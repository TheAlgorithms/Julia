var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = TheAlgorithms","category":"page"},{"location":"#TheAlgorithms","page":"Home","title":"TheAlgorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TheAlgorithms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [TheAlgorithms]","category":"page"},{"location":"#TheAlgorithms.AbstractBinarySearchTree_arr","page":"Home","title":"TheAlgorithms.AbstractBinarySearchTree_arr","text":"array-based binary search tree left tree values < root value < right tree values\n\n\n\n\n\n","category":"type"},{"location":"#TheAlgorithms.AbstractBinaryTree_arr","page":"Home","title":"TheAlgorithms.AbstractBinaryTree_arr","text":"array-based binary tree\n\n\n\n\n\n","category":"type"},{"location":"#TheAlgorithms.BinaryHeap","page":"Home","title":"TheAlgorithms.BinaryHeap","text":"BinaryHeap{T,HT}\n\nA heap data structures implemented as a binary tree. It can be instantiated either as a MinHeap or MaxHeap. In a MinHeap each element in the tree is smaller than its children, and similarly, in a MaxHeap each element is greater than its children, this is called \"Heap Property\".\n\nOne of the most common usage of the Heaps is as a Priority Queue. Note that the element with highest priority will always be at the root of the tree.\n\nIn this implementation, the tree is store in a Vector where the first element (index = 1) is the root and for all elements, it's children will be at index * 2 and index * 2 + 1. The methods are implemented just once for both min and max heap, and it relies on the multiple dispatch of the isbefore function that will depend on the heap type.\n\nFunctions:\n\nMinHeap{T}/MaxHeap{T}: constructors\npush!(heap, elements...): push elements into the heap\ntop(heap): get the top element (smaller in a MinHeap, greater in a MaxHeap)\npop!(heap): get top element and remove it from the heap\nisempty(heap): wheter theres no elemets in the heap\nlength(heap): how many elements are in the heap\n\nExample\n\nheap = MinHeap{Int}()\npush!(heap, 4, 2, 3, 1, 5)\nwhile !isempty(heap)\n    println(pop!(heap))\nend\n\n# output\n\n1\n2\n3\n4\n5\n\nComplexities:\n\nSpace: O(n)\nGet top element: O(1)\nPush a element: O(log n)\nPop a element: O(log n)\nGet number of elements: O(1)\n\nContributed By: Gabriel Soares\n\n\n\n\n\n","category":"type"},{"location":"#TheAlgorithms.DisjointSet","page":"Home","title":"TheAlgorithms.DisjointSet","text":"This can contain a maximum of length(par) parenting-relations par is an array of Int, which is the index of the parent node.\n\n\n\n\n\n","category":"type"},{"location":"#TheAlgorithms.abs_max-Union{Tuple{Vector{N}}, Tuple{N}} where N<:Real","page":"Home","title":"TheAlgorithms.abs_max","text":"abs_max(x)\n\nProgram to find the max absolute value in a vector\n\nExample\n\nabs_max([1,3,4]) # returns 4\nabs_max([-3,1,2]) # returns -3\nabs_max([-7,-3,6]) #returns -7\n\nContributed By:- Ashwani Rathee and Rratic\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.abs_min-Union{Tuple{Vector{N}}, Tuple{N}} where N<:Real","page":"Home","title":"TheAlgorithms.abs_min","text":"abs_min(num)\n\nProgram to find the min absolute value in a vector\n\nExample\n\nabs_min([1,3,4]) # returns 1\nabs_min([-3,1,2]) # returns 1\nabs_min([-7,-3,6]) #returns -3\n\nContributed By:- Ashwani Rathee and Rratic\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.abs_val-Tuple{N} where N<:Real","page":"Home","title":"TheAlgorithms.abs_val","text":"abs_val(num)\n\nProgram to find the absolute value of a number\n\nExample\n\nabs_val(-100) # returns 100\nabs_val(0) # returns 0\nabs(123.1) # returns 123.1\n-1000 == abs_val(-1000) #returns false\n1000 == abs_val(1000) #returns true\n\nContributed By:- Ashwani Rathee and Rratic\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.affine-Tuple{String, String, Int64, Int64}","page":"Home","title":"TheAlgorithms.affine","text":"affine(text, alphabet, nMultiply, nAdd)\n\nProgram to implement affine cipher for the given input. A full description of it can be found on wikipedia.\n\nArguments:\n\ntext : text to be encoded/decoded\nalphabet : the alphaebt the text uses\nnMultiply : the number to the multiply by (a)\nnAdd : the number to add (b)\n\nExamples/Tests\n\n\njulia> affine(\"abcdefghijklmnopqrstuvwxyz\", \"abcdefghijklmnopqrstuvwxyz\", 3, 1)\n\"behknqtwzcfiloruxadgjmpsvy\"\n\njulia> affine(\"whyhellothere\", \"abcdefghijklmnopqrstuvwxyz\", 17, 82)\n\"otwtujjiptuhu\"\n\njulia> affine(\"1234\", \"0123456789\", 5, 2)\n\"9630\"\n\n\nAlgorithm:\n\nAs usual, julia's 1 based indexing doesn't play nicely with the affine cipher, but all that is required is -1 from the initial index of the letter and +1 after the mod.  \n\nAn affine cipher uses a simple function: f(x) = ax + b.\n\nNotes:\n\nnMultiply and length(alphabet) must be coprime so that the two plaintext letters are not substituted for the same cipehrtext letter.\nThis doesn't check that the all of the characters in text actually are in alphabet, but that does need to be the case!\n\n\njoin([\n    alphabet[((findfirst(isequal(letter), alphabet) - 1) * nMultiply + nAdd) % length(alphabet) + 1]\n    for letter in text\n])\n\n\nReferences:\n\nhttps://www.dcode.fr/affine-cipher   https://github.com/Squalm/Cipher-Tools\n\nContributed by: Chirp (Squalm)\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.aliquot_sum-Tuple{Int64}","page":"Home","title":"TheAlgorithms.aliquot_sum","text":"aliquot_sum(n::Int)\n\nThe aliquot sum of a positive integer n is the sum of all the proper divisors of n, i.e, all divisors of n other than n itself.\n\nInput parameters:\n\nn : The number to find the aliquot sum of.\n\nExamples/Tests:\n\naliquot_sum(6)      # returns 6\naliquot_sum(10)     # returns 8\naliquot_sum(1345)   # returns 275\naliquot_sum(-1)     # throws DomainError\n\nReference\n\nhttps://en.wikipedia.org/wiki/Aliquot_sum\n\nContributed by: Praneeth Jain\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.area_circle-Tuple{Any}","page":"Home","title":"TheAlgorithms.area_circle","text":"area_circle(radius)\n\nFinds area of the circle\n\nExample\n\narea_circle(20) # returns 1256.6370614359173\narea_circle(-1) # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.area_ellipse-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.area_ellipse","text":"area_ellipse(radius_x, radius_y)\n\nFinds area of the ellipse\n\nExample\n\narea_ellipse(10, 10) # returns 314.1592653589793\narea_ellipse(10, 20) # returns 628.3185307179587\narea_ellipse(1, -2) # returns DomainError\narea_ellipse(-1, 2) # returns DomainError\narea_ellipse(-1, -2) # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.area_heron_triangle-Tuple{Any, Any, Any}","page":"Home","title":"TheAlgorithms.area_heron_triangle","text":"area_heron_triangle(side1, side2, side3)\n\nFinds area of a triangle using heron's formula\n\nExample\n\narea_heron_triangle(5,12,13) # returns 30.0\narea_heron_triangle(-1,-2,1) # returns DomainError\narea_heron_triangle(1,-2,1)  # returns DomainError\narea_heron_triangle(-1,2,1)  # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.area_parallelogram-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.area_parallelogram","text":"area_parallelogram(base, height)\n\nFinds area of the parallelogram\n\nExample\n\narea_parallelogram(10,20) # returns 200\narea_parallelogram(-1,-2) # returns DomainError\narea_parallelogram(1,-2)  # returns DomainError\narea_parallelogram(-1,2)  # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.area_polygon-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Real","page":"Home","title":"TheAlgorithms.area_polygon","text":"area_polygon(V)\n\nFinds area of any Polygon given by continuous sequence of vertex coordinates Arguments:\n\ncoords: x,y co-ordinates of the vertices   [Vector of Tuples / Matrix with 2 rows or 2 columns]\n\nExample\n\narea_polygon([(0, 0), (100, 0), (0, 100)])  # returns 5000.0\narea_polygon([0 0;100 0;100 100;0 100])  # returns 10000.0\narea_polygon([(6, 4.5), (5, 4.5), (4.5, 5.5), (5, 6.5)]) # returns 1.5\narea_polygon([0 0;100 0]) # returns DomainError\narea_polygon([(6, 4.63), (5, 4.63)]) # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.area_rectangle-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.area_rectangle","text":"area_rectangle(length, width)\n\nFinds area of the rectangle\n\nExample\n\narea_rectangle(10,20) # returns 200\narea_rectangle(-1,-2) # returns DomainError\narea_rectangle(1,-2)  # returns DomainError\narea_rectangle(-1,2)  # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.area_regular_polygon-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.area_regular_polygon","text":"area_regular_polygon(sides, side_len)\n\nFinds area of any regular Polygon\n\nExample\n\narea_regular_polygon(1, 5)  # returns DomainError\narea_regular_polygon(3, 5)  # returns 10.825317547305486\narea_regular_polygon(7, 15)  # returns 817.6302999003576\narea_regular_polygon(-1, 4) # returns DomainError\narea_regular_polygon(4, -3) # returns DomainError\narea_regular_polygon(-12, -4) # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.area_rhombus-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.area_rhombus","text":"area_rhombus(diagonal_1, diagonal_2)\n\nFinds area of the rhombus\n\nExample\n\narea_rhombus(10, 20) # returns 100.0\narea_rhombus(-1,-2) # returns DomainError\narea_rhombus(1,-2)  # returns DomainError\narea_rhombus(-1,2)  # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.area_square-Tuple{Any}","page":"Home","title":"TheAlgorithms.area_square","text":"area_square(side)\n\nFinds area of the area_square\n\nExample\n\narea_square(10) # returns 100\narea_square(-1) # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.area_trapezium-Tuple{Any, Any, Any}","page":"Home","title":"TheAlgorithms.area_trapezium","text":"area_trapezium(base1,base2,height)\n\nFinds area of the traπzium\n\nExample\n\narea_trapezium(10, 20, 30)  # returns 450.0\narea_trapezium(-1, -2, -3)  # returns DomainError\narea_trapezium(-1, 2, 3)    # returns DomainError\narea_trapezium(1, -2, 3)    # returns DomainError\narea_trapezium(1, 2, -3)    # returns DomainError\narea_trapezium(-1, -2, 3)   # returns DomainError\narea_trapezium(1, -2, -3)   # returns DomainError\narea_trapezium(-1, 2, -3)   # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.area_triangle-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.area_triangle","text":"area_triangle(base, height)\n\nFinds area of the right angled triangle with base height\n\nExample\n\narea_triangle(10,10) # returns 50.0\narea_triangle(-1,-2) # returns DomainError\narea_triangle(1,-2)  # returns DomainError\narea_triangle(-1,2)  # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.atbash_encode-Tuple{Any}","page":"Home","title":"TheAlgorithms.atbash_encode","text":"encode(input)\n\nProgram to implement atbash cipher for the given sentence.A full description of the algorithm can be found on wikipedia\n\nArguments:\n\ninput : The sentence needed to rotate\n\nExamples/Tests\n\njulia> atbash_encode(\"test\")\ngvhg\n\njulia> atbash_encode(\"abcdefghijklmnopqrstuvwxyz\")\nzyxwvutsrqponmlkjihgfedcba\n\njulia> atbash_encode(\"hello\")\nsvool\n\n\nAlgorithm:\n\n\nfor r in input\n    part *= xform(r)\n    if length(part) >= 5\n      push!(parts, part)\n      part = \"\"\n    end\n  end\n  if part != \"\"\n    push!(parts, part)\n  end\n  return join(parts, \" \")\n\n\nReferences:\n\nhttps://en.wikipedia.org/wiki/Atbash\n\n```\n\nContributed by:- Ihjass Thasbekha\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.average_absolute_deviation-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Number","page":"Home","title":"TheAlgorithms.average_absolute_deviation","text":"average_absolute_deviation(numbers)\n\nThe average absolute deviation of a data set is the average of the absolute deviations from the mean. It is  a measure of statistical dispersion or variability.\n\nInput parameters:\n\nnumbers : The numbers to find the average absolute deviation of.\n\nExamples/Tests:\n\naverage_absolute_deviation([1, 2, 3, 4, 5])     # returns 1.2\naverage_absolute_deviation([0])                 # returns 0.0\naverage_absolute_deviation([5.5, 64.3, 100.4])  # returns 34.16\n\nReference\n\nhttps://mathworld.wolfram.com/AverageAbsoluteDeviation.html\n\nContributed by Praneeth Jain\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.bab_sqrt-Tuple{Real}","page":"Home","title":"TheAlgorithms.bab_sqrt","text":"bab_sqrt(S::Real; tolerance = 1e-6, guess = nothing)\n\nThe Babylonian Method of calculating a square root is a simple iterative method to determine square roots. A full description of the algorithm can be found on Wikipedia\n\nArguments:\n\nS: The number to calculate the square root for.\n\nPositional Arguments\n\ntolerance: How close the square of the square root needs to be from the input value. abs(S - xn^2) < tolerance\nguess: The initial value to use for xn\n\nExamples/Tests\n\njulia> bab_sqrt(100)\n10.000000000107445\n\njulia> bab_sqrt(100, guess = 15)\n10.000000000131072\n\njulia> bab_sqrt(π, guess = 1)\n1.7724538555800293\n\njulia> bab_sqrt(π, guess = 1, tolerance = 2)\n2.0707963267948966\n\nAlgorithm:\n\nwhile tolerance <= abs(xn^2 - S)\n    xn = (1 / 2) * (xn + S / xn)\nend\n\nReferences:\n\nMethods of computing square roots\n\n```\n\nContributed by:- Anson Biggs\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.bellman_ford","page":"Home","title":"TheAlgorithms.bellman_ford","text":"bellman_ford(graph::Vector{Tuple{Int, Int, Int}}, source::Int)\n\nThe Bellman-Ford algorithm is an algorithm which computes the shortest paths from a single source vertex to all other vertices in a weighted graph. It is slower than Dijkstra's algorithm, which solves the same problem, but it is capable of handling graphs with negative edge weights. Instead of greedily performing the relaxation on the vertices, Bellman-Ford simply relaxes all edges, and does this |V|-1 times.\n\nArguments:\n\ngraph: a directed, weighted graph\nsource: the source vertex from which to begin the traversal\n\nExample\n\ngraph = [\n    (1, 2, 4), (1, 3, 2),\n    (2, 3, 3), (2, 4, 2), (2, 5, 3),\n    (3, 2, 1), (3, 4, 4), (3, 5, 5),\n    (5, 4, -5)\n]\nbellman_ford(graph, 1)\n\n# output\n\n5-element Vector{Int64}:\n 0\n 3\n 2\n 1\n 6\n\nContributed by: Yannick Brenning\n\n\n\n\n\n","category":"function"},{"location":"#TheAlgorithms.bfs","page":"Home","title":"TheAlgorithms.bfs","text":"bfs(graph:Vector{Vector{Int}}, source::Int = 1)\n\nDepth-first search is an algorithm for traversing or searching tree or graph data structures.  The algorithm starts at a given vertex and explores all vertices at the present depth before moving to the next \"level\". This implementation is for educational purposes only, so it simply prints out the vertices in the order that they were traversed.\n\nArguments:\n\ngraph: a directed, unweighted graph\nsource: the source vertex from which to begin the traversal\n\nExample\n\ngraph = [\n    [2, 3, 6], \n    [3, 4],\n    [4],\n    [1, 2, 5],\n    [2],\n    [1, 5]\n]\nbfs(graph, 4)\n\n# output\n\n4 1 2 5 3 6\n\nContributed by: Yannick Brenning\n\n\n\n\n\n","category":"function"},{"location":"#TheAlgorithms.binary_search-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.binary_search","text":"binary_search(list, query; rev=false, lt=<, by=identity)\n\nImplement a binary search algorithm. Searching a sorted collection is a common task. A dictionary is a sorted list of word definitions. Given a word, one can find its definition. A telephone book is a sorted list of people's names, addresses, and telephone numbers. Knowing someone's name allows one to quickly find their telephone number and address.\n\nIf the list to be searched contains more than a few items (a dozen, say) a binary search will require far fewer comparisons than a linear search, but it imposes the requirement that the list be sorted.\n\nIn computer science, a binary search or half-interval search algorithm finds the position of a specified input value (the search \"key\") within an array sorted by key value.\n\nIn each step, the algorithm compares the search key value with the key value of the middle element of the array.\n\nIf the keys match, then a matching element has been found and the range of indices that equal the search key value are returned.\n\nOtherwise, if the search key is less than the middle element's key, then the algorithm repeats its action on the sub-array to the left of the middle element or, if the search key is greater, on the sub-array to the right.\n\nIf the remaining array to be searched is empty, then the key cannot be found in the array and a special \"not found\" indication is returned. Search methods in Julia typically return an empty range located at the insertion point in this case.\n\nA binary search halves the number of items to check with each iteration, so locating an item (or determining its absence) takes logarithmic time. A binary search is a dichotomic divide and conquer search algorithm.\n\nBonus task: Implement keyword arguments by, lt and rev so that by specifies a transformation applied to all elements of the list, lt specifies a comparison and rev specifies if the list is ordered in reverse.\n\nContributed By:- Soc Virnyl Estela\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.binary_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T<:Real","page":"Home","title":"TheAlgorithms.binary_search","text":"binary_search(arr::AbstractArray{T,1}, l::T, r::T, x::T) where {T<:Real}\n\nThe implementation of this binary Search is recursive and requires O(Log n) space. With iterative Binary Search, we need only O(1) space. Useful for the implementation of exponential_search.\n\nContributed By:- Ash\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.caesar-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.caesar","text":"caesar(rot, s)\n\nProgram to implement rotational cipher for the given sentence. A full description of the algorithm can be found on wikipedia\n\nArguments:\n\nrot: The number of rotations needed.\ns : The sentence needed to rotate\n\nExamples/Tests\n\njulia> caesar(13,\"abcdefghijklmnopqrstuvwxyz\")\nnopqrstuvwxyzabcdefghijklm\n\njulia> caesar(5,\"omg\")\ntrl\n\njulia> caesar(0,\"hello\")\nhello\n\n\nAlgorithm:\n\n\nif r >= 'a' && r <= 'z'\n    v = ((r - 'a') + rot) % 26\n    return v + 'a'\nend\nif r >= 'A' && r <= 'Z'\n    v = ((r - 'A') + rot) % 26\n    return v + 'A'\nend\nreturn r\n\n\nReferences:\n\nhttps://en.wikipedia.org/wiki/Caesar_cipher\n\n```\n\nContributed by:- Ihjass Thasbekha\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.catalan-Tuple{Int64}","page":"Home","title":"TheAlgorithms.catalan","text":"catalan(n::Int)\n\nIn combinatorial mathematics, the Catalan numbers are a sequence of natural numbers that occur in various counting problems, often involving recursively defined objects.\n\nInput parameters:\n\nn : index of the catalan number.\n\nExamples/Tests:\n\ncatalan(0)  # returns 1\ncatalan(3)  # returns 5\ncatalan(8)  # returns 1430\ncatalan(-1) # throws DomainError\n\nReference\n\nhttps://mathworld.wolfram.com/CatalanNumber.html\n\nContributed by: Praneeth Jain\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.ceil_val-Tuple{Any}","page":"Home","title":"TheAlgorithms.ceil_val","text":"ceil_val(x)\n\nFinds the ceiling of x as an functionInteger\n\nExample\n\nceil_val(1.3)   # 2.0\nceil_val(2.0)   # returns 2.0\nceil_val(-1.5)  #returns -1.0\n\nReference\n\nhttps://en.wikipedia.org/wiki/Floorandceiling_functions\n\nContributed By:- Ashwani Rathee\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.celsius_to_fahrenheit","page":"Home","title":"TheAlgorithms.celsius_to_fahrenheit","text":"celsiustofahrenheit(celsius, ndigits::Int = 2)\n\nConverts celsius to fahrenheit and round to 2 decimal places\n\nExample\n\ncelsius_to_fahrenheit(273.354, 3) == 524.037  # returns true\ncelsius_to_fahrenheit(273.354, 0) == 524.0    # returns true\ncelsius_to_fahrenheit(-40.0) == -40.0         # returns true\ncelsius_to_fahrenheit(-20.0) == -4.0          # returns true\ncelsius_to_fahrenheit(0) == 32.0              # returns true\ncelsius_to_fahrenheit(20) == 68.0             # returns true\n\n\n\n\n\n","category":"function"},{"location":"#TheAlgorithms.celsius_to_kelvin","page":"Home","title":"TheAlgorithms.celsius_to_kelvin","text":"function celsiustokelvin(celsius, ndigits::Int = 2)\n\nConverts celsius to kelvin and round to 2 decimal places\n\nExample\n\ncelsius_to_kelvin(273.354, 3) == 546.504    # returns true\ncelsius_to_kelvin(273.354, 0) == 547.0      # returns true\ncelsius_to_kelvin(0.0) == 273.15            # returns true\ncelsius_to_kelvin(20.0) == 293.15           # returns true\n\n\n\n\n\n","category":"function"},{"location":"#TheAlgorithms.coin_change-Tuple{Vector{Int64}, Int64}","page":"Home","title":"TheAlgorithms.coin_change","text":"coin_change(coins::Vector{Int}, amount::Int)\n\nGiven a vector coins of coin values, calculates the minimum number of coins that sums to amount. It's considered that a unlimited number of coins for each value is available.\n\nArguments:\n\ncoins: the coins values available\namount: the total amount that need to be summed to\n\nExamples\n\njulia> n_coins, coins = coin_change([1, 3, 4, 7], 13);\n\njulia> n_coins\n3\n\njulia> coins\n3-element Vector{Int64}:\n 3\n 3\n 7\n\njulia> n_coins, coins = coin_change([2, 4, 6], 23)\n(-1, Int64[])\n\njulia> n_coins\n-1\n\njulia> coins\nInt64[]\n\nContributors:\n\nGabriel Soares\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N<:Number, V<:(AbstractVector)}","page":"Home","title":"TheAlgorithms.complete_pack!","text":"This does complete/infinite (each item can be chosen infinite times) knapsack : pack capacity = capacity weight of each item = weights value of each item = values dp array is what the function works on It returns the ans (dp[capacity])\n\njulia> dp=zeros(Int,30)\njulia> complete_pack!(20,[1,2,9],[1,3,20],dp)\n43\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N<:Number, V<:(AbstractVector)}","page":"Home","title":"TheAlgorithms.complete_pack!","text":"This does complete/infinite (each item can be chosen infinite times) knapsack : pack capacity = capacity weight of each item = weights value of each item = values\n\nEach loop the function will find the highest value in the array and check if the capacity is enough to store it, if enough then  the value will be added into the totalmaxvalue until the capacity cannot hold the weight of the highest current value.  After that the highest current value will be deleted.\n\njulia> complete_pack!(20,[1,2,9],[1,3,20])\n43\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.count_nucleotides-Tuple{AbstractString}","page":"Home","title":"TheAlgorithms.count_nucleotides","text":"count_nucleotides(s::AbstractString)\n\nGiven: A DNA string s\n\nof length at most 1000 nt.\n\nReturn: Four integers (separated by spaces) counting the respective number of times that the symbols 'A', 'C', 'G', and 'T' occur in s\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.counting_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Int64}, Tuple{Vector{T}, Int64, Int64}} where T","page":"Home","title":"TheAlgorithms.counting_sort!","text":"Counting Sort\n\nOVERVIEW: Counting Sort is a sorting algorithm that sort elements within a specific range. The sorting technique is to count the existing element and stored its occurrence time in a new list, then only print it out.\n\nSTEPS:  Assume the input as –> x=[-3, 1, -5, 0, -3]   minimum = -5\n\nSTEP 1: Create a list size within the range, in this case is -5 –> 1 which have range of 7 (-5, -4, -3, -2, -1, 0, 1), so list with size 7 and assign all to 0 is created\nSTEP 2: Count the occurances of element in the list          First number = -3 it is the third number in the range, so count[3]+=1         Final view:         index : ( 1,  2,  3,  4,  5, 6, 7)         range : (-5, -4, -3, -2, -1, 0, 1)         count : [ 1,  0,  2,  0,  0, 1, 1] <– the list will store this occurrence\nSTEP 3: Make the count list accumulate the occurances          The final count is (1, 1, 3, 3, 3, 4, 5)\nSTEP 4: Assign the elements in x into correct possition by creating a new list (will call 'output' in this sample)         the 1st element in 'x' is -3, it is third in range, so it will call the index of 3 in 'count', which is 3 and assign the -3 in to 3rd position in 'output',          then the third element in range will deduct by 1, so the next repeated element will get the correct position, new 'count' –> [1, 1, 2, 3, 3, 4, 5]\n    the 2nd element in 'x' is  1, it is last  in range, so it will call the index of 7 in 'count', which is 5 and assign the  1 in to 5th position in 'output', \n    new 'count' --> [1, 1, 2, 3, 3, 4, 4]\n    ......\n    ......\n    *If you want the order of original array to have the same order as the output array use can change this to decremental for loop\nSTEP 5: Assign the 'output' list back to 'x'\n\nFINAL RESULT –>  [-5, -3, -3, 0, 1]                                                                                    \n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.detect_anagrams-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.detect_anagrams","text":"detect_anagrams(subject, candidates)\n\nA function that checks if a list of words is an Anagram or not of a subject word.\n\nis the original word = subject is list of words to be compared if they are an anagram of subject = candidates\n\njulia> subject = \"listen\"\njulia> candidates = [\"inlets\", \"enlists\", \"google\", \"banana\"]\njulia> detect_anagrams(subject, candidates)\n1-element Vector{String}:\n \"inlets\"\n\nContributed By:- Soc V. E. Based on my exercism's Julia track problem solution on Anagrams.\n\nInstructions:\n\nAn anagram is a rearrangement of letters to form a new word. Given a word and a list of candidates, select the sublist of anagrams of the given word. Given \"listen\" and a list of candidates like \"enlists\" \"google\" \"inlets\" \"banana\" the program should return a list containing \"inlets\".\n\nInspired by the Extreme Startup game\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.determinant-Tuple{Any}","page":"Home","title":"TheAlgorithms.determinant","text":"determinant(mat)\n\nGiven a non singluar matrix, calculate its determinant using LU decomposition.\n\nL and U are lower triangular and upper triangular matrices respectively such that\n\nA = L*U\n\nIf we want to find the determinant, then\n\ndet(A) = det(LU) = det(L)*det(U)\n\nDeterminant of triangualar matrices is the product of their diagonal entries. Hence, makes finding the determinant easy.\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.dfs","page":"Home","title":"TheAlgorithms.dfs","text":"dfs(graph::Vector{Vector{Int}}, source::Int)\n\nDepth-first search is an algorithm for traversing or searching tree or graph data structures.  The algorithm starts at a given vertex and explores as far as possible along each branch before backtracking. This implementation is for educational purposes only, so it simply prints out the vertices in the order that they were traversed.\n\nArguments:\n\ngraph: a directed, unweighted graph\nsource: the source vertex from which to begin the traversal\n\nExample\n\ngraph = [\n    [2, 3, 6], \n    [3, 4],\n    [4],\n    [1, 2, 5],\n    [2],\n    [1, 5]\n]\ndfs(graph, 6)\n\n# output\n\n6 5 2 4 3 1\n\nContributed by: Yannick Brenning\n\n\n\n\n\n","category":"function"},{"location":"#TheAlgorithms.dijkstra-Tuple{Vector{Vector{Tuple{Int64, Int64}}}, Int64}","page":"Home","title":"TheAlgorithms.dijkstra","text":"dijkstra(graph::Vector{Vector{Tuple{Int,Int}}}, source::Int)\n\nGiven a directed graph with weights on the arcs and a source vertex, the dijkstra algorithm calculates the distance from the source to all other vertices, and the solution tree associated with those distances. The solution tree is given by a vector prev which stores the source of the arc that arrives at each vertex. By definition: distance[source] = prev[source] = 0. If a vertex v is not reachable from the source, then distance[v] = prev[v] = -1.\n\nArguments:\n\ngraph: a directed graph with weights on the arcs\nsource: the source vertex from which the distances will be calculated\n\nExample\n\ngraph = [\n    [(2, 8), (3, 6), (4, 4)],\n    [(3, 1), (5, 5)],\n    [(5, 4)],\n    [(2, 3), (5, 9)],\n    [(1, 2), (3, 2), (4, 5)],\n    [(1, 1), (4, 3)],\n]\ndistances, prev = dijkstra(graph, 1)\n\nprintln(\"v | dist | path\")\nfor v in eachindex(graph)\n    distance = distances[v] == -1 ? \"  NR\" : lpad(distances[v], 4) # NR: Non Reachable\n    path = join(get_dijkstra_path(prev, v), \" -> \")\n    println(\"$v | $distance | $path\")\nend\n\n# output\n\nv | dist | path\n1 |    0 | 1\n2 |    7 | 1 -> 4 -> 2\n3 |    6 | 1 -> 3\n4 |    4 | 1 -> 4\n5 |   10 | 1 -> 3 -> 5\n6 |   NR | \n\nContributed By: Gabriel Soares\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.divisors-Tuple{Int64}","page":"Home","title":"TheAlgorithms.divisors","text":"divisors(n::Int)\n\nReturns the divisors of n as a vector.\n\nInput parameters:\n\nn : The number to find the factors of.\n\nExamples/Tests:\n\ndivisors(6)     # returns [1, 2, 3, 6]\ndivisors(10)    # returns [1, 2, 5, 10]\ndivisors(1345)  # returns [1, 5, 269, 1345]\ndivisors(-1)    # throws DomainError\n\nReference\n\nhttps://mathworld.wolfram.com/Divisor.html\n\nContributed by: Praneeth Jain\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.dna2rna-Tuple{AbstractString}","page":"Home","title":"TheAlgorithms.dna2rna","text":"dna2rna(s::AbstractString)\n\nGiven: A DNA string t\n\nhaving length at most 1000 nt.\n\nReturn: The transcribed RNA string of t\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.eratosthenes-Tuple{Any}","page":"Home","title":"TheAlgorithms.eratosthenes","text":"Sieve of Eratosthenes is an algorithm for finding all the primes upto a limit n.\n\nReference: -https://en.wikipedia.org/wiki/SieveofEratosthenes\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.euler_method","page":"Home","title":"TheAlgorithms.euler_method","text":"euler_method(f, x0, span, h=1.0e-2)\n\nCalculate the solution to a differential equation using forward euler method.\n\n\n\n\n\n","category":"function"},{"location":"#TheAlgorithms.exponential_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T<:Real","page":"Home","title":"TheAlgorithms.exponential_search","text":" exponential_search(arr::AbstractArray{T,1}, x::T) where {T <: Real}\n\nExponential Search in 1-D array Time Complexity:  O(Log n)\n\nExponential Search\n\nIt works in O(Log n) time Exponential search involves two steps:\n\nFind range where element is present\nDo Binary Search in above found range.\n\nTime Complexity :\n\nO(Log n) Applications of Exponential Search: Exponential Binary Search is particularly useful for unbounded searches, where size of array is infinite. Please refer Unbounded Binary Search for an example. It works better than Binary Search for bounded arrays, and also when the element to be searched is closer to the first element.\n\nContributed By:- Ash\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.factorial_iterative-Tuple{N} where N<:Integer","page":"Home","title":"TheAlgorithms.factorial_iterative","text":"factorial_iterative(n)\n\nFinds factorial of a number using Iterative method\n\nExample\n\nfactorial_iterative(5)      # returns 120\nfactorial_iterative(-1)     # returns error\n\nReference\n\nfactorial of a positive integer – https://en.wikipedia.org/wiki/Factorial\n\nContributed By:- Ashwani Rathee and Rratic\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.factorial_recursive-Tuple{N} where N<:Integer","page":"Home","title":"TheAlgorithms.factorial_recursive","text":"factorial_recursive(n)\n\nFinds factorial of a number using recursive method\n\nExample\n\nfactorial_recursive(5)      # returns 120\n\nReference\n\nfactorial of a positive integer – https://en.wikipedia.org/wiki/Factorial\n\nContributed By:- Ashwani Rathee and Rratic\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.fahrenheit_to_celsius","page":"Home","title":"TheAlgorithms.fahrenheit_to_celsius","text":"fahrenheittocelsius(fahrenheit, ndigits::Int = 2)\n\nConverts fahrenheit to celsius and round to 2 decimal places\n\nExample\n\nfahrenheit_to_celsius(273.354, 3) == 134.086 # returns true\nfahrenheit_to_celsius(273.354, 0) == 134.0   # returns true\nfahrenheit_to_celsius(0.0) == -17.78         # returns true\nfahrenheit_to_celsius(20.0) == -6.67         # returns true\nfahrenheit_to_celsius(40.0) == 4.44          # returns true\nfahrenheit_to_celsius(60.0) == 15.56         # returns true\nfahrenheit_to_celsius(80.0) == 26.67         # returns true\n\n\n\n\n\n","category":"function"},{"location":"#TheAlgorithms.fahrenheit_to_kelvin","page":"Home","title":"TheAlgorithms.fahrenheit_to_kelvin","text":"fahrenheittokelvin(fahrenheit, ndigits::Int = 2)\n\nConverts fahrenheit to kelvin and round to 2 decimal places\n\nExample\n\nfahrenheit_to_kelvin(273.354, 3) == 407.236 # returns true\nfahrenheit_to_kelvin(273.354, 0) == 407.0   # returns true\nfahrenheit_to_kelvin(0) == 255.37           # returns true\nfahrenheit_to_kelvin(20.0) == 266.48        # returns true\nfahrenheit_to_kelvin(40.0) == 277.59        # returns true\nfahrenheit_to_kelvin(60.0) == 288.71        # returns true\nfahrenheit_to_kelvin(80.0) == 299.82        # returns true\n\n\n\n\n\n","category":"function"},{"location":"#TheAlgorithms.fcfs-Tuple{Any, Any, Any}","page":"Home","title":"TheAlgorithms.fcfs","text":"fcfs(n, process_id, burst_time)\n\nImplementation of first come first served scheduling algorithm\n\nOutput\n\nTuple of vectors (processid, bursttime, waitingtime, turnaroundtime, avgwaitingtime, avgturnaroundtime)\n\nExample\n\nn = 3 # number of processes\nprocess_id = Any[1, 2, 3] # process ids\nburst_times = Any[3, 4, 5] # burst times\nfcfs(n, process_id, burst_times)\n\nReference\n\nhttps://en.wikipedia.org/wiki/Scheduling(computing)#Firstcome,firstserved\n\nContributed By:- Ashwani Rathee\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.fib_iterative-Tuple{Int64}","page":"Home","title":"TheAlgorithms.fib_iterative","text":"fib_iterative(n::Int)\n\nFinds the first n fibonacci number using iterative method.\n\nArguments:\n\nn : Number of fibonacci numbers required\n\nExamples/Tests\n\nfib_iterative(1)    # returns [0]\nfib_iterative(2)    # returns [0, 1]\nfib_iterative(6)    # returns [0, 1, 1, 2, 3, 5]\nfib_iterative(10)   # returns [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\nfib_iterative(-1)   # throws DomainError\n\nReference\n\nhttps://mathworld.wolfram.com/FibonacciNumber.html\n\nContributed by Praneeth Jain\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.fib_recursive-Tuple{Int64}","page":"Home","title":"TheAlgorithms.fib_recursive","text":"fib_recursive(n::Int)\n\nFinds the first n fibonacci number using recursive method.\n\nArguments:\n\nn : Number of fibonacci numbers required\n\nExamples/Tests\n\nfib_recursive(1)    # returns [0]\nfib_recursive(2)    # returns [0, 1]\nfib_recursive(6)    # returns [0, 1, 1, 2, 3, 5]\nfib_recursive(10)   # returns [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\nfib_recursive(-1)   # throws DomainError\n\nReference\n\nhttps://mathworld.wolfram.com/FibonacciNumber.html\n\nContributed by Praneeth Jain\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.fib_recursive_memo-Tuple{Int64}","page":"Home","title":"TheAlgorithms.fib_recursive_memo","text":"fib_recursive_memo(n::Int)\n\nFinds the first n fibonacci number using recursive method and memoization.\n\nArguments:\n\nn : Number of fibonacci numbers required\n\nExamples/Tests\n\nfib_recursive_memo(1)    # returns [0]\nfib_recursive_memo(2)    # returns [0, 1]\nfib_recursive_memo(6)    # returns [0, 1, 1, 2, 3, 5]\nfib_recursive_memo(10)   # returns [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\nfib_recursive_memo(-1)   # throws DomainError\n\nReference\n\nhttps://mathworld.wolfram.com/FibonacciNumber.html\n\nContributed by Praneeth Jain\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.find-Tuple{DisjointSet, Int64}","page":"Home","title":"TheAlgorithms.find","text":"Find the ancestor of node x.\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.floor_val-Tuple{Any}","page":"Home","title":"TheAlgorithms.floor_val","text":"floor_val(x)\n\nFinds the floor of x as an Integer\n\nExample\n\nfloor_val(1.3)  # 1\nfloor_val(2.0)  # returns 2.0\nfloor_val(-1.7) # returns -2.0\n\nReference\n\nhttps://en.wikipedia.org/wiki/Floorandceiling_functions\n\nContributed By:- Ashwani Rathee\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.gauss_jordan-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T<:Number","page":"Home","title":"TheAlgorithms.gauss_jordan","text":"gauss_jordan(A::AbstractMatrix{T}) where T<:Number\n\nGaussian elimination, also known as row reduction, is an algorithm for solving systems of linear equations.  It consists of a sequence of operations performed on the corresponding matrix of coefficients.  This method can also be used to compute the rank of a matrix, the determinant of a square matrix, and the inverse of an invertible matrix. https://en.wikipedia.org/wiki/Gaussian_elimination\n\nExamples/Tests\n\njulia> M1 = [1 2 3; 4 5 6];\njulia> M2 = [1 2 3; 4 8 12];\n\njulia> @test gauss_jordan(M1) == [1 0 -1; 0 1 2]        # Test Passed\njulia> @test_throws AssertionError gauss_jordan(M2)     # Test Passed - Thrown: AssertionError\n\nContributed By:- AugustoCL\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.get_dijkstra_path-Tuple{Vector{Int64}, Int64}","page":"Home","title":"TheAlgorithms.get_dijkstra_path","text":"get_dijkstra_path(tree::Vector{Int}, dest::Int)\n\nGiven a solution tree from the dijkstra algorithm, extract the path from the source to dest, including them.\n\nArguments:\n\ntree: solution tree from the dijkstra algorithm\ndest: path's destionation vertex\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.get_mersenne_primes-Tuple{Int64}","page":"Home","title":"TheAlgorithms.get_mersenne_primes","text":"get_mersenne_primes(n::Int)\n\nA mersenne prime is a prime number that is one less than a power of 2. Returns a list of mersenne primes upto n.\n\nInput parameters:\n\nn : The limit upto which mersenne primes are to be generated.\n\nExamples/Tests:\n\nget_mersenne_primes(100)    # returns [3, 7, 31]\nget_mersenne_primes(1000)   # returns [3, 7, 31, 127]\nget_mersenne_primes(10000)  # returns [3, 7, 31, 127, 8191]\n\nReference\n\nhttps://mathworld.wolfram.com/MersennePrime.html\n\nContributed by Praneeth Jain\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.heap_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Any}, Tuple{Vector{T}, Any, Int64}} where T","page":"Home","title":"TheAlgorithms.heap_sort!","text":"heap_sort!(arr::Vector{T}, gt = >, N::Int = length(arr)) where {T}\n\nSort the given vector (in-place) using the Heapsort algorithm.\n\nHeapsort consists of two stages:\n\nBuilding a (max) heap of the array\nRepeatedly extracting the largest element and inserting it at the front of the sorted part of the array\n\nAfter the largest element has been extracted, the tree is updated to maintain the heap property via a \"sifting\" operation.\n\nStoring a heap in an array is pretty straightforward - for every node with index n, its children are stored at indices   2n + 1 and 2n + 2 (for 0-based indices). Index 0 contains the root node.   Since Julia's indices are 1-based, we need to change this a little bit. We're using a trivial helper function    idx_for to convert from 0-based to 1-based.\n\nSee https://en.wikipedia.org/wiki/Heapsort for a complete explanation of Heapsort.\n\nContributed By:- Frank Schmitt\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.idx_for-Tuple{Int64}","page":"Home","title":"TheAlgorithms.idx_for","text":"idx_for(i::Int)\n\nSimple helper function for converting 0-based indices to Julia's 1-based indices.\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.interpolation_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T<:Real","page":"Home","title":"TheAlgorithms.interpolation_search","text":" interpolation_search(arr::AbstractArray{T,1}, l::T, r::T, x::T) where {T <: Real}\n\nInterpolation Search in 1-D array Time Complexity: O(log2(log2 n))\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.is_armstrong-Tuple{Any}","page":"Home","title":"TheAlgorithms.is_armstrong","text":"is_armstrong(x)\n\nProgram to check if a number is an Armstrong/Narcissistic number in decimal system.\n\nArmstrong number is a number that is the sum of its own digits raised to the power of the number of digits.\n\nContributed By:- Ashwani Rathee\n\nA positive integer is called an Armstrong number (of order n) if\n\nabcd... = a^n + b^n + c^n + d^n +....\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.is_mersenne_prime-Tuple{Int64}","page":"Home","title":"TheAlgorithms.is_mersenne_prime","text":"is_mersenne_prime(n::Int)\n\nA mersenne prime is a prime number that is one less than a power of 2. Checks whether the given integer is a mersenne prime.\n\nInput parameters:\n\nn : The number to be checked.\n\nExamples/Tests:\n\nis_mersenne_prime(3)     # returns true\nis_mersenne_prime(15)    # returns false\nis_mersenne_prime(8191)  # returns true\n\nReference\n\nhttps://mathworld.wolfram.com/MersennePrime.html\n\nContributed by Praneeth Jain\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.isbefore-Union{Tuple{T}, Tuple{MinHeap{T}, T, T}} where T","page":"Home","title":"TheAlgorithms.isbefore","text":"isbefore(heap, x, y)\n\nWhether x comes before y in the heap ordering.\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.ispangram-Tuple{Any}","page":"Home","title":"TheAlgorithms.ispangram","text":"ispangram(input)\n\nProgram to determine the sentence is pangram or not.The program will return true if it is pangram and false if it is not.A full description of the algorithm can be found on exercism\n\nArguments:\n\ninput: The sentence to find if its pangram or not.\n\nExamples/Tests\n\njulia> ispangram(Pack my box with five dozen liquor jugs)\ntrue\n\njulia> ispangram(The quick brown fox jumps over the lazy dog)\ntrue\n\njulia> wordcount(hello world!!!)\nfalse\n\n\nAlgorithm:\n\n\nfor letter in input\n    if 'A' <= letter <= 'Z'\n        x &= ~(1<<(letter-'A'))\n    elseif 'a' <= letter <= 'z'\n        x &= ~(1<<(letter-'a'))\n    end\n    x == 0 && return true\nend\n\n\nReferences:\n\n(https://exercism.org/tracks/julia/exercises/pangram)\n\n```\n\nContributed by:- Ihjass Thasbekha\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.jump_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}, Tuple{AbstractVector{T}, T, T}} where T<:Real","page":"Home","title":"TheAlgorithms.jump_search","text":"jump_search(arr::AbstractArray{T,1}, x::T, jump::T = Int(ceil(sqrt(n)))) where {T <: Real}\n\nJump Search in 1-D array Time Complexity :  O(√ n) Time complexity of Jump Search is between Linear Search ( ( O(n) ) and Binary Search ( O (Log n) )\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.kelvin_to_celsius","page":"Home","title":"TheAlgorithms.kelvin_to_celsius","text":"function kelvintocelsius(kelvin, ndigits::Int = 2)\n\nConverts kelvin to celsius and round to 2 decimal places\n\nExample\n\nkelvin_to_celsius(273.354, 3) == 0.204   # returns true\nkelvin_to_celsius(273.354, 0) == 0.0     # returns true\nkelvin_to_celsius(273.15) == 0.0         # returns true\nkelvin_to_celsius(300) == 26.85          # returns true\n\n\n\n\n\n","category":"function"},{"location":"#TheAlgorithms.kelvin_to_fahrenheit","page":"Home","title":"TheAlgorithms.kelvin_to_fahrenheit","text":"function kelvintofahrenheit(kelvin, ndigits::Int = 2)\n\nConverts kelvin to fahrenheit and round to 2 decimal places\n\nExample\n\nkelvin_to_fahrenheit(273.354, 3) == 32.367  # returns true\nkelvin_to_fahrenheit(273.354, 0) == 32.0    # returns true\nkelvin_to_fahrenheit(273.15) == 32.0        # returns true\nkelvin_to_fahrenheit(300) == 80.33          # returns true\n\n\n\n\n\n","category":"function"},{"location":"#TheAlgorithms.krishnamurthy-Tuple{Any}","page":"Home","title":"TheAlgorithms.krishnamurthy","text":"krishnamurthy(number)\n\nCheck if a number is a Krishnamurthy number or not\n\nDetails\n\nIt is also known as Peterson Number. \n\nA Krishnamurthy Number is a number whose sum of the factorial of the digits equals to the original number itself.\n\nFor example: 145 = 1! + 4! + 5!     So, 145 is a Krishnamurthy Number\n\nExample\n\nkrishnamurthy(145) # returns true\nkrishnamurthy(240) # returns false\nkrishnamurthy(1)   # returns true \n\nContributed By:- Ashwani Rathee\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.line_length","page":"Home","title":"TheAlgorithms.line_length","text":"line_length(f, x_start, x_end, steps=100)\n\nApproximates the arc length of a line segment by treating the curve as a sequence of linear lines and summing their lengths.\n\nArguments:\n\nf: function that returns the arc\nx_start: starting x value\nxend: ending xvalue\nsteps: steps to take for accurace, more the steps greater the accuracy\n\n\n\n\n\n","category":"function"},{"location":"#TheAlgorithms.linear_search-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.linear_search","text":"linear_search(array, key)\n\nA simple search of array, element per element until key is found.\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.lu_decompose-Tuple{Any}","page":"Home","title":"TheAlgorithms.lu_decompose","text":"lu_decompose(mat)\n\nDecomposes a n x n non singular matrix into a lower triangular matrix (L) and an upper triangular matrix (U)\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.mean-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Number","page":"Home","title":"TheAlgorithms.mean","text":"mean(nums)\n\nFind mean of a vector of numbers\n\nExample\n\nmean([3, 6, 9, 12, 15, 18, 21])      # returns 12.0\nmean([5, 10, 15, 20, 25, 30, 35])    # returns 20.0\nmean([1, 2, 3, 4, 5, 6, 7, 8])       # returns 4.5\n\nContributed By:- Ashwani Rathee and Rratic\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.median-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Number","page":"Home","title":"TheAlgorithms.median","text":"median(nums)\n\nFinds median of a vector of numbers\n\nExample\n\nmedian([2,1,3,4])                   # returns 2.5\nmedian([2, 70, 6, 50, 20, 8, 4])    # returns 8\nmedian([0])                         # returns 0\n\nContributed By:- Ashwani Rathee and Rratic\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.mode-Tuple{Any}","page":"Home","title":"TheAlgorithms.mode","text":"mode(nums)\n\nFinds mode of a vector of numbers\n\nExample\n\nmode([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2])        # returns [2]\nmode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2])        # returns [2]\nmode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2])  # returns [2, 4]\nmode([\"x\", \"y\", \"y\", \"z\"])                              # returns [\"y\"]\nmode([\"x\", \"x\" , \"y\", \"y\", \"z\"])                       # returns [\"x\", \"y\"]\n\nContributed By:- Ashwani Rathee\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.monte_carlo_integration-Tuple{Function, Real, Real, Int64}","page":"Home","title":"TheAlgorithms.monte_carlo_integration","text":"monte_carlo_integration(f::Function, a::Real, b::Real, n::Int)\n\nMonte carlo integration is a very easy and scalable way to do multidimentional integrals. However, only single variable integrals are considered.\n\nArguments\n\nf: the function to integrate. (at the momment only single variable is suported)\na: start in the integration limits.\nb: endin the integration limits.\nN: Number of points to sample. For most simple functions, 1000 to 10,000 should be okay.\n\nExamples\n\njulia> monte_carlo_integration(x -> 3*x^2, 0, 1, 100000) # integrate a polynomial\n1.0000037602209\n\njulia> monte_carlo_integration(x -> sin(x), 0, pi, 1000) # integrate the sin function\n2.0018927826323756\n\nReferences\n\nhttps://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration\nhttps://kingaa.github.io/sbied/pfilter/monteCarlo.html\n\nContributors\n\nAugustoCL\nVed Mahajan\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.partitions_recursive-Tuple{N} where N<:Integer","page":"Home","title":"TheAlgorithms.partitions_recursive","text":"partitions_recursive(n)\n\nFinds partitions of an integer using recursion.\n\nA partition of a positive integer n, also called an integer partition, is a way of writing n as a sum of positive integers.\n\nThere are 7 partitions of 5: 5 4 + 1 3 + 2 3 + 1 + 1 2 + 2 + 1 2 + 1 + 1 + 1 1 + 1 + 1 + 1 + 1\n\nPartitions of n is equal to the sum of partitions of n with k parts.\n\nP left ( n right ) = sum_k=1^n P_k left ( n right )\n\nPartitions of n with k parts is the sum of partitions of n-1 with k-1 parts and, partitions of n-k with k parts.\n\nP_kleft ( n right ) =  P_k-1left ( n - 1 right ) + P_kleft ( n - k right )\n\nExample\n\npartitions_recursive(0)      # returns 1\npartitions_recursive(1)      # returns 1\npartitions_recursive(10)     # returns 42\npartitions_recursive(-1)     # returns DomainError\n\nReferences\n\nPartitions of a positive integer – https://en.wikipedia.org/wiki/Partitionfunction(number_theory)\nPartitions of a positive integer – https://www.whitman.edu/mathematics/cgt_online/book/section03.03.html\n\nContributor\n\nVaishakh C R\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.perfect_cube-Tuple{N} where N<:Integer","page":"Home","title":"TheAlgorithms.perfect_cube","text":"perfect_cube(number)\n\nCheck if a number is a perfect cube or not.\n\nExample\n\nperfect_cube(27) # returns true\nperfect_cube(4)  # returns false\n\nContributed By:- Ashwani Rathee and Rratic\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.perfect_number-Tuple{N} where N<:Number","page":"Home","title":"TheAlgorithms.perfect_number","text":"perfect_number(number)\n\nChecks if a number is a perfect_number number or not\n\nDetails\n\nperfect_number number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself.\n\nFor example : 6 is perfect_number number\n\nDivisors of 6 => [1,2,3]\n\nSum of divisors => 1+2+3 = 6\n\n6 == sum(divisors) # which is true\n\nExample\n\nperfect_number(27)     # returns false\nperfect_number(28)     # returns true\nperfect_number(496)    # returns true\nperfect_number(8128)   # returns true\nperfect_number(123)    # returns false\n\nContributed By:- Ashwani Rathee and Rratic\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.perfect_square-Tuple{N} where N<:Integer","page":"Home","title":"TheAlgorithms.perfect_square","text":"perfect_square(number)\n\nCheck if a number is a perfect square or not.\n\nExample\n\nperfect_square(9)   # returns True\nperfect_square(16)  # returns True\nperfect_square(1)   # returns True\nperfect_square(0)   # returns True\nperfect_square(10)  # returns False\nperfect_square(-9)  # returns False\n\nContributed By:- Ashwani Rathee and Rratic\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.prime_check-Tuple{N} where N<:Integer","page":"Home","title":"TheAlgorithms.prime_check","text":"prime_check(number)\n\nChecks to see if a number is a prime or not\n\nA number is prime if it has exactly two factors: 1 and itself.\n\nExample\n\nprime_check(2) # returns true\nprime_check(3) # returns true\nprime_check(5) # returns true\nprime_check(7) # returns true\nprime_check(11) # returns true\nprime_check(13) # returns true\nprime_check(17) # returns true\nprime_check(19) # returns true\nprime_check(23) # returns true\nprime_check(29) # returns true\nprime_check(30) # returns false\n\nContributed By:- Ashwani Rathee and Rratic\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.prime_factors-Tuple{N} where N<:Integer","page":"Home","title":"TheAlgorithms.prime_factors","text":"prime_factors(number)\n\nReturns prime factors of number as a vector\n\nExample\n\nprime_factors(50)          # returns [2,5,5]\nprime_factors(0)           # returns []\nprime_factors(100)         # returns [2, 2, 5, 5]\nprime_factors(2560)        # returns [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]\n\nContributed By:- Ashwani Rathee\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.problem_001-Tuple{Int64}","page":"Home","title":"TheAlgorithms.problem_001","text":"Multiples of 3 or 5\n\nIf we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nFind the sum of all the multiples of 3 or 5 below 1000.\n\nInput parameters:\n\nlimit : Upper limit for the numbers.\n\nExamples/Tests:\n\nproblem_001(10)     # returns 23\nproblem_001(1000)   # returns 233168\nproblem_001(-1)     # throws DomainError\n\nReference\n\nhttps://projecteuler.net/problem=1\n\nContributed by: Praneeth Jain\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.rabin_karp-Tuple{String, String}","page":"Home","title":"TheAlgorithms.rabin_karp","text":"rabin_karp(text, pattern)\n\nBrief:\n\nA function that finds all occurrences of a pattern in the given text.\nInstead of checking each character ot the pattern with each character block of the text,\nfor each character block calculate the hash value, and only if that value matches hash value of the pattern,\ncompare them character by character. These blocks are the same length as the pattern.\n\nReturns:\n\nA list with starting indices where the pattern was found\n\nReferences:\n\nhttps://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/\n\nContributed by: Nikola Mircic\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.riemann_integration","page":"Home","title":"TheAlgorithms.riemann_integration","text":"riemann_integration(f::Function, a::Real, b::Real, n::Int, approx::Symbol = :midpoint)\n\na Riemann sum is a certain kind of approximation of an integral by a finite sum. The sum is calculated by partitioning the region into shapes (rectangles, trapezoids, parabolas, or cubics) that together form a region that is similar to the region being measured, then calculating the area for each of these shapes, and finally adding all of these small areas together.\n\nBecause the region filled by the small shapes is usually not exactly the same shape as the region being measured, the Riemann sum will differ from the area being measured.  This error can be reduced by dividing up the region more finely, using smaller and smaller shapes.  As the shapes get smaller and smaller, the sum approaches the Riemann integral.\n\nArguments\n\nf: the function to integrate. (at the momment only single variable is suported)\na: Start of the integration limit.\nb: End of the integration limit.\nn: Number of points to sample. (as n increase, error decrease)\napprox: Indicate the method of approximation (midpoint, left or right)\n\nExamples\n\njulia> riemann_integration(x -> x, 1, 3, 1_000, :midpoint)  # 4.0\njulia> riemann_integration(x -> x, 1, 3, 1_000, :left)      # 3.997997997997998\njulia> riemann_integration(x -> x, 1, 3, 1_000, :right)     # 4.002002002002002\njulia> riemann_integration(x -> 3*x^2, 0, 1, 100000)        # integrate a polynomial\n0.9999999999750021\njulia> riemann_integration(x -> sin(x), 0, pi, 1000)          # integrate the sin function\n2.0000008241146774\n\nRefereces\n\nhttps://www.khanacademy.org/math/ap-calculus-ab/ab-integration-new/ab-6-2/a/riemann-sums-review\nhttps://math.libretexts.org/Courses/MountRoyalUniversity/MATH2200%3ACalculusforScientistsII/2%3ATechniquesofIntegration/2.5%3ANumericalIntegration-Midpoint%2CTrapezoid%2CSimpson's_rule\nhttps://abel.math.harvard.edu/~knill/teaching/math1a_2011/handouts/40-numerical.pdf\nhttps://en.wikipedia.org/wiki/Riemann_integral\n\nContributed By:- AugustoCL\n\n\n\n\n\n","category":"function"},{"location":"#TheAlgorithms.rotation_matrix-Tuple{Any}","page":"Home","title":"TheAlgorithms.rotation_matrix","text":"A 2D Rotation matrix is a mtrix that rotates a vector in a 2D real space by an angle theta. For more info: https://en.wikipedia.org/wiki/Rotation_matrix\n\nThis function takes the angle theta in radians as input and returns a 2D Matrix which will rotate the vector by angle theta.\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.simpsons_integration-Tuple{Function, Real, Real, Int64}","page":"Home","title":"TheAlgorithms.simpsons_integration","text":"simpsons_integration(f::Function, a::Real, b::Real, n::Int)\n\nSimpson's rule uses a quadratic polynomial on each subinterval of a partition to approximate the function f(x) and to compute the definite integral.  This is an improvement over the trapezoid rule which approximates f(x) by a straight line on each subinterval of a partition. For more details of the method, check the link in the reference.\n\nArguments\n\nf: The function to integrate. (ar the moment only single variable is suported)\na: Start of the integration limit.\nb: End of the integration limit.\nn: Number of points to sample. (as n increase, error decrease)\n\nExamples/Test\n\n# aproximate pi with f(x) = 4 / (1 + x^2)\njulia> simpsons_integration(x -> 4 / (1 + x^2), 0, 1, 100_000)\n3.1415926535897936\njulia> simpsons_integration(x -> 4 / (1 + x^2), 0, 1, 100_000) ≈ pi\ntrue\n\nReferences:\n\nhttps://personal.math.ubc.ca/~pwalls/math-python/integration/simpsons-rule/\n\nContributed By:- AugustoCL\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.sum_ap-Tuple{Any, Any, Any}","page":"Home","title":"TheAlgorithms.sum_ap","text":"sum_ap(first_term, diff, num_terms)\n\nFinds sum of a arithmetic progression series\n\nInput parameters\n\nfirst_term : first term of the series\ndiff       : common difference between consecutive terms\nnum_terms  : number of terms in the series till which we count sum\n\nExample\n\nsum_ap(1, 1, 10)    # returns 55.0 \nsum_ap(1, 10, 100)  # returns 49600.0\n\nContributed By:- Ashwani Rathee\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.sum_divisors-Tuple{Int64}","page":"Home","title":"TheAlgorithms.sum_divisors","text":"sum_divisors(n::Int)\n\nReturns the sum of the divisors of n.\n\nInput parameters:\n\nn : The number to find the sum of divisors of.\n\nExamples/Tests:\n\nsum_divisors(6)     # returns 12\nsum_divisors(10)    # returns 18\nsum_divisors(1345)  # returns 1620\nsum_divisors(-1)    # throws DomainError\n\nReference\n\nhttps://mathworld.wolfram.com/Divisor.html\n\nContributed by: Praneeth Jain\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.sum_gp-Tuple{Any, Any, Any}","page":"Home","title":"TheAlgorithms.sum_gp","text":"sum_gp(first_term, ratio, num_terms)\n\nFinds sum of n terms in a geometric progression\n\nInput parameters\n\nfirst_term : first term of the series\nraio      : common ratio between consecutive terms -> a2/a1 or a3/a2 or a4/a3\nnum_terms  : number of terms in the series till which we count sum\n\nExample\n\nsum_gp(1, 2, 10)    # 1023.0\nsum_gp(1, 10, 5)    # 11111.0\nsum_gp(0, 2, 10)    # 0.0\nsum_gp(1, 0, 10)    # 1.0\nsum_gp(1, 2, 0)     # -0.0\nsum_gp(-1, 2, 10)   # -1023.0\nsum_gp(1, -2, 10)   # -341.0\n\nContributed By:- Ashwani Rathee\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.surfarea_cube-Tuple{Any}","page":"Home","title":"TheAlgorithms.surfarea_cube","text":"surfarea_cube(side)\n\nFinds surface area of a cube\n\nExample\n\nsurfarea_cube(1)  # returns 6\nsurfarea_cube(3)  # returns 54\nsurfarea_cube(-1) # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.surfarea_cuboid-Tuple{Any, Any, Any}","page":"Home","title":"TheAlgorithms.surfarea_cuboid","text":"surfarea_cuboid(length, width, height)\n\nFinds surface area of a cuboid\n\nExample\n\nsurfarea_cuboid(5, 5, 5)  # returns 150\nsurfarea_cuboid(-5, -5, -5)  # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.surfarea_sphere-Tuple{Any}","page":"Home","title":"TheAlgorithms.surfarea_sphere","text":"surfarea_sphere(side)\n\nFinds surface area of a sphere\n\nExample\n\nsurfarea_sphere(5)  # returns 314.1592653589793\nsurfarea_sphere(1)  # returns 12.566370614359172\nsurfarea_sphere(-1) # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.totient-Tuple{Int64}","page":"Home","title":"TheAlgorithms.totient","text":"totient(n::Int)\n\nThe totient function phi(n) is defined as the number of positive integers <=n that are relatively prime to n. Since a number less than or equal to and relatively prime to a given number is called a totative, the totient function phi(n) can be simply defined as the number of totatives of n.\n\nInput parameters:\n\nn : The number to find the totient of.\n\nExamples/Tests:\n\ntotient(1) # returns 1\ntotient(2) # returns 1\ntotient(3) # returns 2\ntotient(10) # returns 4\ntotient(24) # returns 8\ntotient(50) # returns 20\ntotient(-1) # throws DomainError\n\nReference\n\nhttps://mathworld.wolfram.com/TotientFunction.html\n\nContributed by Praneeth Jain\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.trapazoidal_area-NTuple{4, Any}","page":"Home","title":"TheAlgorithms.trapazoidal_area","text":"trapazoidal_area(f, x_start, x_end, steps)\n\nApproximates the area under the curve using the trapezoidal rule Arguments:\n\nf: function for the\nx_start: starting value for x\nx_end: ending value for x\nsteps: steps taken while integrating.\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.trapezoid_integration-Tuple{Function, Real, Real, Int64}","page":"Home","title":"TheAlgorithms.trapezoid_integration","text":"trapezoid_integration(f::Function, a::Real, b::Real, n::Int)\n\nThe trapezoidal rule works by approximating the region under the graph of the function f(x) as a trapezoid and calculating its area.\n\nArguments\n\nf: the function to integrate. (at the momment only single variable is suported)\na: Start of the integration limit.\nb: End of the integration limit.\nn: Number of points to sample. (as n increase, error decrease)\n\nExamples/Test\n\njulia> trapezoid_integration(x -> 4 / (1 + x^2), 0, 1, 100_000)\n3.1415926535731526\njulia> trapezoid_integration(x -> 4 / (1 + x^2), 0, 1, 100_000) ≈ pi\ntrue\n\nReferences:\n\n-https://personal.math.ubc.ca/~pwalls/math-python/integration/trapezoid-rule/ -https://en.wikipedia.org/wiki/Trapezoidal_rule\n\nContributed By:- AugustoCL\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.variance-Tuple{Any}","page":"Home","title":"TheAlgorithms.variance","text":"variance(a)\n\nFind the variance from a set of data.\n\nArguments:\n\na: holds the set of data\n\nReference\n\n- According to Ronald E. Walpole, `variance` is used to measure the variability of a set of data. -- Introduction to Statistics by Ronald E. Walpole\n\nContributors:\n\nAru Bhardwaj\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.verlet_integration","page":"Home","title":"TheAlgorithms.verlet_integration","text":"Verlet integration is an integration method used to integrate newtons - law of motion. It is frequently used to find trajectories in molecular dynamics simulation. The function takes four inputs viz,\n\nf : the differential equation\nx0 : the initial condition. This is a Vector with the first element as initial value for position (x0) and the second initial condition for velocity (v0) \ntspan: is the time span for integration. It is a tuple (initial time, final time)\n\nThis functionr returns a tuple (x,t):\n\nx is the solution\nt is the array containing the time points\n\nReference:\n\nhttps://www.algorithm-archive.org/contents/verletintegration/verletintegration.html\n\nContributed by: Ved Mahajan\n\n\n\n\n\n","category":"function"},{"location":"#TheAlgorithms.vol_circular_cylinder-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.vol_circular_cylinder","text":"vol_circular_cylinder(area_of_, height)\n\nCompute the Volume of a Circular Cylinder.\n\nExamples\n\n```julia-repl julia> volcircularcylinder(1, 1) 3.141592653589793 julia> volcircularcylinder(4, 3) 150.79644737231007\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.vol_cone-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.vol_cone","text":"vol_cone(area_of_base, height)\n\nCompute the Volume of a Cone\n\nExamples\n\njulia> vol_cone(10, 3)\n10.0\njulia> vol_cone(1, 1)\n0.3333333333333333\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.vol_cube-Tuple{Any}","page":"Home","title":"TheAlgorithms.vol_cube","text":"vol_cube()\n\nCompute the volume of a cube.\n\nExamples\n\njulia> vol_cube(1)\n1\njulia> vol_cube(3)\n27\njulia> vol_cube(-1)\nDomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.vol_cuboid-Tuple{Any, Any, Any}","page":"Home","title":"TheAlgorithms.vol_cuboid","text":"vol_cuboid(width, height, length)\n\nCompute the volume of a vol_cuboid\n\nExamples\n\njulia> vol_cuboid(1, 1, 1)\n1\njulia> vol_cuboid(1, 2, 3)\n6\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.vol_prism-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.vol_prism","text":"vol_prism(area_of_base, height)\n\nCompute the Volume of a Prism.\n\nExamples\n\njulia> vol_prism(10, 2)\n20.0\njulia> vol_prism(11, 1)\n11.0\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.vol_pyramid-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.vol_pyramid","text":"vol_pyramid(area_of_base, height)\n\nCompute the volume of a Pyramid.\n\nExamples\n\njulia> vol_pyramid(10, 3)\n10.0\njulia> vol_pyramid(1.5, 3)\n1.5\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.vol_right_circ_cone-Tuple{Any, Any}","page":"Home","title":"TheAlgorithms.vol_right_circ_cone","text":"vol_right_circ_cone(radius, height)\n\nCompute the Volume of a Right Circular Cone.\n\nExamples\n\njulia> vol_right_circ_cone(2, 3)\n12.566370614359172\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.vol_sphere-Tuple{Any}","page":"Home","title":"TheAlgorithms.vol_sphere","text":"vol_sphere(radius)\n\nCompute the volume of a sphere.\n\nExamples\n\nvol_sphere(5)  # returns 523.5987755982989\nvol_sphere(1)  # returns 4.1887902047863905\nvol_sphere(-1) # returns DomainError\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.word_count-Tuple{Any}","page":"Home","title":"TheAlgorithms.word_count","text":"wordcount(sentence)\n\nProgram to find word count in the given sentence. The program will return count with the word. A full description of the algorithm can be found on exercism\n\nArguments:\n\nsentence: The sentence to find the word count.\n\nExamples/Tests\n\njulia> wordcount(The quick brown fox jumps over the lazy dog)\nDict{Any, Any}(\"jumps\" => 1, \"the\" => 2, \"brown\" => 1, \"over\" => 1, \"quick\" => 1, \"lazy\" => 1, \"dog\" => 1, \"fox\" => 1)\n\njulia> wordcount(the sky is blue and beautiful)\nDict{Any, Any}(\"and\" => 1, \"the\" => 1, \"sky\" => 1, \"blue\" => 1, \"is\" => 1, \"beautiful\" => 1)\n\n\nAlgorithm:\n\n\nfor word in eachmatch(reg_expression, sentence)\n    if !haskey(counts, word.match)\n        counts[word.match] = 1\n    else\n        counts[word.match] += 1\n    end\nend\n\n\nReferences:\n\n(https://exercism.org/tracks/julia/exercises/word-count)\n\n```\n\nContributed by:- Ihjass Thasbekha\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N<:Number, V<:(AbstractVector)}","page":"Home","title":"TheAlgorithms.zero_one_pack!","text":"zero_one_pack!(capacity::N, weights::V, values::V, dp::V) where {N <: Number,V <: AbstractVector}\n\nThis does 0-1 (each item can be chosen only once) knapsack : pack capacity = capacity weight of each item = weights value of each item = values dp array is what the function works on It returns the ans (dp[capacity])\n\njulia> dp=zeros(Int,30)\njulia> zero_one_pack!(20,[1,3,11],[2,5,30],dp)\n37\n\n\n\n\n\n","category":"method"},{"location":"#TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N<:Number, V<:(AbstractVector)}","page":"Home","title":"TheAlgorithms.zero_one_pack!","text":"For greedy algorithm, it will take the element based on the optimal value in the array at each loop in the function\n\nThis does 0-1 (each item can be chosen only once) knapsack : pack capacity = capacity weight of each item = weights value of each item = values\n\nEach loop the function will find the highest value in the array and check if the capacity is enough to store it, if enough then  the value will be added into the totalmaxvalue.  After that the highest current value will be deleted.\n\njulia> zero_one_pack!(20,[1,3,11],[2,5,30])\n37\n\n\n\n\n\n","category":"method"}]
}
