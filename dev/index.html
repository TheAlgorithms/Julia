<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TheAlgorithms.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://TheAlgorithms.github.io/Julia/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TheAlgorithms.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/TheAlgorithms/Julia/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TheAlgorithms"><a class="docs-heading-anchor" href="#TheAlgorithms">TheAlgorithms</a><a id="TheAlgorithms-1"></a><a class="docs-heading-anchor-permalink" href="#TheAlgorithms" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/TheAlgorithms/Julia">TheAlgorithms</a>.</p><ul><li><a href="#TheAlgorithms.AbstractBinarySearchTree_arr"><code>TheAlgorithms.AbstractBinarySearchTree_arr</code></a></li><li><a href="#TheAlgorithms.AbstractBinaryTree_arr"><code>TheAlgorithms.AbstractBinaryTree_arr</code></a></li><li><a href="#TheAlgorithms.DisjointSet"><code>TheAlgorithms.DisjointSet</code></a></li><li><a href="#TheAlgorithms.abs_max-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real"><code>TheAlgorithms.abs_max</code></a></li><li><a href="#TheAlgorithms.abs_min-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real"><code>TheAlgorithms.abs_min</code></a></li><li><a href="#TheAlgorithms.abs_val-Tuple{N} where N&lt;:Real"><code>TheAlgorithms.abs_val</code></a></li><li><a href="#TheAlgorithms.area_circle-Tuple{Any}"><code>TheAlgorithms.area_circle</code></a></li><li><a href="#TheAlgorithms.area_ellipse-Tuple{Any, Any}"><code>TheAlgorithms.area_ellipse</code></a></li><li><a href="#TheAlgorithms.area_heron_triangle-Tuple{Any, Any, Any}"><code>TheAlgorithms.area_heron_triangle</code></a></li><li><a href="#TheAlgorithms.area_parallelogram-Tuple{Any, Any}"><code>TheAlgorithms.area_parallelogram</code></a></li><li><a href="#TheAlgorithms.area_rectangle-Tuple{Any, Any}"><code>TheAlgorithms.area_rectangle</code></a></li><li><a href="#TheAlgorithms.area_rhombus-Tuple{Any, Any}"><code>TheAlgorithms.area_rhombus</code></a></li><li><a href="#TheAlgorithms.area_square-Tuple{Any}"><code>TheAlgorithms.area_square</code></a></li><li><a href="#TheAlgorithms.area_trapezium-Tuple{Any, Any, Any}"><code>TheAlgorithms.area_trapezium</code></a></li><li><a href="#TheAlgorithms.area_triangle-Tuple{Any, Any}"><code>TheAlgorithms.area_triangle</code></a></li><li><a href="#TheAlgorithms.bab_sqrt-Tuple{Real}"><code>TheAlgorithms.bab_sqrt</code></a></li><li><a href="#TheAlgorithms.binary_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real"><code>TheAlgorithms.binary_search</code></a></li><li><a href="#TheAlgorithms.binary_search-Tuple{Any, Any}"><code>TheAlgorithms.binary_search</code></a></li><li><a href="#TheAlgorithms.caesar-Tuple{Any, Any}"><code>TheAlgorithms.caesar</code></a></li><li><a href="#TheAlgorithms.ceil_val-Tuple{Any}"><code>TheAlgorithms.ceil_val</code></a></li><li><a href="#TheAlgorithms.celsius_to_fahrenheit"><code>TheAlgorithms.celsius_to_fahrenheit</code></a></li><li><a href="#TheAlgorithms.celsius_to_kelvin"><code>TheAlgorithms.celsius_to_kelvin</code></a></li><li><a href="#TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.complete_pack!</code></a></li><li><a href="#TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.complete_pack!</code></a></li><li><a href="#TheAlgorithms.count_nucleotides-Tuple{AbstractString}"><code>TheAlgorithms.count_nucleotides</code></a></li><li><a href="#TheAlgorithms.counting_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Int64}, Tuple{Vector{T}, Int64, Int64}} where T"><code>TheAlgorithms.counting_sort!</code></a></li><li><a href="#TheAlgorithms.detect_anagrams-Tuple{Any, Any}"><code>TheAlgorithms.detect_anagrams</code></a></li><li><a href="#TheAlgorithms.determinant-Tuple{Any}"><code>TheAlgorithms.determinant</code></a></li><li><a href="#TheAlgorithms.dna2rna-Tuple{AbstractString}"><code>TheAlgorithms.dna2rna</code></a></li><li><a href="#TheAlgorithms.encode-Tuple{Any}"><code>TheAlgorithms.encode</code></a></li><li><a href="#TheAlgorithms.eratosthenes-Tuple{Any}"><code>TheAlgorithms.eratosthenes</code></a></li><li><a href="#TheAlgorithms.euler_method"><code>TheAlgorithms.euler_method</code></a></li><li><a href="#TheAlgorithms.exponential_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:Real"><code>TheAlgorithms.exponential_search</code></a></li><li><a href="#TheAlgorithms.factorial_iterative-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.factorial_iterative</code></a></li><li><a href="#TheAlgorithms.factorial_recursive-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.factorial_recursive</code></a></li><li><a href="#TheAlgorithms.fahrenheit_to_celsius"><code>TheAlgorithms.fahrenheit_to_celsius</code></a></li><li><a href="#TheAlgorithms.fahrenheit_to_kelvin"><code>TheAlgorithms.fahrenheit_to_kelvin</code></a></li><li><a href="#TheAlgorithms.fcfs-Tuple{Any, Any, Any}"><code>TheAlgorithms.fcfs</code></a></li><li><a href="#TheAlgorithms.find-Tuple{DisjointSet, Int64}"><code>TheAlgorithms.find</code></a></li><li><a href="#TheAlgorithms.floor_val-Tuple{Any}"><code>TheAlgorithms.floor_val</code></a></li><li><a href="#TheAlgorithms.gauss_jordan-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.gauss_jordan</code></a></li><li><a href="#TheAlgorithms.heap_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Any}, Tuple{Vector{T}, Any, Int64}} where T"><code>TheAlgorithms.heap_sort!</code></a></li><li><a href="#TheAlgorithms.idx_for-Tuple{Int64}"><code>TheAlgorithms.idx_for</code></a></li><li><a href="#TheAlgorithms.interpolation_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real"><code>TheAlgorithms.interpolation_search</code></a></li><li><a href="#TheAlgorithms.is_armstrong-Tuple{Any}"><code>TheAlgorithms.is_armstrong</code></a></li><li><a href="#TheAlgorithms.ispangram-Tuple{Any}"><code>TheAlgorithms.ispangram</code></a></li><li><a href="#TheAlgorithms.jump_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:Real"><code>TheAlgorithms.jump_search</code></a></li><li><a href="#TheAlgorithms.kelvin_to_celsius"><code>TheAlgorithms.kelvin_to_celsius</code></a></li><li><a href="#TheAlgorithms.kelvin_to_fahrenheit"><code>TheAlgorithms.kelvin_to_fahrenheit</code></a></li><li><a href="#TheAlgorithms.krishnamurthy-Tuple{Any}"><code>TheAlgorithms.krishnamurthy</code></a></li><li><a href="#TheAlgorithms.line_length"><code>TheAlgorithms.line_length</code></a></li><li><a href="#TheAlgorithms.linear_search-Tuple{Any, Any}"><code>TheAlgorithms.linear_search</code></a></li><li><a href="#TheAlgorithms.lu_decompose-Tuple{Any}"><code>TheAlgorithms.lu_decompose</code></a></li><li><a href="#TheAlgorithms.mean-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.mean</code></a></li><li><a href="#TheAlgorithms.median-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.median</code></a></li><li><a href="#TheAlgorithms.mode-Tuple{Any}"><code>TheAlgorithms.mode</code></a></li><li><a href="#TheAlgorithms.monte_carlo_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.monte_carlo_integration</code></a></li><li><a href="#TheAlgorithms.perfect_cube-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.perfect_cube</code></a></li><li><a href="#TheAlgorithms.perfect_number-Tuple{N} where N&lt;:Number"><code>TheAlgorithms.perfect_number</code></a></li><li><a href="#TheAlgorithms.perfect_square-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.perfect_square</code></a></li><li><a href="#TheAlgorithms.prime_check-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.prime_check</code></a></li><li><a href="#TheAlgorithms.prime_factors-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.prime_factors</code></a></li><li><a href="#TheAlgorithms.rabin_karp-Tuple{String, String}"><code>TheAlgorithms.rabin_karp</code></a></li><li><a href="#TheAlgorithms.riemann_integration"><code>TheAlgorithms.riemann_integration</code></a></li><li><a href="#TheAlgorithms.rotation_matrix-Tuple{Any}"><code>TheAlgorithms.rotation_matrix</code></a></li><li><a href="#TheAlgorithms.simpsons_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.simpsons_integration</code></a></li><li><a href="#TheAlgorithms.sum_ap-Tuple{Any, Any, Any}"><code>TheAlgorithms.sum_ap</code></a></li><li><a href="#TheAlgorithms.sum_gp-Tuple{Any, Any, Any}"><code>TheAlgorithms.sum_gp</code></a></li><li><a href="#TheAlgorithms.surfarea_cube-Tuple{Any}"><code>TheAlgorithms.surfarea_cube</code></a></li><li><a href="#TheAlgorithms.surfarea_sphere-Tuple{Any}"><code>TheAlgorithms.surfarea_sphere</code></a></li><li><a href="#TheAlgorithms.trapazoidal_area-NTuple{4, Any}"><code>TheAlgorithms.trapazoidal_area</code></a></li><li><a href="#TheAlgorithms.trapezoid_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.trapezoid_integration</code></a></li><li><a href="#TheAlgorithms.variance-Tuple{Any}"><code>TheAlgorithms.variance</code></a></li><li><a href="#TheAlgorithms.verlet_integration"><code>TheAlgorithms.verlet_integration</code></a></li><li><a href="#TheAlgorithms.vol_circular_cylinder-Tuple{Any, Any}"><code>TheAlgorithms.vol_circular_cylinder</code></a></li><li><a href="#TheAlgorithms.vol_cone-Tuple{Any, Any}"><code>TheAlgorithms.vol_cone</code></a></li><li><a href="#TheAlgorithms.vol_cube-Tuple{Any}"><code>TheAlgorithms.vol_cube</code></a></li><li><a href="#TheAlgorithms.vol_cuboid-Tuple{Any, Any, Any}"><code>TheAlgorithms.vol_cuboid</code></a></li><li><a href="#TheAlgorithms.vol_prism-Tuple{Any, Any}"><code>TheAlgorithms.vol_prism</code></a></li><li><a href="#TheAlgorithms.vol_pyramid-Tuple{Any, Any}"><code>TheAlgorithms.vol_pyramid</code></a></li><li><a href="#TheAlgorithms.vol_right_circ_cone-Tuple{Any, Any}"><code>TheAlgorithms.vol_right_circ_cone</code></a></li><li><a href="#TheAlgorithms.vol_sphere-Tuple{Any}"><code>TheAlgorithms.vol_sphere</code></a></li><li><a href="#TheAlgorithms.word_count-Tuple{Any}"><code>TheAlgorithms.word_count</code></a></li><li><a href="#TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.zero_one_pack!</code></a></li><li><a href="#TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.zero_one_pack!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.AbstractBinarySearchTree_arr" href="#TheAlgorithms.AbstractBinarySearchTree_arr"><code>TheAlgorithms.AbstractBinarySearchTree_arr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>array-based binary search tree left tree values &lt; root value &lt; right tree values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/data_structures/binary_tree/basic_binary_search_tree.jl#L2-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.AbstractBinaryTree_arr" href="#TheAlgorithms.AbstractBinaryTree_arr"><code>TheAlgorithms.AbstractBinaryTree_arr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>array-based binary tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/data_structures/binary_tree/basic_binary_tree.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.DisjointSet" href="#TheAlgorithms.DisjointSet"><code>TheAlgorithms.DisjointSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This can contain a maximum of <code>length(par)</code> parenting-relations par is an array of <code>Int</code>, which is the index of the parent node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/data_structures/disjoint_set/disjoint_set.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.abs_max-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real" href="#TheAlgorithms.abs_max-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real"><code>TheAlgorithms.abs_max</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs_max(x)</code></pre><p>Program to find the max absolute value in a vector</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">abs_max([1,3,4]) # returns 4
abs_max([-3,1,2]) # returns -3
abs_max([-7,-3,6]) #returns -7</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/abs.jl#L22-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.abs_min-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real" href="#TheAlgorithms.abs_min-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real"><code>TheAlgorithms.abs_min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs_min(num)</code></pre><p>Program to find the min absolute value in a vector</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">abs_min([1,3,4]) # returns 1
abs_min([-3,1,2]) # returns 1
abs_min([-7,-3,6]) #returns -3</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/abs.jl#L46-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.abs_val-Tuple{N} where N&lt;:Real" href="#TheAlgorithms.abs_val-Tuple{N} where N&lt;:Real"><code>TheAlgorithms.abs_val</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs_val(num)</code></pre><p>Program to find the absolute value of a number</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">abs_val(-100) # returns 100
abs_val(0) # returns 0
abs(123.1) # returns 123.1
-1000 == abs_val(-1000) #returns false
1000 == abs_val(1000) #returns true</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/abs.jl#L2-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_circle-Tuple{Any}" href="#TheAlgorithms.area_circle-Tuple{Any}"><code>TheAlgorithms.area_circle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_circle(radius)</code></pre><p>Finds area of the circle</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_circle(20) # returns 1256.6370614359173
area_circle(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/area.jl#L203-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_ellipse-Tuple{Any, Any}" href="#TheAlgorithms.area_ellipse-Tuple{Any, Any}"><code>TheAlgorithms.area_ellipse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_ellipse(radius_x, radius_y)</code></pre><p>Finds area of the ellipse</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_ellipse(10, 10) # returns 314.1592653589793
area_ellipse(10, 20) # returns 628.3185307179587
area_ellipse(1, -2) # returns DomainError
area_ellipse(-1, 2) # returns DomainError
area_ellipse(-1, -2) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/area.jl#L222-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_heron_triangle-Tuple{Any, Any, Any}" href="#TheAlgorithms.area_heron_triangle-Tuple{Any, Any, Any}"><code>TheAlgorithms.area_heron_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_heron_triangle(side1, side2, side3)</code></pre><p>Finds area of a triangle using heron&#39;s formula</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_heron_triangle(5,12,13) # returns 30.0
area_heron_triangle(-1,-2,1) # returns DomainError
area_heron_triangle(1,-2,1)  # returns DomainError
area_heron_triangle(-1,2,1)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/area.jl#L117-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_parallelogram-Tuple{Any, Any}" href="#TheAlgorithms.area_parallelogram-Tuple{Any, Any}"><code>TheAlgorithms.area_parallelogram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_parallelogram(base, height)</code></pre><p>Finds area of the parallelogram</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_parallelogram(10,20) # returns 200
area_parallelogram(-1,-2) # returns DomainError
area_parallelogram(1,-2)  # returns DomainError
area_parallelogram(-1,2)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/area.jl#L153-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_rectangle-Tuple{Any, Any}" href="#TheAlgorithms.area_rectangle-Tuple{Any, Any}"><code>TheAlgorithms.area_rectangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_rectangle(length, width)</code></pre><p>Finds area of the rectangle</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_rectangle(10,20) # returns 200
area_rectangle(-1,-2) # returns DomainError
area_rectangle(1,-2)  # returns DomainError
area_rectangle(-1,2)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/area.jl#L54-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_rhombus-Tuple{Any, Any}" href="#TheAlgorithms.area_rhombus-Tuple{Any, Any}"><code>TheAlgorithms.area_rhombus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_rhombus(diagonal_1, diagonal_2)</code></pre><p>Finds area of the rhombus</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_rhombus(10, 20) # returns 100.0
area_rhombus(-1,-2) # returns DomainError
area_rhombus(1,-2)  # returns DomainError
area_rhombus(-1,2)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/area.jl#L244-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_square-Tuple{Any}" href="#TheAlgorithms.area_square-Tuple{Any}"><code>TheAlgorithms.area_square</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_square(side)</code></pre><p>Finds area of the area_square</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_square(10) # returns 100
area_square(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/area.jl#L77-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_trapezium-Tuple{Any, Any, Any}" href="#TheAlgorithms.area_trapezium-Tuple{Any, Any, Any}"><code>TheAlgorithms.area_trapezium</code></a> — <span class="docstring-category">Method</span></header><section><div><p>area_trapezium(base1,base2,height)</p><p>Finds area of the traπzium</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_trapezium(10, 20, 30)  # returns 450.0
area_trapezium(-1, -2, -3)  # returns DomainError
area_trapezium(-1, 2, 3)    # returns DomainError
area_trapezium(1, -2, 3)    # returns DomainError
area_trapezium(1, 2, -3)    # returns DomainError
area_trapezium(-1, -2, 3)   # returns DomainError
area_trapezium(1, -2, -3)   # returns DomainError
area_trapezium(-1, 2, -3)   # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/area.jl#L178-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_triangle-Tuple{Any, Any}" href="#TheAlgorithms.area_triangle-Tuple{Any, Any}"><code>TheAlgorithms.area_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_triangle(base, height)</code></pre><p>Finds area of the right angled triangle with base height</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_triangle(10,10) # returns 50.0
area_triangle(-1,-2) # returns DomainError
area_triangle(1,-2)  # returns DomainError
area_triangle(-1,2)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/area.jl#L96-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.bab_sqrt-Tuple{Real}" href="#TheAlgorithms.bab_sqrt-Tuple{Real}"><code>TheAlgorithms.bab_sqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bab_sqrt(S::Real; tolerance = 1e-6, guess = nothing)</code></pre><p>The Babylonian Method of calculating a square root is a simple iterative method to determine square roots. A full description of the algorithm can be found on <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method">Wikipedia</a></p><p><strong>Arguments:</strong></p><ul><li><code>S</code>: The number to calculate the square root for.</li></ul><p><strong>Positional Arguments</strong></p><ul><li><code>tolerance</code>: How close the square of the square root needs to be from the input value. <code>abs(S - xn^2) &lt; tolerance</code></li><li><code>guess</code>: The initial value to use for <code>xn</code></li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; bab_sqrt(100)
10.000000000107445

julia&gt; bab_sqrt(100, guess = 15)
10.000000000131072

julia&gt; bab_sqrt(π, guess = 1)
1.7724538555800293

julia&gt; bab_sqrt(π, guess = 1, tolerance = 2)
2.0707963267948966</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">while tolerance &lt;= abs(xn^2 - S)
    xn = (1 / 2) * (xn + S / xn)
end</code></pre><p><strong>References:</strong></p><p><a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method">Methods of computing square roots</a></p><p>```</p><p><strong>Contributed by:- <a href="https://ansonbiggs.com">Anson Biggs</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/babylonian_sqrt.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.binary_search-Tuple{Any, Any}" href="#TheAlgorithms.binary_search-Tuple{Any, Any}"><code>TheAlgorithms.binary_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">binary_search(list, query; rev=false, lt=&lt;, by=identity)</code></pre><p>Implement a binary search algorithm. Searching a sorted collection is a common task. A dictionary is a sorted list of word definitions. Given a word, one can find its definition. A telephone book is a sorted list of people&#39;s names, addresses, and telephone numbers. Knowing someone&#39;s name allows one to quickly find their telephone number and address.</p><p>If the list to be searched contains more than a few items (a dozen, say) a binary search will require far fewer comparisons than a linear search, but it imposes the requirement that the list be sorted.</p><p>In computer science, a binary search or half-interval search algorithm finds the position of a specified input value (the search &quot;key&quot;) within an array sorted by key value.</p><p>In each step, the algorithm compares the search key value with the key value of the middle element of the array.</p><p>If the keys match, then a matching element has been found and the range of indices that equal the search key value are returned.</p><p>Otherwise, if the search key is less than the middle element&#39;s key, then the algorithm repeats its action on the sub-array to the left of the middle element or, if the search key is greater, on the sub-array to the right.</p><p>If the remaining array to be searched is empty, then the key cannot be found in the array and a special &quot;not found&quot; indication is returned. Search methods in Julia typically return an empty range located at the insertion point in this case.</p><p>A binary search halves the number of items to check with each iteration, so locating an item (or determining its absence) takes logarithmic time. A binary search is a dichotomic divide and conquer search algorithm.</p><p>Bonus task: Implement keyword arguments by, lt and rev so that by specifies a transformation applied to all elements of the list, lt specifies a comparison and rev specifies if the list is ordered in reverse.</p><p>Contributed By:- <a href="https://github.com/uncomfyhalomacro">Soc Virnyl Estela</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/searches/binary_search.jl#L6-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.binary_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real" href="#TheAlgorithms.binary_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real"><code>TheAlgorithms.binary_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">binary_search(arr::AbstractArray{T,1}, l::T, r::T, x::T) where {T&lt;:Real}</code></pre><p>The implementation of this binary Search is recursive and requires O(Log n) space. With iterative Binary Search, we need only O(1) space. Useful for the implementation of <code>exponential_search</code>.</p><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ash</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/searches/binary_search.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.caesar-Tuple{Any, Any}" href="#TheAlgorithms.caesar-Tuple{Any, Any}"><code>TheAlgorithms.caesar</code></a> — <span class="docstring-category">Method</span></header><section><div><p>rotate(rot, s)</p><p>Program to implement rotational cipher for the given sentence. A full description of the algorithm can be found on <a href="https://en.wikipedia.org/wiki/Caesar_cipher">wikipedia</a></p><p><strong>Arguments:</strong></p><ul><li><code>rot</code>: The number of rotations needed.</li><li><code>s</code> : The sentence needed to rotate</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; rotate(13,&quot;abcdefghijklmnopqrstuvwxyz&quot;)
nopqrstuvwxyzabcdefghijklm

julia&gt; rotate(5,&quot;omg&quot;)
trl

julia&gt; rotate(0,&quot;hello&quot;)
hello
</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">
if r &gt;= &#39;a&#39; &amp;&amp; r &lt;= &#39;z&#39;
    v = ((r - &#39;a&#39;) + rot) % 26
    return v + &#39;a&#39;
end
if r &gt;= &#39;A&#39; &amp;&amp; r &lt;= &#39;Z&#39;
    v = ((r - &#39;A&#39;) + rot) % 26
    return v + &#39;A&#39;
end
return r
</code></pre><p><strong>References:</strong></p><p>https://en.wikipedia.org/wiki/Caesar_cipher</p><p>```</p><p><strong>Contributed by:- <a href="https://github.com/Ihjass">Ihjass Thasbekha</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/cipher/caesar.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.ceil_val-Tuple{Any}" href="#TheAlgorithms.ceil_val-Tuple{Any}"><code>TheAlgorithms.ceil_val</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ceil_val(x)</code></pre><p>Finds the ceiling of x as an functionInteger</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ceil_val(1.3)   # 2.0
ceil_val(2.0)   # returns 2.0
ceil_val(-1.5)  #returns -1.0</code></pre><p><strong>Reference</strong></p><ul><li>https://en.wikipedia.org/wiki/Floor<em>and</em>ceiling_functions</li></ul><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/ceil_floor.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.celsius_to_fahrenheit" href="#TheAlgorithms.celsius_to_fahrenheit"><code>TheAlgorithms.celsius_to_fahrenheit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>celsius<em>to</em>fahrenheit(celsius, ndigits::Int = 2)</p><p>Converts celsius to fahrenheit and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">celsius_to_fahrenheit(273.354, 3) == 524.037  # returns true
celsius_to_fahrenheit(273.354, 0) == 524.0    # returns true
celsius_to_fahrenheit(-40.0) == -40.0         # returns true
celsius_to_fahrenheit(-20.0) == -4.0          # returns true
celsius_to_fahrenheit(0) == 32.0              # returns true
celsius_to_fahrenheit(20) == 68.0             # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/conversions/temparature_conversion.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.celsius_to_kelvin" href="#TheAlgorithms.celsius_to_kelvin"><code>TheAlgorithms.celsius_to_kelvin</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function celsius<em>to</em>kelvin(celsius, ndigits::Int = 2)</p><p>Converts celsius to kelvin and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">celsius_to_kelvin(273.354, 3) == 546.504    # returns true
celsius_to_kelvin(273.354, 0) == 547.0      # returns true
celsius_to_kelvin(0.0) == 273.15            # returns true
celsius_to_kelvin(20.0) == 293.15           # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/conversions/temparature_conversion.jl#L21-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}" href="#TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.complete_pack!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This does complete/infinite (each item can be chosen infinite times) knapsack : pack capacity = capacity weight of each item = weights value of each item = values dp array is what the function works on It returns the ans (dp[capacity])</p><pre><code class="nohighlight hljs">julia&gt; dp=zeros(Int,30)
julia&gt; complete_pack!(20,[1,2,9],[1,3,20],dp)
43</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/knapsack/dynamic_programming.jl#L32-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}" href="#TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.complete_pack!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This does complete/infinite (each item can be chosen infinite times) knapsack : pack capacity = capacity weight of each item = weights value of each item = values</p><p>Each loop the function will find the highest value in the array and check if the capacity is enough to store it, if enough then  the value will be added into the total<em>max</em>value until the capacity cannot hold the weight of the highest current value.  After that the highest current value will be deleted.</p><pre><code class="nohighlight hljs">julia&gt; complete_pack!(20,[1,2,9],[1,3,20])
43</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/knapsack/greedy_algorithm.jl#L36-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.count_nucleotides-Tuple{AbstractString}" href="#TheAlgorithms.count_nucleotides-Tuple{AbstractString}"><code>TheAlgorithms.count_nucleotides</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_nucleotides(s::AbstractString)</code></pre><p>Given: A DNA string s</p><p>of length at most 1000 nt.</p><p>Return: Four integers (separated by spaces) counting the respective number of times that the symbols &#39;A&#39;, &#39;C&#39;, &#39;G&#39;, and &#39;T&#39; occur in s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/project-rosalind/count_nucleotide.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.counting_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Int64}, Tuple{Vector{T}, Int64, Int64}} where T" href="#TheAlgorithms.counting_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Int64}, Tuple{Vector{T}, Int64, Int64}} where T"><code>TheAlgorithms.counting_sort!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Counting Sort</strong></p><p>OVERVIEW: Counting Sort is a sorting algorithm that sort elements within a specific range. The sorting technique is to count the existing element and stored its occurrence time in a new list, then only print it out.</p><p>STEPS:  Assume the input as –&gt; x=[-3, 1, -5, 0, -3]   minimum = -5</p><ul><li><p>STEP 1: Create a list size within the range, in this case is -5 –&gt; 1 which have range of 7 (-5, -4, -3, -2, -1, 0, 1), so list with size 7 and assign all to 0 is created</p></li><li><p>STEP 2: Count the occurances of element in the list          First number = -3 it is the third number in the range, so count[3]+=1         Final view:         index : ( 1,  2,  3,  4,  5, 6, 7)         range : (-5, -4, -3, -2, -1, 0, 1)         count : [ 1,  0,  2,  0,  0, 1, 1] &lt;– the list will store this occurences</p></li><li><p>STEP 3: Make the count list accumulate the occurances          The final count is (1, 1, 3, 3, 3, 4, 5)</p></li><li><p>STEP 4: Assign the elements in x into correct possition by creating a new list (will call &#39;output&#39; in this sample)         the 1st element in &#39;x&#39; is -3, it is third in range, so it will call the index of 3 in &#39;count&#39;, which is 3 and assign the -3 in to 3rd position in &#39;output&#39;,          then the third element in range will deduct by 1, so the next repeated element will get the correct position, new &#39;count&#39; –&gt; [1, 1, 2, 3, 3, 4, 5]</p><pre><code class="nohighlight hljs">    the 2nd element in &#39;x&#39; is  1, it is last  in range, so it will call the index of 7 in &#39;count&#39;, which is 5 and assign the  1 in to 5th position in &#39;output&#39;, 
    new &#39;count&#39; --&gt; [1, 1, 2, 3, 3, 4, 4]
    ......
    ......
    *If you want the order of original array to have the same order as the output array use can change this to decremental for loop</code></pre></li><li><p>STEP 5: Assign the &#39;ouput&#39; list back to &#39;x&#39;</p></li></ul><p>FINAL RESULT –&gt;  [-5, -3, -3, 0, 1]                                                                                    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/sorts/counting_sort.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.detect_anagrams-Tuple{Any, Any}" href="#TheAlgorithms.detect_anagrams-Tuple{Any, Any}"><code>TheAlgorithms.detect_anagrams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">detect_anagrams(subject, candidates)</code></pre><p>A function that checks if a list of words is an <a href="https://en.wikipedia.org/wiki/Anagram">Anagram</a> or not of a subject word.</p><p>is the original word = subject is list of words to be compared if they are an anagram of <code>subject</code> = candidates</p><pre><code class="nohighlight hljs">julia&gt; subject = &quot;listen&quot;
julia&gt; candidates = [&quot;inlets&quot;, &quot;enlists&quot;, &quot;google&quot;, &quot;banana&quot;]
julia&gt; detect_anagrams(subject, candidates)
1-element Vector{String}:
 &quot;inlets&quot;</code></pre><p>Contributed By:- <a href="https://github.com/ReneganRonin">Soc V. E.</a> Based on my exercism&#39;s Julia track problem solution on <a href="https://exercism.io/my/solutions/0a1d39faa5694624b7750be3ebf6c974">Anagrams</a>.</p><p>Instructions:</p><p>An anagram is a rearrangement of letters to form a new word. Given a word and a list of candidates, select the sublist of anagrams of the given word. Given &quot;listen&quot; and a list of candidates like &quot;enlists&quot; &quot;google&quot; &quot;inlets&quot; &quot;banana&quot; the program should return a list containing &quot;inlets&quot;.</p><p>Inspired by the <a href="https://github.com/rchatley/extreme_startup">Extreme Startup game</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/strings/detect_anagrams.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.determinant-Tuple{Any}" href="#TheAlgorithms.determinant-Tuple{Any}"><code>TheAlgorithms.determinant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">determinant(mat)</code></pre><p>Given a non singluar matrix, calculate its determinant using LU decomposition.</p><p>L and U are lower triangular and upper triangular matrices respectively such that</p><p>A = L*U</p><p>If we want to find the determinant, then</p><p>det(A) = det(LU) = det(L)*det(U)</p><p>Determinant of triangualar matrices is the product of their diagonal entries. Hence, makes finding the determinant easy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/matrix/determinant.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.dna2rna-Tuple{AbstractString}" href="#TheAlgorithms.dna2rna-Tuple{AbstractString}"><code>TheAlgorithms.dna2rna</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dna2rna(s::AbstractString)</code></pre><p>Given: A DNA string t</p><p>having length at most 1000 nt.</p><p>Return: The transcribed RNA string of t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/project-rosalind/dna2rna.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.encode-Tuple{Any}" href="#TheAlgorithms.encode-Tuple{Any}"><code>TheAlgorithms.encode</code></a> — <span class="docstring-category">Method</span></header><section><div><p>encode(input)</p><p>Program to implement atbash cipher for the given sentence.A full description of the algorithm can be found on <a href="https://en.wikipedia.org/wiki/Atbash">wikipedia</a></p><p><strong>Arguments:</strong></p><ul><li><code>input</code> : The sentence needed to rotate</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; encode(&quot;test&quot;)
gvhg

julia&gt; encode(&quot;abcdefghijklmnopqrstuvwxyz&quot;)
zyxwvutsrqponmlkjihgfedcba

julia&gt; encode(&quot;hello&quot;)
svool
</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">
for r in input
    part *= xform(r)
    if length(part) &gt;= 5
      push!(parts, part)
      part = &quot;&quot;
    end
  end
  if part != &quot;&quot;
    push!(parts, part)
  end
  return join(parts, &quot; &quot;)
</code></pre><p><strong>References:</strong></p><p>https://en.wikipedia.org/wiki/Atbash</p><p>```</p><p><strong>Contributed by:- <a href="https://github.com/Ihjass">Ihjass Thasbekha</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/cipher/atbash.jl#L1-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.eratosthenes-Tuple{Any}" href="#TheAlgorithms.eratosthenes-Tuple{Any}"><code>TheAlgorithms.eratosthenes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sieve of Eratosthenes is an algorithm for finding all the primes upto a limit <code>n</code>.</p><p>Reference: -https://en.wikipedia.org/wiki/Sieve<em>of</em>Eratosthenes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/sieve_of_eratosthenes.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.euler_method" href="#TheAlgorithms.euler_method"><code>TheAlgorithms.euler_method</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">euler_method(f, x0, span, h=1.0e-2)</code></pre><p>Calculate the solution to a differential equation using forward euler method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/euler_method.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.exponential_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:Real" href="#TheAlgorithms.exponential_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:Real"><code>TheAlgorithms.exponential_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> exponential_search(arr::AbstractArray{T,1}, x::T) where {T &lt;: Real}</code></pre><p>Exponential Search in 1-D array Time Complexity:  O(Log n)</p><p><strong>Exponential Search</strong></p><p>It works in O(Log n) time Exponential search involves two steps:</p><ul><li>Find range where element is present</li><li>Do Binary Search in above found range.</li></ul><p><strong>Time Complexity :</strong></p><p>O(Log n) Applications of Exponential Search: Exponential Binary Search is particularly useful for unbounded searches, where size of array is infinite. Please refer Unbounded Binary Search for an example. It works better than Binary Search for bounded arrays, and also when the element to be searched is closer to the first element.</p><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ash</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/searches/exponential_search.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.factorial_iterative-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.factorial_iterative-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.factorial_iterative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factorial_iterative(n)</code></pre><p>Finds factorial of a number using Iterative method</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">factorial_iterative(5)      # returns 120
factorial_iterative(-1)     # returns error</code></pre><p><strong>Reference</strong></p><ul><li>factorial of a positive integer – https://en.wikipedia.org/wiki/Factorial</li></ul><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/factorial.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.factorial_recursive-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.factorial_recursive-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.factorial_recursive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factorial_recursive(n)</code></pre><p>Finds factorial of anumber using recursive method</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">factorial_recursive(5)      # returns 120</code></pre><p><strong>Reference</strong></p><ul><li>factorial of a positive integer – https://en.wikipedia.org/wiki/Factorial</li></ul><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/factorial.jl#L30-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.fahrenheit_to_celsius" href="#TheAlgorithms.fahrenheit_to_celsius"><code>TheAlgorithms.fahrenheit_to_celsius</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fahrenheit<em>to</em>celsius(fahrenheit, ndigits::Int = 2)</p><p>Converts fahrenheit to celsius and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">fahrenheit_to_celsius(273.354, 3) == 134.086 # returns true
fahrenheit_to_celsius(273.354, 0) == 134.0   # returns true
fahrenheit_to_celsius(0.0) == -17.78         # returns true
fahrenheit_to_celsius(20.0) == -6.67         # returns true
fahrenheit_to_celsius(40.0) == 4.44          # returns true
fahrenheit_to_celsius(60.0) == 15.56         # returns true
fahrenheit_to_celsius(80.0) == 26.67         # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/conversions/temparature_conversion.jl#L40-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.fahrenheit_to_kelvin" href="#TheAlgorithms.fahrenheit_to_kelvin"><code>TheAlgorithms.fahrenheit_to_kelvin</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fahrenheit<em>to</em>kelvin(fahrenheit, ndigits::Int = 2)</p><p>Converts fahrenheit to kelvin and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">fahrenheit_to_kelvin(273.354, 3) == 407.236 # returns true
fahrenheit_to_kelvin(273.354, 0) == 407.0   # returns true
fahrenheit_to_kelvin(0) == 255.37           # returns true
fahrenheit_to_kelvin(20.0) == 266.48        # returns true
fahrenheit_to_kelvin(40.0) == 277.59        # returns true
fahrenheit_to_kelvin(60.0) == 288.71        # returns true
fahrenheit_to_kelvin(80.0) == 299.82        # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/conversions/temparature_conversion.jl#L61-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.fcfs-Tuple{Any, Any, Any}" href="#TheAlgorithms.fcfs-Tuple{Any, Any, Any}"><code>TheAlgorithms.fcfs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fcfs(n, process_id, burst_time)</code></pre><p>Implementation of first come first served scheduling algorithm</p><p><strong>Output</strong></p><p>Tuple of vectors (process<em>id, burst</em>time, waiting<em>time, turnaround</em>time, avg<em>waiting</em>time, avg<em>turnaround</em>time)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">n = 3 # number of processes
process_id = Any[1, 2, 3] # process ids
burst_times = Any[3, 4, 5] # burst times
fcfs(n, process_id, burst_times)</code></pre><p><strong>Reference</strong></p><p>https://en.wikipedia.org/wiki/Scheduling<em>(computing)#First</em>come,<em>first</em>served</p><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/scheduling/fcfs.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.find-Tuple{DisjointSet, Int64}" href="#TheAlgorithms.find-Tuple{DisjointSet, Int64}"><code>TheAlgorithms.find</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the ancestor of node <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/data_structures/disjoint_set/disjoint_set.jl#L13-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.floor_val-Tuple{Any}" href="#TheAlgorithms.floor_val-Tuple{Any}"><code>TheAlgorithms.floor_val</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floor_val(x)</code></pre><p>Finds the floor of x as an Integer</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">floor_val(1.3)  # 1
floor_val(2.0)  # returns 2.0
floor_val(-1.7) # returns -2.0</code></pre><p><strong>Reference</strong></p><ul><li>https://en.wikipedia.org/wiki/Floor<em>and</em>ceiling_functions</li></ul><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/ceil_floor.jl#L20-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.gauss_jordan-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number" href="#TheAlgorithms.gauss_jordan-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.gauss_jordan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gauss_jordan(A::AbstractMatrix{T}) where T&lt;:Number</code></pre><p>Gaussian elimination, also known as row reduction, is an algorithm for solving systems of linear equations.  It consists of a sequence of operations performed on the corresponding matrix of coefficients.  This method can also be used to compute the rank of a matrix, the determinant of a square matrix, and the inverse of an invertible matrix. https://en.wikipedia.org/wiki/Gaussian_elimination</p><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; M1 = [1 2 3; 4 5 6];
julia&gt; M2 = [1 2 3; 4 8 12];

julia&gt; @test gauss_jordan(M1) == [1 0 -1; 0 1 2]        # Test Passed
julia&gt; @test_throws AssertionError gauss_jordan(M2)     # Test Passed - Thrown: AssertionError</code></pre><p><strong>Contributed By:- <a href="https://github.com/AugustoCL">AugustoCL</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/matrix/gauss_jordan_elim.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.heap_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Any}, Tuple{Vector{T}, Any, Int64}} where T" href="#TheAlgorithms.heap_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Any}, Tuple{Vector{T}, Any, Int64}} where T"><code>TheAlgorithms.heap_sort!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heap_sort!(arr::Vector{T}, gt = &gt;, N::Int = length(arr)) where {T}</code></pre><p>Sort the given vector (in-place) using the Heapsort algorithm.</p><p>Heapsort consists of two stages:</p><ol><li>Building a (max) heap of the array</li><li>Repeatedly extracting the largest element and inserting it at the front of the sorted part of the array</li></ol><p>After the largest element has been extracted, the tree is updated to maintain the heap property via a &quot;sifting&quot; operation.</p><p>Storing a heap in an array is pretty straightforward - for every node with index n, its children are stored at indices   2n + 1 and 2n + 2 (for 0-based indices). Index 0 contains the root node.   Since Julia&#39;s indices are 1-based, we need to change this a little bit. We&#39;re using a trivial helper function    idx_for to convert from 0-based to 1-based.</p><p>See https://en.wikipedia.org/wiki/Heapsort for a complete explanation of Heapsort.</p><p>Contributed By:- <a href="https://github.com/frankschmitt">Frank Schmitt</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/sorts/heap_sort.jl#L10-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.idx_for-Tuple{Int64}" href="#TheAlgorithms.idx_for-Tuple{Int64}"><code>TheAlgorithms.idx_for</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">idx_for(i::Int)</code></pre><p>Simple helper function for converting 0-based indices to Julia&#39;s 1-based indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/sorts/heap_sort.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.interpolation_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real" href="#TheAlgorithms.interpolation_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real"><code>TheAlgorithms.interpolation_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> interpolation_search(arr::AbstractArray{T,1}, l::T, r::T, x::T) where {T &lt;: Real}</code></pre><p>Interpolation Search in 1-D array Time Complexity: O(log2(log2 n))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/searches/interpolation_search.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.is_armstrong-Tuple{Any}" href="#TheAlgorithms.is_armstrong-Tuple{Any}"><code>TheAlgorithms.is_armstrong</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_armstrong(x)</code></pre><p>Program to check if a number is an <a href="https://en.wikipedia.org/wiki/Narcissistic_number">Armstrong/Narcissistic number</a> in decimal system.</p><p>Armstrong number is a number that is the sum of its own digits raised to the power of the number of digits.</p><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p><p>A positive integer is called an Armstrong number (of order n) if</p><p><code>abcd... = a^n + b^n + c^n + d^n +....</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/armstrong_number.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.ispangram-Tuple{Any}" href="#TheAlgorithms.ispangram-Tuple{Any}"><code>TheAlgorithms.ispangram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ispangram(input)</p><p>Program to determine the sentence is pangram or not.The program will return true if it is pangram and false if it is not.A full description of the algorithm can be found on <a href="https://exercism.org/tracks/julia/exercises/pangram">exercism</a></p><p><strong>Arguments:</strong></p><ul><li><code>input</code>: The sentence to find if its pangram or not.</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; ispangram(Pack my box with five dozen liquor jugs)
true

julia&gt; ispangram(The quick brown fox jumps over the lazy dog)
true

julia&gt; wordcount(hello world!!!)
false
</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">
for letter in input
    if &#39;A&#39; &lt;= letter &lt;= &#39;Z&#39;
        x &amp;= ~(1&lt;&lt;(letter-&#39;A&#39;))
    elseif &#39;a&#39; &lt;= letter &lt;= &#39;z&#39;
        x &amp;= ~(1&lt;&lt;(letter-&#39;a&#39;))
    end
    x == 0 &amp;&amp; return true
end
</code></pre><p><strong>References:</strong></p><p>(https://exercism.org/tracks/julia/exercises/pangram)</p><p>```</p><p><strong>Contributed by:- <a href="https://github.com/Ihjass">Ihjass Thasbekha</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/strings/pangram.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.jump_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:Real" href="#TheAlgorithms.jump_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:Real"><code>TheAlgorithms.jump_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jump_search(arr::AbstractArray{T,1}, x::T, jump::T = Int(ceil(sqrt(n)))) where {T &lt;: Real}</code></pre><p>Jump Search in 1-D array Time Complexity :  O(√ n) Time complexity of Jump Search is between Linear Search ( ( O(n) ) and Binary Search ( O (Log n) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/searches/jump_search.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.kelvin_to_celsius" href="#TheAlgorithms.kelvin_to_celsius"><code>TheAlgorithms.kelvin_to_celsius</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function kelvin<em>to</em>celsius(kelvin, ndigits::Int = 2)</p><p>Converts kelvin to celsius and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">kelvin_to_celsius(273.354, 3) == 0.204   # returns true
kelvin_to_celsius(273.354, 0) == 0.0     # returns true
kelvin_to_celsius(273.15) == 0.0         # returns true
kelvin_to_celsius(300) == 26.85          # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/conversions/temparature_conversion.jl#L85-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.kelvin_to_fahrenheit" href="#TheAlgorithms.kelvin_to_fahrenheit"><code>TheAlgorithms.kelvin_to_fahrenheit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function kelvin<em>to</em>fahrenheit(kelvin, ndigits::Int = 2)</p><p>Converts kelvin to fahrenheit and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">kelvin_to_fahrenheit(273.354, 3) == 32.367  # returns true
kelvin_to_fahrenheit(273.354, 0) == 32.0    # returns true
kelvin_to_fahrenheit(273.15) == 32.0        # returns true
kelvin_to_fahrenheit(300) == 80.33          # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/conversions/temparature_conversion.jl#L103-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.krishnamurthy-Tuple{Any}" href="#TheAlgorithms.krishnamurthy-Tuple{Any}"><code>TheAlgorithms.krishnamurthy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">krishnamurthy(number)</code></pre><p>Check if a number is a Krishnamurthy number or not</p><p><strong>Details</strong></p><p>It is also known as Peterson Number. </p><p>A Krishnamurthy Number is a number whose sum of the factorial of the digits equals to the original number itself.</p><p>For example: 145 = 1! + 4! + 5!     So, 145 is a Krishnamurthy Number</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">krishnamurthy(145) # returns true
krishnamurthy(240) # returns false
krishnamurthy(1)   # returns true </code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/krishnamurthy_number.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.line_length" href="#TheAlgorithms.line_length"><code>TheAlgorithms.line_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">line_length(f, x_start, x_end, steps=100)</code></pre><p>Approximates the arc length of a line segment by treating the curve as a sequence of linear lines and summing their lengths.</p><p>Arguments:</p><ul><li>f: function that returns the arc</li><li>x_start: starting x value</li><li>x<em>end: ending x</em>value</li><li>steps: steps to take for accurace, more the steps greater the accuracy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/line_length.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.linear_search-Tuple{Any, Any}" href="#TheAlgorithms.linear_search-Tuple{Any, Any}"><code>TheAlgorithms.linear_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linear_search(array, key)</code></pre><p>A simple search of <code>array</code>, element per element until <code>key</code> is found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/searches/linear_search.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.lu_decompose-Tuple{Any}" href="#TheAlgorithms.lu_decompose-Tuple{Any}"><code>TheAlgorithms.lu_decompose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lu_decompose(mat)</code></pre><p>Decomposes a <code>n x n</code> non singular matrix into a lower triangular matrix (L) and an upper triangular matrix (U)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/matrix/lu_decompose.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.mean-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#TheAlgorithms.mean-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean(nums)</code></pre><p>Find mean of a vector of numbers</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mean([3, 6, 9, 12, 15, 18, 21])      # returns 12.0
mean([5, 10, 15, 20, 25, 30, 35])    # returns 20.0
mean([1, 2, 3, 4, 5, 6, 7, 8])       # returns 4.5</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/average_mean.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.median-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#TheAlgorithms.median-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.median</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">median(nums)</code></pre><p>Finds median of a vector of numbers</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">median([2,1,3,4])                   # returns 2.5
median([2, 70, 6, 50, 20, 8, 4])    # returns 8
median([0])                         # returns 0</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/average_median.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.mode-Tuple{Any}" href="#TheAlgorithms.mode-Tuple{Any}"><code>TheAlgorithms.mode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mode(nums)</code></pre><p>Finds mode of a vector of numbers</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mode([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2])        # returns [2]
mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2])        # returns [2]
mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2])  # returns [2, 4]
mode([&quot;x&quot;, &quot;y&quot;, &quot;y&quot;, &quot;z&quot;])                              # returns [&quot;y&quot;]
mode([&quot;x&quot;, &quot;x&quot; , &quot;y&quot;, &quot;y&quot;, &quot;z&quot;])                       # returns [&quot;x&quot;, &quot;y&quot;]</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/average_mode.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.monte_carlo_integration-Tuple{Function, Real, Real, Int64}" href="#TheAlgorithms.monte_carlo_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.monte_carlo_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">monte_carlo_integration(f::Function, a::Real, b::Real, n::Int)</code></pre><p>Monte carlo integration is a very easy and scalable way to do multidimentional integrals. However, only single variable integrals are considered.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: the function to integrate. (at the momment only single variable is suported)</li><li><code>a</code>: start in the integration limits.</li><li><code>b</code>: endin the integration limits.</li><li><code>N</code>: Number of points to sample. For most simple functions, 1000 to 10,000 should be okay.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; monte_carlo_integration(x -&gt; 3*x^2, 0, 1, 100000) # integrate a polynomial
1.0000037602209

julia&gt; monte_carlo_integration(x -&gt; sin(x), 0, pi, 1000) # integrate the sin function
2.0018927826323756</code></pre><p><strong>References</strong></p><ul><li>https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration</li><li>https://kingaa.github.io/sbied/pfilter/monteCarlo.html</li></ul><p><strong>Contributors</strong></p><ul><li><a href="https://github.com/AugustoCL">AugustoCL</a></li><li><a href="https://github.com/Ved-Mahajan">Ved Mahajan</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/monte_carlo_integration.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.perfect_cube-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.perfect_cube-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.perfect_cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perfect_cube(number)</code></pre><p>Check if a number is a perfect cube or not.</p><p><strong>Example</strong></p><pre><code class="language-jula hljs">perfect_cube(27) # returns true
perfect_cube(4)  # returns false</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/perfect_cube.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.perfect_number-Tuple{N} where N&lt;:Number" href="#TheAlgorithms.perfect_number-Tuple{N} where N&lt;:Number"><code>TheAlgorithms.perfect_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perfect_number(number)</code></pre><p>Checks if a number is a perfect_number number or not</p><p><strong>Details</strong></p><p>perfect_number number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself.</p><p>For example : 6 is perfect_number number</p><p>Divisors of 6 =&gt; [1,2,3]</p><p>Sum of divisors =&gt; 1+2+3 = 6</p><p>6 == sum(divisors) # which is true</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">perfect_number(27)     # returns false
perfect_number(28)     # returns true
perfect_number(496)    # returns true
perfect_number(8128)   # returns true
perfect_number(123)    # returns false</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/perfect_number.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.perfect_square-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.perfect_square-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.perfect_square</code></a> — <span class="docstring-category">Method</span></header><section><div><p>perfect_square(number)</p><p>Check if a number is a perfect square or not.</p><p><strong>Example</strong></p><pre><code class="language-jula hljs">perfect_square(9)   # returns True
perfect_square(16)  # returns True
perfect_square(1)   # returns True
perfect_square(0)   # returns True
perfect_square(10)  # returns False
perfect_square(-9)  # returns False</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/perfect_square.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.prime_check-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.prime_check-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.prime_check</code></a> — <span class="docstring-category">Method</span></header><section><div><p>prime_check(number)</p><p>Checks to see if a number is a prime or not</p><p>A number is prime if it has exactly two factors: 1 and itself.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">prime_check(2) # returns true
prime_check(3) # returns true
prime_check(5) # returns true
prime_check(7) # returns true
prime_check(11) # returns true
prime_check(13) # returns true
prime_check(17) # returns true
prime_check(19) # returns true
prime_check(23) # returns true
prime_check(29) # returns true
prime_check(30) # returns false</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/prime_check.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.prime_factors-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.prime_factors-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.prime_factors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>prime_factors(number)</p><p>Returns prime factors of <code>number</code> as a vector</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">prime_factors(50)          # returns [2,5,5]
prime_factors(0)           # returns []
prime_factors(100)         # returns [2, 2, 5, 5]
prime_factors(2560)        # returns [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/prime_factors.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.rabin_karp-Tuple{String, String}" href="#TheAlgorithms.rabin_karp-Tuple{String, String}"><code>TheAlgorithms.rabin_karp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rabin_karp(text, pattern)</code></pre><p><strong>Brief:</strong></p><pre><code class="nohighlight hljs">A function that finds all occurrences of a pattern in the given text.
Instead of checking each character ot the pattern with each character block of the text,
for each character block calculate the hash value, and only if that value matches hash value of the pattern,
compare them character by character. These blocks are the same length as the pattern.</code></pre><p><strong>Returns:</strong></p><pre><code class="nohighlight hljs">A list with starting indices where the pattern was found</code></pre><p><strong>References:</strong></p><pre><code class="nohighlight hljs">https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/</code></pre><p><strong>Contributed by: <a href="https://github.com/Nikola-Mircic">Nikola Mircic</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/strings/rabin_karp.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.riemann_integration" href="#TheAlgorithms.riemann_integration"><code>TheAlgorithms.riemann_integration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">riemann_integration(f::Function, a::Real, b::Real, n::Int, approx::Symbol = :midpoint)</code></pre><p>a Riemann sum is a certain kind of approximation of an integral by a finite sum. The sum is calculated by partitioning the region into shapes (rectangles, trapezoids, parabolas, or cubics) that together form a region that is similar to the region being measured, then calculating the area for each of these shapes, and finally adding all of these small areas together.</p><p>Because the region filled by the small shapes is usually not exactly the same shape as the region being measured, the Riemann sum will differ from the area being measured.  This error can be reduced by dividing up the region more finely, using smaller and smaller shapes.  As the shapes get smaller and smaller, the sum approaches the Riemann integral.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: the function to integrate. (at the momment only single variable is suported)</li><li><code>a</code>: Start of the integration limit.</li><li><code>b</code>: End of the integration limit.</li><li><code>n</code>: Number of points to sample. (as n increase, error decrease)</li><li><code>approx</code>: Indicate the method of approximation (midpoint, left or right)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; riemann_integration(x -&gt; x, 1, 3, 1_000, :midpoint)  # 4.0
julia&gt; riemann_integration(x -&gt; x, 1, 3, 1_000, :left)      # 3.997997997997998
julia&gt; riemann_integration(x -&gt; x, 1, 3, 1_000, :right)     # 4.002002002002002
julia&gt; riemann_integration(x -&gt; 3*x^2, 0, 1, 100000)        # integrate a polynomial
0.9999999999750021
julia&gt; riemann_integration(x -&gt; sin(x), 0, pi, 1000)          # integrate the sin function
2.0000008241146774</code></pre><p><strong>Refereces</strong></p><ul><li>https://www.khanacademy.org/math/ap-calculus-ab/ab-integration-new/ab-6-2/a/riemann-sums-review</li><li>https://math.libretexts.org/Courses/Mount<em>Royal</em>University/MATH<em>2200%3A</em>Calculus<em>for</em>Scientists<em>II/2%3A</em>Techniques<em>of</em>Integration/2.5%3A<em>Numerical</em>Integration<em>-</em>Midpoint%2C<em>Trapezoid%2C</em>Simpson&#39;s_rule</li><li>https://abel.math.harvard.edu/~knill/teaching/math1a_2011/handouts/40-numerical.pdf</li><li>https://en.wikipedia.org/wiki/Riemann_integral</li></ul><p>Contributed By:- <a href="https://github.com/AugustoCL">AugustoCL</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/riemann_integration.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.rotation_matrix-Tuple{Any}" href="#TheAlgorithms.rotation_matrix-Tuple{Any}"><code>TheAlgorithms.rotation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A 2D Rotation matrix is a mtrix that rotates a vector in a 2D real space by an angle theta. For more info: https://en.wikipedia.org/wiki/Rotation_matrix</p><p>This function takes the angle <code>theta</code> in radians as input and returns a 2D Matrix which will rotate the the vector by angle <code>theta</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/matrix/rotation-matrix.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.simpsons_integration-Tuple{Function, Real, Real, Int64}" href="#TheAlgorithms.simpsons_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.simpsons_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simpsons_integration(f::Function, a::Real, b::Real, n::Int)</code></pre><p>Simpson&#39;s rule uses a quadratic polynomial on each subinterval of a partition to approximate the function f(x) and to compute the definite integral.  This is an improvement over the trapezoid rule which approximates f(x) by a straight line on each subinterval of a partition. For more details of the method, check the link in the reference.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The function to integrate. (ar the moment only single variable is suported)</li><li><code>a</code>: Start of the integration limit.</li><li><code>b</code>: End of the integration limit.</li><li><code>n</code>: Number of points to sample. (as n increase, error decrease)</li></ul><p><strong>Examples/Test</strong></p><pre><code class="language-julia hljs"># aproximate pi with f(x) = 4 / (1 + x^2)
julia&gt; simpsons_integration(x -&gt; 4 / (1 + x^2), 0, 1, 100_000)
3.1415926535897936
julia&gt; simpsons_integration(x -&gt; 4 / (1 + x^2), 0, 1, 100_000) ≈ pi
true</code></pre><p><strong>References:</strong></p><ul><li>https://personal.math.ubc.ca/~pwalls/math-python/integration/simpsons-rule/</li></ul><p><strong>Contributed By:- <a href="https://github.com/AugustoCL">AugustoCL</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/simpsons_integration.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.sum_ap-Tuple{Any, Any, Any}" href="#TheAlgorithms.sum_ap-Tuple{Any, Any, Any}"><code>TheAlgorithms.sum_ap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum_ap(first_term, diff, num_terms)</code></pre><p>Finds sum of a arithmetic progression series</p><p><strong>Input parameters</strong></p><ul><li>first_term : first term of the series</li><li>diff       : common difference between consecutive terms</li><li>num_terms  : number of terms in the series till which we count sum</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sum_ap(1, 1, 10)    # returns 55.0 
sum_ap(1, 10, 100)  # returns 49600.0</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/sum_of_arithmetic_series.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.sum_gp-Tuple{Any, Any, Any}" href="#TheAlgorithms.sum_gp-Tuple{Any, Any, Any}"><code>TheAlgorithms.sum_gp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum_gp(first_term, ratio, num_terms)</code></pre><p>Finds sum of n terms in a geometric progression</p><p><strong>Input parameters</strong></p><ul><li>first_term : first term of the series</li><li>raio      : common ratio between consecutive terms -&gt; a2/a1 or a3/a2 or a4/a3</li><li>num_terms  : number of terms in the series till which we count sum</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sum_gp(1, 2, 10)    # 1023.0
sum_gp(1, 10, 5)    # 11111.0
sum_gp(0, 2, 10)    # 0.0
sum_gp(1, 0, 10)    # 1.0
sum_gp(1, 2, 0)     # -0.0
sum_gp(-1, 2, 10)   # -1023.0
sum_gp(1, -2, 10)   # -341.0</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/sum_of_geometric_progression.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.surfarea_cube-Tuple{Any}" href="#TheAlgorithms.surfarea_cube-Tuple{Any}"><code>TheAlgorithms.surfarea_cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surfarea_cube(side)</code></pre><p>Finds surface area of a cube</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">surfarea_cube(1)  # returns 6
surfarea_cube(3)  # returns 54
surfarea_cube(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/area.jl#L4-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.surfarea_sphere-Tuple{Any}" href="#TheAlgorithms.surfarea_sphere-Tuple{Any}"><code>TheAlgorithms.surfarea_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surfarea_sphere(side)</code></pre><p>Finds surface area of a sphere</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">surfarea_sphere(5)  # returns 314.1592653589793
surfarea_sphere(1)  # returns 12.566370614359172
surfarea_sphere(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/area.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.trapazoidal_area-NTuple{4, Any}" href="#TheAlgorithms.trapazoidal_area-NTuple{4, Any}"><code>TheAlgorithms.trapazoidal_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trapazoidal_area(f, x_start, x_end, steps)</code></pre><p>Approximates the area under the curve using the trapezoidal rule Arguments:</p><ul><li>f: function for the</li><li>x_start: starting value for x</li><li>x_end: ending value for x</li><li>steps: steps taken while integrating.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/area.jl#L265-L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.trapezoid_integration-Tuple{Function, Real, Real, Int64}" href="#TheAlgorithms.trapezoid_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.trapezoid_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trapezoid_integration(f::Function, a::Real, b::Real, n::Int)</code></pre><p>The trapezoidal rule works by approximating the region under the graph of the function f(x) as a trapezoid and calculating its area.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: the function to integrate. (at the momment only single variable is suported)</li><li><code>a</code>: Start of the integration limit.</li><li><code>b</code>: End of the integration limit.</li><li><code>n</code>: Number of points to sample. (as n increase, error decrease)</li></ul><p><strong>Examples/Test</strong></p><pre><code class="language-julia hljs">julia&gt; trapezoid_integration(x -&gt; 4 / (1 + x^2), 0, 1, 100_000)
3.1415926535731526
julia&gt; trapezoid_integration(x -&gt; 4 / (1 + x^2), 0, 1, 100_000) ≈ pi
true</code></pre><p><strong>References:</strong></p><p>-https://personal.math.ubc.ca/~pwalls/math-python/integration/trapezoid-rule/ -https://en.wikipedia.org/wiki/Trapezoidal_rule</p><p><strong>Contributed By:- <a href="https://github.com/AugustoCL">AugustoCL</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/trapezoid_integration.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.variance-Tuple{Any}" href="#TheAlgorithms.variance-Tuple{Any}"><code>TheAlgorithms.variance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variance(a)</code></pre><p>Find the variance from a set of data.</p><p><strong>Arguments:</strong></p><ul><li><code>a</code>: holds the set of data</li></ul><p><strong>Reference</strong></p><pre><code class="nohighlight hljs">- According to Ronald E. Walpole, `variance` is used to measure the variability of a set of data. -- Introduction to Statistics by Ronald E. Walpole</code></pre><p><strong>Contributors:</strong></p><ul><li><a href="https://github.com/arubhardwaj">Aru Bhardwaj</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/statistics/variance.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.verlet_integration" href="#TheAlgorithms.verlet_integration"><code>TheAlgorithms.verlet_integration</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Verlet integration is an integration method used to integrate newtons - law of motion. It is frequently used to find trajectories in molecular dynamics simulation. The function takes <code>four</code> inputs viz,</p><ul><li><code>f</code> : the differential equation</li><li><code>x0</code> : the initial condition. This is a Vector with the first element as initial value for position(x<em>0) and the the second  initial condition for velocity (v</em>0) </li><li><code>tspan</code>: is the time span for integration. It is a tuple (initial time, final time)</li></ul><p>This functionr returns a tuple (x,t):</p><ul><li><code>x</code> is the solution</li><li><code>t</code> is the array containing the time points</li></ul><p>Reference:</p><ul><li>https://www.algorithm-archive.org/contents/verlet<em>integration/verlet</em>integration.html</li></ul><p>Contributed by: <a href="https://github.com/Ved-Mahajan">Ved Mahajan</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/verlet.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_circular_cylinder-Tuple{Any, Any}" href="#TheAlgorithms.vol_circular_cylinder-Tuple{Any, Any}"><code>TheAlgorithms.vol_circular_cylinder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_circular_cylinder(area_of_, height)</code></pre><p>Compute the Volume of a Circular Cylinder.</p><p><strong>Examples</strong></p><p>```julia-repl julia&gt; vol<em>circular</em>cylinder(1, 1) 3.141592653589793 julia&gt; vol<em>circular</em>cylinder(4, 3) 150.79644737231007</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/volume.jl#L156-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_cone-Tuple{Any, Any}" href="#TheAlgorithms.vol_cone-Tuple{Any, Any}"><code>TheAlgorithms.vol_cone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_cone(area_of_base, height)</code></pre><p>Compute the Volume of a Cone</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_cone(10, 3)
10.0
julia&gt; vol_cone(1, 1)
0.3333333333333333</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/volume.jl#L49-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_cube-Tuple{Any}" href="#TheAlgorithms.vol_cube-Tuple{Any}"><code>TheAlgorithms.vol_cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_cube()</code></pre><p>Compute the volume of a cube.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_cube(1)
1
julia&gt; vol_cube(3)
27
julia&gt; vol_cube(-1)
DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/volume.jl#L5-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_cuboid-Tuple{Any, Any, Any}" href="#TheAlgorithms.vol_cuboid-Tuple{Any, Any, Any}"><code>TheAlgorithms.vol_cuboid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_cuboid(width, height, length)</code></pre><p>Compute the volume of a vol_cuboid</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_cuboid(1, 1, 1)
1
julia&gt; vol_cuboid(1, 2, 3)
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/volume.jl#L28-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_prism-Tuple{Any, Any}" href="#TheAlgorithms.vol_prism-Tuple{Any, Any}"><code>TheAlgorithms.vol_prism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_prism(area_of_base, height)</code></pre><p>Compute the Volume of a Prism.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_prism(10, 2)
20.0
julia&gt; vol_prism(11, 1)
11.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/volume.jl#L94-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_pyramid-Tuple{Any, Any}" href="#TheAlgorithms.vol_pyramid-Tuple{Any, Any}"><code>TheAlgorithms.vol_pyramid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_pyramid(area_of_base, height)</code></pre><p>Compute the volume of a Pyramid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_pyramid(10, 3)
10.0
julia&gt; vol_pyramid(1.5, 3)
1.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/volume.jl#L115-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_right_circ_cone-Tuple{Any, Any}" href="#TheAlgorithms.vol_right_circ_cone-Tuple{Any, Any}"><code>TheAlgorithms.vol_right_circ_cone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_right_circ_cone(radius, height)</code></pre><p>Compute the Volume of a Right Circular Cone.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_right_circ_cone(2, 3)
12.566370614359172</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/volume.jl#L71-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_sphere-Tuple{Any}" href="#TheAlgorithms.vol_sphere-Tuple{Any}"><code>TheAlgorithms.vol_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_sphere(radius)</code></pre><p>Compute the volume of a sphere.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">vol_sphere(5)  # returns 523.5987755982989
vol_sphere(1)  # returns 4.1887902047863905
vol_sphere(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/math/volume.jl#L136-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.word_count-Tuple{Any}" href="#TheAlgorithms.word_count-Tuple{Any}"><code>TheAlgorithms.word_count</code></a> — <span class="docstring-category">Method</span></header><section><div><p>wordcount(sentence)</p><p>Program to find word count in the given sentence. The program will return count with the word. A full description of the algorithm can be found on <a href="https://exercism.org/tracks/julia/exercises/word-count">exercism</a></p><p><strong>Arguments:</strong></p><ul><li><code>sentence</code>: The sentence to find the word count.</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; wordcount(The quick brown fox jumps over the lazy dog)
Dict{Any, Any}(&quot;jumps&quot; =&gt; 1, &quot;the&quot; =&gt; 2, &quot;brown&quot; =&gt; 1, &quot;over&quot; =&gt; 1, &quot;quick&quot; =&gt; 1, &quot;lazy&quot; =&gt; 1, &quot;dog&quot; =&gt; 1, &quot;fox&quot; =&gt; 1)

julia&gt; wordcount(the sky is blue and beautiful)
Dict{Any, Any}(&quot;and&quot; =&gt; 1, &quot;the&quot; =&gt; 1, &quot;sky&quot; =&gt; 1, &quot;blue&quot; =&gt; 1, &quot;is&quot; =&gt; 1, &quot;beautiful&quot; =&gt; 1)
</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">
for word in eachmatch(reg_expression, sentence)
    if !haskey(counts, word.match)
        counts[word.match] = 1
    else
        counts[word.match] += 1
    end
end
</code></pre><p><strong>References:</strong></p><p>(https://exercism.org/tracks/julia/exercises/word-count)</p><p>```</p><p><strong>Contributed by:- <a href="https://github.com/Ihjass">Ihjass Thasbekha</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/strings/word_count.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}" href="#TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.zero_one_pack!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_one_pack!(capacity::N, weights::V, values::V, dp::V) where {N &lt;: Number,V &lt;: AbstractVector}</code></pre><p>This does 0-1 (each item can be chosen only once) knapsack : pack capacity = capacity weight of each item = weights value of each item = values dp array is what the function works on It returns the ans (dp[capacity])</p><pre><code class="nohighlight hljs">julia&gt; dp=zeros(Int,30)
julia&gt; zero_one_pack!(20,[1,3,11],[2,5,30],dp)
37</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/knapsack/dynamic_programming.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}" href="#TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.zero_one_pack!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For greedy algorithm, it will take the element based on the optimal value in the array at each loop in the function</p><p>This does 0-1 (each item can be chosen only once) knapsack : pack capacity = capacity weight of each item = weights value of each item = values</p><p>Each loop the function will find the highest value in the array and check if the capacity is enough to store it, if enough then  the value will be added into the total<em>max</em>value.  After that the highest current value will be deleted.</p><pre><code class="nohighlight hljs">julia&gt; zero_one_pack!(20,[1,3,11],[2,5,30])
37</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/9564066df5f952562a7194d4657472222fde371b/src/knapsack/greedy_algorithm.jl#L1-L17">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Friday 25 March 2022 04:20">Friday 25 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
