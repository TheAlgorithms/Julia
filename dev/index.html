<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TheAlgorithms.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://TheAlgorithms.github.io/Julia/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TheAlgorithms.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/TheAlgorithms/Julia/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TheAlgorithms"><a class="docs-heading-anchor" href="#TheAlgorithms">TheAlgorithms</a><a id="TheAlgorithms-1"></a><a class="docs-heading-anchor-permalink" href="#TheAlgorithms" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/TheAlgorithms/Julia">TheAlgorithms</a>.</p><ul><li><a href="#TheAlgorithms.AbstractBinarySearchTree_arr"><code>TheAlgorithms.AbstractBinarySearchTree_arr</code></a></li><li><a href="#TheAlgorithms.AbstractBinaryTree_arr"><code>TheAlgorithms.AbstractBinaryTree_arr</code></a></li><li><a href="#TheAlgorithms.BinaryHeap"><code>TheAlgorithms.BinaryHeap</code></a></li><li><a href="#TheAlgorithms.DisjointSet"><code>TheAlgorithms.DisjointSet</code></a></li><li><a href="#TheAlgorithms.abs_max-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real"><code>TheAlgorithms.abs_max</code></a></li><li><a href="#TheAlgorithms.abs_min-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real"><code>TheAlgorithms.abs_min</code></a></li><li><a href="#TheAlgorithms.abs_val-Tuple{N} where N&lt;:Real"><code>TheAlgorithms.abs_val</code></a></li><li><a href="#TheAlgorithms.affine-Tuple{String, String, Int64, Int64}"><code>TheAlgorithms.affine</code></a></li><li><a href="#TheAlgorithms.area_circle-Tuple{Any}"><code>TheAlgorithms.area_circle</code></a></li><li><a href="#TheAlgorithms.area_ellipse-Tuple{Any, Any}"><code>TheAlgorithms.area_ellipse</code></a></li><li><a href="#TheAlgorithms.area_heron_triangle-Tuple{Any, Any, Any}"><code>TheAlgorithms.area_heron_triangle</code></a></li><li><a href="#TheAlgorithms.area_parallelogram-Tuple{Any, Any}"><code>TheAlgorithms.area_parallelogram</code></a></li><li><a href="#TheAlgorithms.area_polygon-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>TheAlgorithms.area_polygon</code></a></li><li><a href="#TheAlgorithms.area_rectangle-Tuple{Any, Any}"><code>TheAlgorithms.area_rectangle</code></a></li><li><a href="#TheAlgorithms.area_regular_polygon-Tuple{Any, Any}"><code>TheAlgorithms.area_regular_polygon</code></a></li><li><a href="#TheAlgorithms.area_rhombus-Tuple{Any, Any}"><code>TheAlgorithms.area_rhombus</code></a></li><li><a href="#TheAlgorithms.area_square-Tuple{Any}"><code>TheAlgorithms.area_square</code></a></li><li><a href="#TheAlgorithms.area_trapezium-Tuple{Any, Any, Any}"><code>TheAlgorithms.area_trapezium</code></a></li><li><a href="#TheAlgorithms.area_triangle-Tuple{Any, Any}"><code>TheAlgorithms.area_triangle</code></a></li><li><a href="#TheAlgorithms.atbash_encode-Tuple{Any}"><code>TheAlgorithms.atbash_encode</code></a></li><li><a href="#TheAlgorithms.bab_sqrt-Tuple{Real}"><code>TheAlgorithms.bab_sqrt</code></a></li><li><a href="#TheAlgorithms.bellman_ford"><code>TheAlgorithms.bellman_ford</code></a></li><li><a href="#TheAlgorithms.bfs"><code>TheAlgorithms.bfs</code></a></li><li><a href="#TheAlgorithms.binary_search-Tuple{Any, Any}"><code>TheAlgorithms.binary_search</code></a></li><li><a href="#TheAlgorithms.binary_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real"><code>TheAlgorithms.binary_search</code></a></li><li><a href="#TheAlgorithms.caesar-Tuple{Any, Any}"><code>TheAlgorithms.caesar</code></a></li><li><a href="#TheAlgorithms.ceil_val-Tuple{Any}"><code>TheAlgorithms.ceil_val</code></a></li><li><a href="#TheAlgorithms.celsius_to_fahrenheit"><code>TheAlgorithms.celsius_to_fahrenheit</code></a></li><li><a href="#TheAlgorithms.celsius_to_kelvin"><code>TheAlgorithms.celsius_to_kelvin</code></a></li><li><a href="#TheAlgorithms.coin_change-Tuple{Vector{Int64}, Int64}"><code>TheAlgorithms.coin_change</code></a></li><li><a href="#TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.complete_pack!</code></a></li><li><a href="#TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.complete_pack!</code></a></li><li><a href="#TheAlgorithms.count_nucleotides-Tuple{AbstractString}"><code>TheAlgorithms.count_nucleotides</code></a></li><li><a href="#TheAlgorithms.counting_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Int64}, Tuple{Vector{T}, Int64, Int64}} where T"><code>TheAlgorithms.counting_sort!</code></a></li><li><a href="#TheAlgorithms.detect_anagrams-Tuple{Any, Any}"><code>TheAlgorithms.detect_anagrams</code></a></li><li><a href="#TheAlgorithms.determinant-Tuple{Any}"><code>TheAlgorithms.determinant</code></a></li><li><a href="#TheAlgorithms.dfs"><code>TheAlgorithms.dfs</code></a></li><li><a href="#TheAlgorithms.dijkstra-Tuple{Vector{Vector{Tuple{Int64, Int64}}}, Int64}"><code>TheAlgorithms.dijkstra</code></a></li><li><a href="#TheAlgorithms.dna2rna-Tuple{AbstractString}"><code>TheAlgorithms.dna2rna</code></a></li><li><a href="#TheAlgorithms.eratosthenes-Tuple{Any}"><code>TheAlgorithms.eratosthenes</code></a></li><li><a href="#TheAlgorithms.euler_method"><code>TheAlgorithms.euler_method</code></a></li><li><a href="#TheAlgorithms.exponential_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:Real"><code>TheAlgorithms.exponential_search</code></a></li><li><a href="#TheAlgorithms.factorial_iterative-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.factorial_iterative</code></a></li><li><a href="#TheAlgorithms.factorial_recursive-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.factorial_recursive</code></a></li><li><a href="#TheAlgorithms.fahrenheit_to_celsius"><code>TheAlgorithms.fahrenheit_to_celsius</code></a></li><li><a href="#TheAlgorithms.fahrenheit_to_kelvin"><code>TheAlgorithms.fahrenheit_to_kelvin</code></a></li><li><a href="#TheAlgorithms.fcfs-Tuple{Any, Any, Any}"><code>TheAlgorithms.fcfs</code></a></li><li><a href="#TheAlgorithms.find-Tuple{DisjointSet, Int64}"><code>TheAlgorithms.find</code></a></li><li><a href="#TheAlgorithms.floor_val-Tuple{Any}"><code>TheAlgorithms.floor_val</code></a></li><li><a href="#TheAlgorithms.gauss_jordan-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.gauss_jordan</code></a></li><li><a href="#TheAlgorithms.get_dijkstra_path-Tuple{Vector{Int64}, Int64}"><code>TheAlgorithms.get_dijkstra_path</code></a></li><li><a href="#TheAlgorithms.heap_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Any}, Tuple{Vector{T}, Any, Int64}} where T"><code>TheAlgorithms.heap_sort!</code></a></li><li><a href="#TheAlgorithms.idx_for-Tuple{Int64}"><code>TheAlgorithms.idx_for</code></a></li><li><a href="#TheAlgorithms.interpolation_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real"><code>TheAlgorithms.interpolation_search</code></a></li><li><a href="#TheAlgorithms.is_armstrong-Tuple{Any}"><code>TheAlgorithms.is_armstrong</code></a></li><li><a href="#TheAlgorithms.isbefore-Union{Tuple{T}, Tuple{MinHeap{T}, T, T}} where T"><code>TheAlgorithms.isbefore</code></a></li><li><a href="#TheAlgorithms.ispangram-Tuple{Any}"><code>TheAlgorithms.ispangram</code></a></li><li><a href="#TheAlgorithms.jump_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:Real"><code>TheAlgorithms.jump_search</code></a></li><li><a href="#TheAlgorithms.kelvin_to_celsius"><code>TheAlgorithms.kelvin_to_celsius</code></a></li><li><a href="#TheAlgorithms.kelvin_to_fahrenheit"><code>TheAlgorithms.kelvin_to_fahrenheit</code></a></li><li><a href="#TheAlgorithms.krishnamurthy-Tuple{Any}"><code>TheAlgorithms.krishnamurthy</code></a></li><li><a href="#TheAlgorithms.line_length"><code>TheAlgorithms.line_length</code></a></li><li><a href="#TheAlgorithms.linear_search-Tuple{Any, Any}"><code>TheAlgorithms.linear_search</code></a></li><li><a href="#TheAlgorithms.lu_decompose-Tuple{Any}"><code>TheAlgorithms.lu_decompose</code></a></li><li><a href="#TheAlgorithms.mean-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.mean</code></a></li><li><a href="#TheAlgorithms.median-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.median</code></a></li><li><a href="#TheAlgorithms.mode-Tuple{Any}"><code>TheAlgorithms.mode</code></a></li><li><a href="#TheAlgorithms.monte_carlo_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.monte_carlo_integration</code></a></li><li><a href="#TheAlgorithms.partitions_recursive-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.partitions_recursive</code></a></li><li><a href="#TheAlgorithms.perfect_cube-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.perfect_cube</code></a></li><li><a href="#TheAlgorithms.perfect_number-Tuple{N} where N&lt;:Number"><code>TheAlgorithms.perfect_number</code></a></li><li><a href="#TheAlgorithms.perfect_square-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.perfect_square</code></a></li><li><a href="#TheAlgorithms.prime_check-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.prime_check</code></a></li><li><a href="#TheAlgorithms.prime_factors-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.prime_factors</code></a></li><li><a href="#TheAlgorithms.rabin_karp-Tuple{String, String}"><code>TheAlgorithms.rabin_karp</code></a></li><li><a href="#TheAlgorithms.riemann_integration"><code>TheAlgorithms.riemann_integration</code></a></li><li><a href="#TheAlgorithms.rotation_matrix-Tuple{Any}"><code>TheAlgorithms.rotation_matrix</code></a></li><li><a href="#TheAlgorithms.simpsons_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.simpsons_integration</code></a></li><li><a href="#TheAlgorithms.sum_ap-Tuple{Any, Any, Any}"><code>TheAlgorithms.sum_ap</code></a></li><li><a href="#TheAlgorithms.sum_gp-Tuple{Any, Any, Any}"><code>TheAlgorithms.sum_gp</code></a></li><li><a href="#TheAlgorithms.surfarea_cube-Tuple{Any}"><code>TheAlgorithms.surfarea_cube</code></a></li><li><a href="#TheAlgorithms.surfarea_cuboid-Tuple{Any, Any, Any}"><code>TheAlgorithms.surfarea_cuboid</code></a></li><li><a href="#TheAlgorithms.surfarea_sphere-Tuple{Any}"><code>TheAlgorithms.surfarea_sphere</code></a></li><li><a href="#TheAlgorithms.trapazoidal_area-NTuple{4, Any}"><code>TheAlgorithms.trapazoidal_area</code></a></li><li><a href="#TheAlgorithms.trapezoid_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.trapezoid_integration</code></a></li><li><a href="#TheAlgorithms.variance-Tuple{Any}"><code>TheAlgorithms.variance</code></a></li><li><a href="#TheAlgorithms.verlet_integration"><code>TheAlgorithms.verlet_integration</code></a></li><li><a href="#TheAlgorithms.vol_circular_cylinder-Tuple{Any, Any}"><code>TheAlgorithms.vol_circular_cylinder</code></a></li><li><a href="#TheAlgorithms.vol_cone-Tuple{Any, Any}"><code>TheAlgorithms.vol_cone</code></a></li><li><a href="#TheAlgorithms.vol_cube-Tuple{Any}"><code>TheAlgorithms.vol_cube</code></a></li><li><a href="#TheAlgorithms.vol_cuboid-Tuple{Any, Any, Any}"><code>TheAlgorithms.vol_cuboid</code></a></li><li><a href="#TheAlgorithms.vol_prism-Tuple{Any, Any}"><code>TheAlgorithms.vol_prism</code></a></li><li><a href="#TheAlgorithms.vol_pyramid-Tuple{Any, Any}"><code>TheAlgorithms.vol_pyramid</code></a></li><li><a href="#TheAlgorithms.vol_right_circ_cone-Tuple{Any, Any}"><code>TheAlgorithms.vol_right_circ_cone</code></a></li><li><a href="#TheAlgorithms.vol_sphere-Tuple{Any}"><code>TheAlgorithms.vol_sphere</code></a></li><li><a href="#TheAlgorithms.word_count-Tuple{Any}"><code>TheAlgorithms.word_count</code></a></li><li><a href="#TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.zero_one_pack!</code></a></li><li><a href="#TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.zero_one_pack!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.AbstractBinarySearchTree_arr" href="#TheAlgorithms.AbstractBinarySearchTree_arr"><code>TheAlgorithms.AbstractBinarySearchTree_arr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>array-based binary search tree left tree values &lt; root value &lt; right tree values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/data_structures/binary_tree/basic_binary_search_tree.jl#L2-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.AbstractBinaryTree_arr" href="#TheAlgorithms.AbstractBinaryTree_arr"><code>TheAlgorithms.AbstractBinaryTree_arr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>array-based binary tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/data_structures/binary_tree/basic_binary_tree.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.BinaryHeap" href="#TheAlgorithms.BinaryHeap"><code>TheAlgorithms.BinaryHeap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BinaryHeap{T,HT}</code></pre><p>A heap data structures implemented as a binary tree. It can be instantiated either as a <code>MinHeap</code> or <code>MaxHeap</code>. In a <code>MinHeap</code> each element in the tree is smaller than its children, and similarly, in a <code>MaxHeap</code> each element is greater than its children, this is called &quot;Heap Property&quot;.</p><p>One of the most common usage of the Heaps is as a Priority Queue. Note that the element with highest priority will always be at the root of the tree.</p><p>In this implementation, the tree is store in a <code>Vector</code> where the first element (<code>index = 1</code>) is the root and for all elements, it&#39;s children will be at <code>index * 2</code> and <code>index * 2 + 1</code>. The methods are implemented just once for both min and max heap, and it relies on the multiple dispatch of the <code>isbefore</code> function that will depend on the heap type.</p><p><strong>Functions:</strong></p><ul><li><code>MinHeap{T}</code>/<code>MaxHeap{T}</code>: constructors</li><li><code>push!(heap, elements...)</code>: push elements into the heap</li><li><code>top(heap)</code>: get the top element (smaller in a <code>MinHeap</code>, greater in a <code>MaxHeap</code>)</li><li><code>pop!(heap)</code>: get top element and remove it from the heap</li><li><code>isempty(heap)</code>: wheter theres no elemets in the heap</li><li><code>length(heap)</code>: how many elements are in the heap</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">heap = MinHeap{Int}()
push!(heap, 4, 2, 3, 1, 5)
while !isempty(heap)
    println(pop!(heap))
end

# output

1
2
3
4
5</code></pre><p><strong>Complexities:</strong></p><ul><li>Space: O(n)</li><li>Get top element: O(1)</li><li>Push a element: O(log n)</li><li>Pop a element: O(log n)</li><li>Get number of elements: O(1)</li></ul><p>Contributed By: <a href="https://github.com/gosoares">Gabriel Soares</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/data_structures/binary_heap.jl#L5-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.DisjointSet" href="#TheAlgorithms.DisjointSet"><code>TheAlgorithms.DisjointSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This can contain a maximum of <code>length(par)</code> parenting-relations par is an array of <code>Int</code>, which is the index of the parent node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/data_structures/disjoint_set/disjoint_set.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.abs_max-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real" href="#TheAlgorithms.abs_max-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real"><code>TheAlgorithms.abs_max</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs_max(x)</code></pre><p>Program to find the max absolute value in a vector</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">abs_max([1,3,4]) # returns 4
abs_max([-3,1,2]) # returns -3
abs_max([-7,-3,6]) #returns -7</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/abs.jl#L22-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.abs_min-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real" href="#TheAlgorithms.abs_min-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real"><code>TheAlgorithms.abs_min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs_min(num)</code></pre><p>Program to find the min absolute value in a vector</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">abs_min([1,3,4]) # returns 1
abs_min([-3,1,2]) # returns 1
abs_min([-7,-3,6]) #returns -3</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/abs.jl#L46-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.abs_val-Tuple{N} where N&lt;:Real" href="#TheAlgorithms.abs_val-Tuple{N} where N&lt;:Real"><code>TheAlgorithms.abs_val</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs_val(num)</code></pre><p>Program to find the absolute value of a number</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">abs_val(-100) # returns 100
abs_val(0) # returns 0
abs(123.1) # returns 123.1
-1000 == abs_val(-1000) #returns false
1000 == abs_val(1000) #returns true</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/abs.jl#L2-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.affine-Tuple{String, String, Int64, Int64}" href="#TheAlgorithms.affine-Tuple{String, String, Int64, Int64}"><code>TheAlgorithms.affine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">affine(text, alphabet, nMultiply, nAdd)</code></pre><p>Program to implement affine cipher for the given input. A full description of it can be found on <a href="https://en.wikipedia.org/wiki/Affine_cipher">wikipedia</a>.</p><p><strong>Arguments:</strong></p><ul><li><code>text</code> : text to be encoded/decoded</li><li><code>alphabet</code> : the alphaebt the text uses</li><li><code>nMultiply</code> : the number to the multiply by (a)</li><li><code>nAdd</code> : the number to add (b)</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">
julia&gt; affine(&quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;, 3, 1)
&quot;behknqtwzcfiloruxadgjmpsvy&quot;

julia&gt; affine(&quot;whyhellothere&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;, 17, 82)
&quot;otwtujjiptuhu&quot;

julia&gt; affine(&quot;1234&quot;, &quot;0123456789&quot;, 5, 2)
&quot;9630&quot;
</code></pre><p><strong>Algorithm:</strong></p><p>As usual, julia&#39;s 1 based indexing doesn&#39;t play nicely with the affine cipher, but all that is required is <code>-1</code> from the initial index of the letter and <code>+1</code> after the mod.  </p><p>An affine cipher uses a simple function: <code>f(x) = ax + b</code>.</p><p>Notes:</p><ul><li><code>nMultiply</code> and <code>length(alphabet)</code> <em>must</em> be coprime so that the two plaintext letters are not substituted for the same cipehrtext letter.</li><li>This doesn&#39;t check that the all of the characters in <code>text</code> actually are in <code>alphabet</code>, but that does need to be the case!</li></ul><pre><code class="language-julia hljs">
join([
    alphabet[((findfirst(isequal(letter), alphabet) - 1) * nMultiply + nAdd) % length(alphabet) + 1]
    for letter in text
])
</code></pre><p><strong>References:</strong></p><p>https://www.dcode.fr/affine-cipher   https://github.com/Squalm/Cipher-Tools</p><p><strong>Contributed by: <a href="https://github.com/Squalm">Chirp (Squalm)</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/cipher/affine.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_circle-Tuple{Any}" href="#TheAlgorithms.area_circle-Tuple{Any}"><code>TheAlgorithms.area_circle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_circle(radius)</code></pre><p>Finds area of the circle</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_circle(20) # returns 1256.6370614359173
area_circle(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L222-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_ellipse-Tuple{Any, Any}" href="#TheAlgorithms.area_ellipse-Tuple{Any, Any}"><code>TheAlgorithms.area_ellipse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_ellipse(radius_x, radius_y)</code></pre><p>Finds area of the ellipse</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_ellipse(10, 10) # returns 314.1592653589793
area_ellipse(10, 20) # returns 628.3185307179587
area_ellipse(1, -2) # returns DomainError
area_ellipse(-1, 2) # returns DomainError
area_ellipse(-1, -2) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L241-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_heron_triangle-Tuple{Any, Any, Any}" href="#TheAlgorithms.area_heron_triangle-Tuple{Any, Any, Any}"><code>TheAlgorithms.area_heron_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_heron_triangle(side1, side2, side3)</code></pre><p>Finds area of a triangle using heron&#39;s formula</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_heron_triangle(5,12,13) # returns 30.0
area_heron_triangle(-1,-2,1) # returns DomainError
area_heron_triangle(1,-2,1)  # returns DomainError
area_heron_triangle(-1,2,1)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L136-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_parallelogram-Tuple{Any, Any}" href="#TheAlgorithms.area_parallelogram-Tuple{Any, Any}"><code>TheAlgorithms.area_parallelogram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_parallelogram(base, height)</code></pre><p>Finds area of the parallelogram</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_parallelogram(10,20) # returns 200
area_parallelogram(-1,-2) # returns DomainError
area_parallelogram(1,-2)  # returns DomainError
area_parallelogram(-1,2)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L172-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_polygon-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real" href="#TheAlgorithms.area_polygon-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>TheAlgorithms.area_polygon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_polygon(V)</code></pre><p>Finds area of any Polygon given by continuous sequence of vertex coordinates Arguments:</p><ul><li>coords: x,y co-ordinates of the vertices   [Vector of Tuples / Matrix with 2 rows or 2 columns]</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_polygon([(0, 0), (100, 0), (0, 100)])  # returns 5000.0
area_polygon([0 0;100 0;100 100;0 100])  # returns 10000.0
area_polygon([(6, 4.5), (5, 4.5), (4.5, 5.5), (5, 6.5)]) # returns 1.5
area_polygon([0 0;100 0]) # returns DomainError
area_polygon([(6, 4.63), (5, 4.63)]) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L336-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_rectangle-Tuple{Any, Any}" href="#TheAlgorithms.area_rectangle-Tuple{Any, Any}"><code>TheAlgorithms.area_rectangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_rectangle(length, width)</code></pre><p>Finds area of the rectangle</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_rectangle(10,20) # returns 200
area_rectangle(-1,-2) # returns DomainError
area_rectangle(1,-2)  # returns DomainError
area_rectangle(-1,2)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L73-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_regular_polygon-Tuple{Any, Any}" href="#TheAlgorithms.area_regular_polygon-Tuple{Any, Any}"><code>TheAlgorithms.area_regular_polygon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_regular_polygon(sides, side_len)</code></pre><p>Finds area of any regular Polygon</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_regular_polygon(1, 5)  # returns DomainError
area_regular_polygon(3, 5)  # returns 10.825317547305486
area_regular_polygon(7, 15)  # returns 817.6302999003576
area_regular_polygon(-1, 4) # returns DomainError
area_regular_polygon(4, -3) # returns DomainError
area_regular_polygon(-12, -4) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L310-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_rhombus-Tuple{Any, Any}" href="#TheAlgorithms.area_rhombus-Tuple{Any, Any}"><code>TheAlgorithms.area_rhombus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_rhombus(diagonal_1, diagonal_2)</code></pre><p>Finds area of the rhombus</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_rhombus(10, 20) # returns 100.0
area_rhombus(-1,-2) # returns DomainError
area_rhombus(1,-2)  # returns DomainError
area_rhombus(-1,2)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L263-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_square-Tuple{Any}" href="#TheAlgorithms.area_square-Tuple{Any}"><code>TheAlgorithms.area_square</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_square(side)</code></pre><p>Finds area of the area_square</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_square(10) # returns 100
area_square(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L96-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_trapezium-Tuple{Any, Any, Any}" href="#TheAlgorithms.area_trapezium-Tuple{Any, Any, Any}"><code>TheAlgorithms.area_trapezium</code></a> — <span class="docstring-category">Method</span></header><section><div><p>area_trapezium(base1,base2,height)</p><p>Finds area of the traπzium</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_trapezium(10, 20, 30)  # returns 450.0
area_trapezium(-1, -2, -3)  # returns DomainError
area_trapezium(-1, 2, 3)    # returns DomainError
area_trapezium(1, -2, 3)    # returns DomainError
area_trapezium(1, 2, -3)    # returns DomainError
area_trapezium(-1, -2, 3)   # returns DomainError
area_trapezium(1, -2, -3)   # returns DomainError
area_trapezium(-1, 2, -3)   # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L197-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.area_triangle-Tuple{Any, Any}" href="#TheAlgorithms.area_triangle-Tuple{Any, Any}"><code>TheAlgorithms.area_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_triangle(base, height)</code></pre><p>Finds area of the right angled triangle with base height</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_triangle(10,10) # returns 50.0
area_triangle(-1,-2) # returns DomainError
area_triangle(1,-2)  # returns DomainError
area_triangle(-1,2)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L115-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.atbash_encode-Tuple{Any}" href="#TheAlgorithms.atbash_encode-Tuple{Any}"><code>TheAlgorithms.atbash_encode</code></a> — <span class="docstring-category">Method</span></header><section><div><p>encode(input)</p><p>Program to implement atbash cipher for the given sentence.A full description of the algorithm can be found on <a href="https://en.wikipedia.org/wiki/Atbash">wikipedia</a></p><p><strong>Arguments:</strong></p><ul><li><code>input</code> : The sentence needed to rotate</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; atbash_encode(&quot;test&quot;)
gvhg

julia&gt; atbash_encode(&quot;abcdefghijklmnopqrstuvwxyz&quot;)
zyxwvutsrqponmlkjihgfedcba

julia&gt; atbash_encode(&quot;hello&quot;)
svool
</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">
for r in input
    part *= xform(r)
    if length(part) &gt;= 5
      push!(parts, part)
      part = &quot;&quot;
    end
  end
  if part != &quot;&quot;
    push!(parts, part)
  end
  return join(parts, &quot; &quot;)
</code></pre><p><strong>References:</strong></p><p>https://en.wikipedia.org/wiki/Atbash</p><p>```</p><p><strong>Contributed by:- <a href="https://github.com/Ihjass">Ihjass Thasbekha</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/cipher/atbash.jl#L1-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.bab_sqrt-Tuple{Real}" href="#TheAlgorithms.bab_sqrt-Tuple{Real}"><code>TheAlgorithms.bab_sqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bab_sqrt(S::Real; tolerance = 1e-6, guess = nothing)</code></pre><p>The Babylonian Method of calculating a square root is a simple iterative method to determine square roots. A full description of the algorithm can be found on <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method">Wikipedia</a></p><p><strong>Arguments:</strong></p><ul><li><code>S</code>: The number to calculate the square root for.</li></ul><p><strong>Positional Arguments</strong></p><ul><li><code>tolerance</code>: How close the square of the square root needs to be from the input value. <code>abs(S - xn^2) &lt; tolerance</code></li><li><code>guess</code>: The initial value to use for <code>xn</code></li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; bab_sqrt(100)
10.000000000107445

julia&gt; bab_sqrt(100, guess = 15)
10.000000000131072

julia&gt; bab_sqrt(π, guess = 1)
1.7724538555800293

julia&gt; bab_sqrt(π, guess = 1, tolerance = 2)
2.0707963267948966</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">while tolerance &lt;= abs(xn^2 - S)
    xn = (1 / 2) * (xn + S / xn)
end</code></pre><p><strong>References:</strong></p><p><a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method">Methods of computing square roots</a></p><p>```</p><p><strong>Contributed by:- <a href="https://ansonbiggs.com">Anson Biggs</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/babylonian_sqrt.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.bellman_ford" href="#TheAlgorithms.bellman_ford"><code>TheAlgorithms.bellman_ford</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bellman_ford(graph::Vector{Tuple{Int, Int, Int}}, source::Int)</code></pre><p>The Bellman-Ford algorithm is an algorithm which computes the shortest paths from a single source vertex to all other vertices in a weighted graph. It is slower than Dijkstra&#39;s algorithm, which solves the same problem, but it is capable of handling graphs with negative edge weights. Instead of greedily performing the relaxation on the vertices, Bellman-Ford simply relaxes all edges, and does this |V|-1 times.</p><p><strong>Arguments:</strong></p><ul><li><code>graph</code>: a directed, weighted graph</li><li><code>source</code>: the source vertex from which to begin the traversal</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">graph = [
    (1, 2, 4), (1, 3, 2),
    (2, 3, 3), (2, 4, 2), (2, 5, 3),
    (3, 2, 1), (3, 4, 4), (3, 5, 5),
    (5, 4, -5)
]
bellman_ford(graph, 1)

# output

5-element Vector{Int64}:
 0
 3
 2
 1
 6</code></pre><p>Contributed by: <a href="https://github.com/ybrenning">Yannick Brenning</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/graph/bellman_ford.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.bfs" href="#TheAlgorithms.bfs"><code>TheAlgorithms.bfs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bfs(graph:Vector{Vector{Int}}, source::Int = 1)</code></pre><p>Depth-first search is an algorithm for traversing or searching tree or graph data structures.  The algorithm starts at a given vertex and explores all vertices at the present depth before moving to the next &quot;level&quot;. This implementation is for educational purposes only, so it simply prints out the vertices in the order that they were traversed.</p><p><strong>Arguments:</strong></p><ul><li><code>graph</code>: a directed, unweighted graph</li><li><code>source</code>: the source vertex from which to begin the traversal</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">graph = [
    [2, 3, 6], 
    [3, 4],
    [4],
    [1, 2, 5],
    [2],
    [1, 5]
]
bfs(graph, 4)

# output

4 1 2 5 3 6</code></pre><p>Contributed by: <a href="https://github.com/ybrenning">Yannick Brenning</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/graph/bfs.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.binary_search-Tuple{Any, Any}" href="#TheAlgorithms.binary_search-Tuple{Any, Any}"><code>TheAlgorithms.binary_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">binary_search(list, query; rev=false, lt=&lt;, by=identity)</code></pre><p>Implement a binary search algorithm. Searching a sorted collection is a common task. A dictionary is a sorted list of word definitions. Given a word, one can find its definition. A telephone book is a sorted list of people&#39;s names, addresses, and telephone numbers. Knowing someone&#39;s name allows one to quickly find their telephone number and address.</p><p>If the list to be searched contains more than a few items (a dozen, say) a binary search will require far fewer comparisons than a linear search, but it imposes the requirement that the list be sorted.</p><p>In computer science, a binary search or half-interval search algorithm finds the position of a specified input value (the search &quot;key&quot;) within an array sorted by key value.</p><p>In each step, the algorithm compares the search key value with the key value of the middle element of the array.</p><p>If the keys match, then a matching element has been found and the range of indices that equal the search key value are returned.</p><p>Otherwise, if the search key is less than the middle element&#39;s key, then the algorithm repeats its action on the sub-array to the left of the middle element or, if the search key is greater, on the sub-array to the right.</p><p>If the remaining array to be searched is empty, then the key cannot be found in the array and a special &quot;not found&quot; indication is returned. Search methods in Julia typically return an empty range located at the insertion point in this case.</p><p>A binary search halves the number of items to check with each iteration, so locating an item (or determining its absence) takes logarithmic time. A binary search is a dichotomic divide and conquer search algorithm.</p><p>Bonus task: Implement keyword arguments by, lt and rev so that by specifies a transformation applied to all elements of the list, lt specifies a comparison and rev specifies if the list is ordered in reverse.</p><p>Contributed By:- <a href="https://github.com/uncomfyhalomacro">Soc Virnyl Estela</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/searches/binary_search.jl#L6-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.binary_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real" href="#TheAlgorithms.binary_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real"><code>TheAlgorithms.binary_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">binary_search(arr::AbstractArray{T,1}, l::T, r::T, x::T) where {T&lt;:Real}</code></pre><p>The implementation of this binary Search is recursive and requires O(Log n) space. With iterative Binary Search, we need only O(1) space. Useful for the implementation of <code>exponential_search</code>.</p><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ash</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/searches/binary_search.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.caesar-Tuple{Any, Any}" href="#TheAlgorithms.caesar-Tuple{Any, Any}"><code>TheAlgorithms.caesar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">caesar(rot, s)</code></pre><p>Program to implement rotational cipher for the given sentence. A full description of the algorithm can be found on <a href="https://en.wikipedia.org/wiki/Caesar_cipher">wikipedia</a></p><p><strong>Arguments:</strong></p><ul><li><code>rot</code>: The number of rotations needed.</li><li><code>s</code> : The sentence needed to rotate</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; caesar(13,&quot;abcdefghijklmnopqrstuvwxyz&quot;)
nopqrstuvwxyzabcdefghijklm

julia&gt; caesar(5,&quot;omg&quot;)
trl

julia&gt; caesar(0,&quot;hello&quot;)
hello
</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">
if r &gt;= &#39;a&#39; &amp;&amp; r &lt;= &#39;z&#39;
    v = ((r - &#39;a&#39;) + rot) % 26
    return v + &#39;a&#39;
end
if r &gt;= &#39;A&#39; &amp;&amp; r &lt;= &#39;Z&#39;
    v = ((r - &#39;A&#39;) + rot) % 26
    return v + &#39;A&#39;
end
return r
</code></pre><p><strong>References:</strong></p><p>https://en.wikipedia.org/wiki/Caesar_cipher</p><p>```</p><p><strong>Contributed by:- <a href="https://github.com/Ihjass">Ihjass Thasbekha</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/cipher/caesar.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.ceil_val-Tuple{Any}" href="#TheAlgorithms.ceil_val-Tuple{Any}"><code>TheAlgorithms.ceil_val</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ceil_val(x)</code></pre><p>Finds the ceiling of x as an functionInteger</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ceil_val(1.3)   # 2.0
ceil_val(2.0)   # returns 2.0
ceil_val(-1.5)  #returns -1.0</code></pre><p><strong>Reference</strong></p><ul><li>https://en.wikipedia.org/wiki/Floor<em>and</em>ceiling_functions</li></ul><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/ceil_floor.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.celsius_to_fahrenheit" href="#TheAlgorithms.celsius_to_fahrenheit"><code>TheAlgorithms.celsius_to_fahrenheit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>celsius<em>to</em>fahrenheit(celsius, ndigits::Int = 2)</p><p>Converts celsius to fahrenheit and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">celsius_to_fahrenheit(273.354, 3) == 524.037  # returns true
celsius_to_fahrenheit(273.354, 0) == 524.0    # returns true
celsius_to_fahrenheit(-40.0) == -40.0         # returns true
celsius_to_fahrenheit(-20.0) == -4.0          # returns true
celsius_to_fahrenheit(0) == 32.0              # returns true
celsius_to_fahrenheit(20) == 68.0             # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/conversions/temparature_conversion.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.celsius_to_kelvin" href="#TheAlgorithms.celsius_to_kelvin"><code>TheAlgorithms.celsius_to_kelvin</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function celsius<em>to</em>kelvin(celsius, ndigits::Int = 2)</p><p>Converts celsius to kelvin and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">celsius_to_kelvin(273.354, 3) == 546.504    # returns true
celsius_to_kelvin(273.354, 0) == 547.0      # returns true
celsius_to_kelvin(0.0) == 273.15            # returns true
celsius_to_kelvin(20.0) == 293.15           # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/conversions/temparature_conversion.jl#L21-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.coin_change-Tuple{Vector{Int64}, Int64}" href="#TheAlgorithms.coin_change-Tuple{Vector{Int64}, Int64}"><code>TheAlgorithms.coin_change</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coin_change(coins::Vector{Int}, amount::Int)</code></pre><p>Given a vector <code>coins</code> of coin values, calculates the minimum number of coins that sums to <code>amount</code>. It&#39;s considered that a unlimited number of coins for each value is available.</p><p><strong>Arguments:</strong></p><ul><li><code>coins</code>: the coins values available</li><li><code>amount</code>: the total amount that need to be summed to</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n_coins, coins = coin_change([1, 3, 4, 7], 13);

julia&gt; n_coins
3

julia&gt; coins
3-element Vector{Int64}:
 3
 3
 7

julia&gt; n_coins, coins = coin_change([2, 4, 6], 23)
(-1, Int64[])

julia&gt; n_coins
-1

julia&gt; coins
Int64[]</code></pre><p><strong>Contributors:</strong></p><ul><li><a href="https://github.com/gosoares">Gabriel Soares</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/dynamic_programming/coin_change.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}" href="#TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.complete_pack!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This does complete/infinite (each item can be chosen infinite times) knapsack : pack capacity = capacity weight of each item = weights value of each item = values dp array is what the function works on It returns the ans (dp[capacity])</p><pre><code class="nohighlight hljs">julia&gt; dp=zeros(Int,30)
julia&gt; complete_pack!(20,[1,2,9],[1,3,20],dp)
43</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/knapsack/dynamic_programming.jl#L32-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}" href="#TheAlgorithms.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.complete_pack!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This does complete/infinite (each item can be chosen infinite times) knapsack : pack capacity = capacity weight of each item = weights value of each item = values</p><p>Each loop the function will find the highest value in the array and check if the capacity is enough to store it, if enough then  the value will be added into the total<em>max</em>value until the capacity cannot hold the weight of the highest current value.  After that the highest current value will be deleted.</p><pre><code class="nohighlight hljs">julia&gt; complete_pack!(20,[1,2,9],[1,3,20])
43</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/knapsack/greedy_algorithm.jl#L36-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.count_nucleotides-Tuple{AbstractString}" href="#TheAlgorithms.count_nucleotides-Tuple{AbstractString}"><code>TheAlgorithms.count_nucleotides</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_nucleotides(s::AbstractString)</code></pre><p>Given: A DNA string s</p><p>of length at most 1000 nt.</p><p>Return: Four integers (separated by spaces) counting the respective number of times that the symbols &#39;A&#39;, &#39;C&#39;, &#39;G&#39;, and &#39;T&#39; occur in s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/project-rosalind/count_nucleotide.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.counting_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Int64}, Tuple{Vector{T}, Int64, Int64}} where T" href="#TheAlgorithms.counting_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Int64}, Tuple{Vector{T}, Int64, Int64}} where T"><code>TheAlgorithms.counting_sort!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Counting Sort</strong></p><p>OVERVIEW: Counting Sort is a sorting algorithm that sort elements within a specific range. The sorting technique is to count the existing element and stored its occurrence time in a new list, then only print it out.</p><p>STEPS:  Assume the input as –&gt; x=[-3, 1, -5, 0, -3]   minimum = -5</p><ul><li><p>STEP 1: Create a list size within the range, in this case is -5 –&gt; 1 which have range of 7 (-5, -4, -3, -2, -1, 0, 1), so list with size 7 and assign all to 0 is created</p></li><li><p>STEP 2: Count the occurances of element in the list          First number = -3 it is the third number in the range, so count[3]+=1         Final view:         index : ( 1,  2,  3,  4,  5, 6, 7)         range : (-5, -4, -3, -2, -1, 0, 1)         count : [ 1,  0,  2,  0,  0, 1, 1] &lt;– the list will store this occurrence</p></li><li><p>STEP 3: Make the count list accumulate the occurances          The final count is (1, 1, 3, 3, 3, 4, 5)</p></li><li><p>STEP 4: Assign the elements in x into correct possition by creating a new list (will call &#39;output&#39; in this sample)         the 1st element in &#39;x&#39; is -3, it is third in range, so it will call the index of 3 in &#39;count&#39;, which is 3 and assign the -3 in to 3rd position in &#39;output&#39;,          then the third element in range will deduct by 1, so the next repeated element will get the correct position, new &#39;count&#39; –&gt; [1, 1, 2, 3, 3, 4, 5]</p><pre><code class="nohighlight hljs">    the 2nd element in &#39;x&#39; is  1, it is last  in range, so it will call the index of 7 in &#39;count&#39;, which is 5 and assign the  1 in to 5th position in &#39;output&#39;, 
    new &#39;count&#39; --&gt; [1, 1, 2, 3, 3, 4, 4]
    ......
    ......
    *If you want the order of original array to have the same order as the output array use can change this to decremental for loop</code></pre></li><li><p>STEP 5: Assign the &#39;output&#39; list back to &#39;x&#39;</p></li></ul><p>FINAL RESULT –&gt;  [-5, -3, -3, 0, 1]                                                                                    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/sorts/counting_sort.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.detect_anagrams-Tuple{Any, Any}" href="#TheAlgorithms.detect_anagrams-Tuple{Any, Any}"><code>TheAlgorithms.detect_anagrams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">detect_anagrams(subject, candidates)</code></pre><p>A function that checks if a list of words is an <a href="https://en.wikipedia.org/wiki/Anagram">Anagram</a> or not of a subject word.</p><p>is the original word = subject is list of words to be compared if they are an anagram of <code>subject</code> = candidates</p><pre><code class="nohighlight hljs">julia&gt; subject = &quot;listen&quot;
julia&gt; candidates = [&quot;inlets&quot;, &quot;enlists&quot;, &quot;google&quot;, &quot;banana&quot;]
julia&gt; detect_anagrams(subject, candidates)
1-element Vector{String}:
 &quot;inlets&quot;</code></pre><p>Contributed By:- <a href="https://github.com/ReneganRonin">Soc V. E.</a> Based on my exercism&#39;s Julia track problem solution on <a href="https://exercism.io/my/solutions/0a1d39faa5694624b7750be3ebf6c974">Anagrams</a>.</p><p>Instructions:</p><p>An anagram is a rearrangement of letters to form a new word. Given a word and a list of candidates, select the sublist of anagrams of the given word. Given &quot;listen&quot; and a list of candidates like &quot;enlists&quot; &quot;google&quot; &quot;inlets&quot; &quot;banana&quot; the program should return a list containing &quot;inlets&quot;.</p><p>Inspired by the <a href="https://github.com/rchatley/extreme_startup">Extreme Startup game</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/strings/detect_anagrams.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.determinant-Tuple{Any}" href="#TheAlgorithms.determinant-Tuple{Any}"><code>TheAlgorithms.determinant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">determinant(mat)</code></pre><p>Given a non singluar matrix, calculate its determinant using LU decomposition.</p><p>L and U are lower triangular and upper triangular matrices respectively such that</p><p>A = L*U</p><p>If we want to find the determinant, then</p><p>det(A) = det(LU) = det(L)*det(U)</p><p>Determinant of triangualar matrices is the product of their diagonal entries. Hence, makes finding the determinant easy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/matrix/determinant.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.dfs" href="#TheAlgorithms.dfs"><code>TheAlgorithms.dfs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dfs(graph::Vector{Vector{Int}}, source::Int)</code></pre><p>Depth-first search is an algorithm for traversing or searching tree or graph data structures.  The algorithm starts at a given vertex and explores as far as possible along each branch before backtracking. This implementation is for educational purposes only, so it simply prints out the vertices in the order that they were traversed.</p><p><strong>Arguments:</strong></p><ul><li><code>graph</code>: a directed, unweighted graph</li><li><code>source</code>: the source vertex from which to begin the traversal</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">graph = [
    [2, 3, 6], 
    [3, 4],
    [4],
    [1, 2, 5],
    [2],
    [1, 5]
]
dfs(graph, 6)

# output

6 5 2 4 3 1</code></pre><p>Contributed by: <a href="https://github.com/ybrenning">Yannick Brenning</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/graph/dfs.jl#L3-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.dijkstra-Tuple{Vector{Vector{Tuple{Int64, Int64}}}, Int64}" href="#TheAlgorithms.dijkstra-Tuple{Vector{Vector{Tuple{Int64, Int64}}}, Int64}"><code>TheAlgorithms.dijkstra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dijkstra(graph::Vector{Vector{Tuple{Int,Int}}}, source::Int)</code></pre><p>Given a directed graph with weights on the arcs and a source vertex, the dijkstra algorithm calculates the distance from the source to all other vertices, and the solution tree associated with those distances. The solution tree is given by a vector <code>prev</code> which stores the source of the arc that arrives at each vertex. By definition: distance[source] = prev[source] = 0. If a vertex v is not reachable from the source, then distance[v] = prev[v] = -1.</p><p><strong>Arguments:</strong></p><ul><li><code>graph</code>: a directed graph with weights on the arcs</li><li><code>source</code>: the source vertex from which the distances will be calculated</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">graph = [
    [(2, 8), (3, 6), (4, 4)],
    [(3, 1), (5, 5)],
    [(5, 4)],
    [(2, 3), (5, 9)],
    [(1, 2), (3, 2), (4, 5)],
    [(1, 1), (4, 3)],
]
distances, prev = dijkstra(graph, 1)

println(&quot;v | dist | path&quot;)
for v in eachindex(graph)
    distance = distances[v] == -1 ? &quot;  NR&quot; : lpad(distances[v], 4) # NR: Non Reachable
    path = join(get_dijkstra_path(prev, v), &quot; -&gt; &quot;)
    println(&quot;$v | $distance | $path&quot;)
end

# output

v | dist | path
1 |    0 | 1
2 |    7 | 1 -&gt; 4 -&gt; 2
3 |    6 | 1 -&gt; 3
4 |    4 | 1 -&gt; 4
5 |   10 | 1 -&gt; 3 -&gt; 5
6 |   NR | </code></pre><p>Contributed By: <a href="https://github.com/gosoares">Gabriel Soares</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/graph/dijkstra.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.dna2rna-Tuple{AbstractString}" href="#TheAlgorithms.dna2rna-Tuple{AbstractString}"><code>TheAlgorithms.dna2rna</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dna2rna(s::AbstractString)</code></pre><p>Given: A DNA string t</p><p>having length at most 1000 nt.</p><p>Return: The transcribed RNA string of t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/project-rosalind/dna2rna.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.eratosthenes-Tuple{Any}" href="#TheAlgorithms.eratosthenes-Tuple{Any}"><code>TheAlgorithms.eratosthenes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sieve of Eratosthenes is an algorithm for finding all the primes upto a limit <code>n</code>.</p><p>Reference: -https://en.wikipedia.org/wiki/Sieve<em>of</em>Eratosthenes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/sieve_of_eratosthenes.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.euler_method" href="#TheAlgorithms.euler_method"><code>TheAlgorithms.euler_method</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">euler_method(f, x0, span, h=1.0e-2)</code></pre><p>Calculate the solution to a differential equation using forward euler method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/euler_method.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.exponential_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:Real" href="#TheAlgorithms.exponential_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:Real"><code>TheAlgorithms.exponential_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> exponential_search(arr::AbstractArray{T,1}, x::T) where {T &lt;: Real}</code></pre><p>Exponential Search in 1-D array Time Complexity:  O(Log n)</p><p><strong>Exponential Search</strong></p><p>It works in O(Log n) time Exponential search involves two steps:</p><ul><li>Find range where element is present</li><li>Do Binary Search in above found range.</li></ul><p><strong>Time Complexity :</strong></p><p>O(Log n) Applications of Exponential Search: Exponential Binary Search is particularly useful for unbounded searches, where size of array is infinite. Please refer Unbounded Binary Search for an example. It works better than Binary Search for bounded arrays, and also when the element to be searched is closer to the first element.</p><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ash</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/searches/exponential_search.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.factorial_iterative-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.factorial_iterative-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.factorial_iterative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factorial_iterative(n)</code></pre><p>Finds factorial of a number using Iterative method</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">factorial_iterative(5)      # returns 120
factorial_iterative(-1)     # returns error</code></pre><p><strong>Reference</strong></p><ul><li>factorial of a positive integer – https://en.wikipedia.org/wiki/Factorial</li></ul><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/factorial.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.factorial_recursive-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.factorial_recursive-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.factorial_recursive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factorial_recursive(n)</code></pre><p>Finds factorial of a number using recursive method</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">factorial_recursive(5)      # returns 120</code></pre><p><strong>Reference</strong></p><ul><li>factorial of a positive integer – https://en.wikipedia.org/wiki/Factorial</li></ul><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/factorial.jl#L35-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.fahrenheit_to_celsius" href="#TheAlgorithms.fahrenheit_to_celsius"><code>TheAlgorithms.fahrenheit_to_celsius</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fahrenheit<em>to</em>celsius(fahrenheit, ndigits::Int = 2)</p><p>Converts fahrenheit to celsius and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">fahrenheit_to_celsius(273.354, 3) == 134.086 # returns true
fahrenheit_to_celsius(273.354, 0) == 134.0   # returns true
fahrenheit_to_celsius(0.0) == -17.78         # returns true
fahrenheit_to_celsius(20.0) == -6.67         # returns true
fahrenheit_to_celsius(40.0) == 4.44          # returns true
fahrenheit_to_celsius(60.0) == 15.56         # returns true
fahrenheit_to_celsius(80.0) == 26.67         # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/conversions/temparature_conversion.jl#L40-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.fahrenheit_to_kelvin" href="#TheAlgorithms.fahrenheit_to_kelvin"><code>TheAlgorithms.fahrenheit_to_kelvin</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fahrenheit<em>to</em>kelvin(fahrenheit, ndigits::Int = 2)</p><p>Converts fahrenheit to kelvin and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">fahrenheit_to_kelvin(273.354, 3) == 407.236 # returns true
fahrenheit_to_kelvin(273.354, 0) == 407.0   # returns true
fahrenheit_to_kelvin(0) == 255.37           # returns true
fahrenheit_to_kelvin(20.0) == 266.48        # returns true
fahrenheit_to_kelvin(40.0) == 277.59        # returns true
fahrenheit_to_kelvin(60.0) == 288.71        # returns true
fahrenheit_to_kelvin(80.0) == 299.82        # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/conversions/temparature_conversion.jl#L61-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.fcfs-Tuple{Any, Any, Any}" href="#TheAlgorithms.fcfs-Tuple{Any, Any, Any}"><code>TheAlgorithms.fcfs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fcfs(n, process_id, burst_time)</code></pre><p>Implementation of first come first served scheduling algorithm</p><p><strong>Output</strong></p><p>Tuple of vectors (process<em>id, burst</em>time, waiting<em>time, turnaround</em>time, avg<em>waiting</em>time, avg<em>turnaround</em>time)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">n = 3 # number of processes
process_id = Any[1, 2, 3] # process ids
burst_times = Any[3, 4, 5] # burst times
fcfs(n, process_id, burst_times)</code></pre><p><strong>Reference</strong></p><p>https://en.wikipedia.org/wiki/Scheduling<em>(computing)#First</em>come,<em>first</em>served</p><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/scheduling/fcfs.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.find-Tuple{DisjointSet, Int64}" href="#TheAlgorithms.find-Tuple{DisjointSet, Int64}"><code>TheAlgorithms.find</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the ancestor of node <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/data_structures/disjoint_set/disjoint_set.jl#L13-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.floor_val-Tuple{Any}" href="#TheAlgorithms.floor_val-Tuple{Any}"><code>TheAlgorithms.floor_val</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floor_val(x)</code></pre><p>Finds the floor of x as an Integer</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">floor_val(1.3)  # 1
floor_val(2.0)  # returns 2.0
floor_val(-1.7) # returns -2.0</code></pre><p><strong>Reference</strong></p><ul><li>https://en.wikipedia.org/wiki/Floor<em>and</em>ceiling_functions</li></ul><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/ceil_floor.jl#L20-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.gauss_jordan-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number" href="#TheAlgorithms.gauss_jordan-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.gauss_jordan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gauss_jordan(A::AbstractMatrix{T}) where T&lt;:Number</code></pre><p>Gaussian elimination, also known as row reduction, is an algorithm for solving systems of linear equations.  It consists of a sequence of operations performed on the corresponding matrix of coefficients.  This method can also be used to compute the rank of a matrix, the determinant of a square matrix, and the inverse of an invertible matrix. https://en.wikipedia.org/wiki/Gaussian_elimination</p><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; M1 = [1 2 3; 4 5 6];
julia&gt; M2 = [1 2 3; 4 8 12];

julia&gt; @test gauss_jordan(M1) == [1 0 -1; 0 1 2]        # Test Passed
julia&gt; @test_throws AssertionError gauss_jordan(M2)     # Test Passed - Thrown: AssertionError</code></pre><p><strong>Contributed By:- <a href="https://github.com/AugustoCL">AugustoCL</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/matrix/gauss_jordan_elim.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.get_dijkstra_path-Tuple{Vector{Int64}, Int64}" href="#TheAlgorithms.get_dijkstra_path-Tuple{Vector{Int64}, Int64}"><code>TheAlgorithms.get_dijkstra_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_dijkstra_path(tree::Vector{Int}, dest::Int)</code></pre><p>Given a solution <code>tree</code> from the <a href="#TheAlgorithms.dijkstra-Tuple{Vector{Vector{Tuple{Int64, Int64}}}, Int64}"><code>dijkstra</code></a> algorithm, extract the path from the source to <code>dest</code>, including them.</p><p><strong>Arguments:</strong></p><ul><li><code>tree</code>: solution tree from the <a href="#TheAlgorithms.dijkstra-Tuple{Vector{Vector{Tuple{Int64, Int64}}}, Int64}"><code>dijkstra</code></a> algorithm</li><li><code>dest</code>: path&#39;s destionation vertex</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/graph/dijkstra.jl#L81-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.heap_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Any}, Tuple{Vector{T}, Any, Int64}} where T" href="#TheAlgorithms.heap_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Any}, Tuple{Vector{T}, Any, Int64}} where T"><code>TheAlgorithms.heap_sort!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heap_sort!(arr::Vector{T}, gt = &gt;, N::Int = length(arr)) where {T}</code></pre><p>Sort the given vector (in-place) using the Heapsort algorithm.</p><p>Heapsort consists of two stages:</p><ol><li>Building a (max) heap of the array</li><li>Repeatedly extracting the largest element and inserting it at the front of the sorted part of the array</li></ol><p>After the largest element has been extracted, the tree is updated to maintain the heap property via a &quot;sifting&quot; operation.</p><p>Storing a heap in an array is pretty straightforward - for every node with index n, its children are stored at indices   2n + 1 and 2n + 2 (for 0-based indices). Index 0 contains the root node.   Since Julia&#39;s indices are 1-based, we need to change this a little bit. We&#39;re using a trivial helper function    idx_for to convert from 0-based to 1-based.</p><p>See https://en.wikipedia.org/wiki/Heapsort for a complete explanation of Heapsort.</p><p>Contributed By:- <a href="https://github.com/frankschmitt">Frank Schmitt</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/sorts/heap_sort.jl#L10-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.idx_for-Tuple{Int64}" href="#TheAlgorithms.idx_for-Tuple{Int64}"><code>TheAlgorithms.idx_for</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">idx_for(i::Int)</code></pre><p>Simple helper function for converting 0-based indices to Julia&#39;s 1-based indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/sorts/heap_sort.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.interpolation_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real" href="#TheAlgorithms.interpolation_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real"><code>TheAlgorithms.interpolation_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> interpolation_search(arr::AbstractArray{T,1}, l::T, r::T, x::T) where {T &lt;: Real}</code></pre><p>Interpolation Search in 1-D array Time Complexity: O(log2(log2 n))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/searches/interpolation_search.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.is_armstrong-Tuple{Any}" href="#TheAlgorithms.is_armstrong-Tuple{Any}"><code>TheAlgorithms.is_armstrong</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_armstrong(x)</code></pre><p>Program to check if a number is an <a href="https://en.wikipedia.org/wiki/Narcissistic_number">Armstrong/Narcissistic number</a> in decimal system.</p><p>Armstrong number is a number that is the sum of its own digits raised to the power of the number of digits.</p><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p><p>A positive integer is called an Armstrong number (of order n) if</p><p><code>abcd... = a^n + b^n + c^n + d^n +....</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/armstrong_number.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.isbefore-Union{Tuple{T}, Tuple{MinHeap{T}, T, T}} where T" href="#TheAlgorithms.isbefore-Union{Tuple{T}, Tuple{MinHeap{T}, T, T}} where T"><code>TheAlgorithms.isbefore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isbefore(heap, x, y)</code></pre><p>Whether <code>x</code> comes before <code>y</code> in the <code>heap</code> ordering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/data_structures/binary_heap.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.ispangram-Tuple{Any}" href="#TheAlgorithms.ispangram-Tuple{Any}"><code>TheAlgorithms.ispangram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ispangram(input)</p><p>Program to determine the sentence is pangram or not.The program will return true if it is pangram and false if it is not.A full description of the algorithm can be found on <a href="https://exercism.org/tracks/julia/exercises/pangram">exercism</a></p><p><strong>Arguments:</strong></p><ul><li><code>input</code>: The sentence to find if its pangram or not.</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; ispangram(Pack my box with five dozen liquor jugs)
true

julia&gt; ispangram(The quick brown fox jumps over the lazy dog)
true

julia&gt; wordcount(hello world!!!)
false
</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">
for letter in input
    if &#39;A&#39; &lt;= letter &lt;= &#39;Z&#39;
        x &amp;= ~(1&lt;&lt;(letter-&#39;A&#39;))
    elseif &#39;a&#39; &lt;= letter &lt;= &#39;z&#39;
        x &amp;= ~(1&lt;&lt;(letter-&#39;a&#39;))
    end
    x == 0 &amp;&amp; return true
end
</code></pre><p><strong>References:</strong></p><p>(https://exercism.org/tracks/julia/exercises/pangram)</p><p>```</p><p><strong>Contributed by:- <a href="https://github.com/Ihjass">Ihjass Thasbekha</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/strings/pangram.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.jump_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:Real" href="#TheAlgorithms.jump_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:Real"><code>TheAlgorithms.jump_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jump_search(arr::AbstractArray{T,1}, x::T, jump::T = Int(ceil(sqrt(n)))) where {T &lt;: Real}</code></pre><p>Jump Search in 1-D array Time Complexity :  O(√ n) Time complexity of Jump Search is between Linear Search ( ( O(n) ) and Binary Search ( O (Log n) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/searches/jump_search.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.kelvin_to_celsius" href="#TheAlgorithms.kelvin_to_celsius"><code>TheAlgorithms.kelvin_to_celsius</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function kelvin<em>to</em>celsius(kelvin, ndigits::Int = 2)</p><p>Converts kelvin to celsius and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">kelvin_to_celsius(273.354, 3) == 0.204   # returns true
kelvin_to_celsius(273.354, 0) == 0.0     # returns true
kelvin_to_celsius(273.15) == 0.0         # returns true
kelvin_to_celsius(300) == 26.85          # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/conversions/temparature_conversion.jl#L85-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.kelvin_to_fahrenheit" href="#TheAlgorithms.kelvin_to_fahrenheit"><code>TheAlgorithms.kelvin_to_fahrenheit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function kelvin<em>to</em>fahrenheit(kelvin, ndigits::Int = 2)</p><p>Converts kelvin to fahrenheit and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">kelvin_to_fahrenheit(273.354, 3) == 32.367  # returns true
kelvin_to_fahrenheit(273.354, 0) == 32.0    # returns true
kelvin_to_fahrenheit(273.15) == 32.0        # returns true
kelvin_to_fahrenheit(300) == 80.33          # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/conversions/temparature_conversion.jl#L103-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.krishnamurthy-Tuple{Any}" href="#TheAlgorithms.krishnamurthy-Tuple{Any}"><code>TheAlgorithms.krishnamurthy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">krishnamurthy(number)</code></pre><p>Check if a number is a Krishnamurthy number or not</p><p><strong>Details</strong></p><p>It is also known as Peterson Number. </p><p>A Krishnamurthy Number is a number whose sum of the factorial of the digits equals to the original number itself.</p><p>For example: 145 = 1! + 4! + 5!     So, 145 is a Krishnamurthy Number</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">krishnamurthy(145) # returns true
krishnamurthy(240) # returns false
krishnamurthy(1)   # returns true </code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/krishnamurthy_number.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.line_length" href="#TheAlgorithms.line_length"><code>TheAlgorithms.line_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">line_length(f, x_start, x_end, steps=100)</code></pre><p>Approximates the arc length of a line segment by treating the curve as a sequence of linear lines and summing their lengths.</p><p>Arguments:</p><ul><li>f: function that returns the arc</li><li>x_start: starting x value</li><li>x<em>end: ending x</em>value</li><li>steps: steps to take for accurace, more the steps greater the accuracy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/line_length.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.linear_search-Tuple{Any, Any}" href="#TheAlgorithms.linear_search-Tuple{Any, Any}"><code>TheAlgorithms.linear_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linear_search(array, key)</code></pre><p>A simple search of <code>array</code>, element per element until <code>key</code> is found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/searches/linear_search.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.lu_decompose-Tuple{Any}" href="#TheAlgorithms.lu_decompose-Tuple{Any}"><code>TheAlgorithms.lu_decompose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lu_decompose(mat)</code></pre><p>Decomposes a <code>n x n</code> non singular matrix into a lower triangular matrix (L) and an upper triangular matrix (U)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/matrix/lu_decompose.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.mean-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#TheAlgorithms.mean-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean(nums)</code></pre><p>Find mean of a vector of numbers</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mean([3, 6, 9, 12, 15, 18, 21])      # returns 12.0
mean([5, 10, 15, 20, 25, 30, 35])    # returns 20.0
mean([1, 2, 3, 4, 5, 6, 7, 8])       # returns 4.5</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/average_mean.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.median-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#TheAlgorithms.median-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.median</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">median(nums)</code></pre><p>Finds median of a vector of numbers</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">median([2,1,3,4])                   # returns 2.5
median([2, 70, 6, 50, 20, 8, 4])    # returns 8
median([0])                         # returns 0</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/average_median.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.mode-Tuple{Any}" href="#TheAlgorithms.mode-Tuple{Any}"><code>TheAlgorithms.mode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mode(nums)</code></pre><p>Finds mode of a vector of numbers</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mode([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2])        # returns [2]
mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2])        # returns [2]
mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2])  # returns [2, 4]
mode([&quot;x&quot;, &quot;y&quot;, &quot;y&quot;, &quot;z&quot;])                              # returns [&quot;y&quot;]
mode([&quot;x&quot;, &quot;x&quot; , &quot;y&quot;, &quot;y&quot;, &quot;z&quot;])                       # returns [&quot;x&quot;, &quot;y&quot;]</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/average_mode.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.monte_carlo_integration-Tuple{Function, Real, Real, Int64}" href="#TheAlgorithms.monte_carlo_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.monte_carlo_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">monte_carlo_integration(f::Function, a::Real, b::Real, n::Int)</code></pre><p>Monte carlo integration is a very easy and scalable way to do multidimentional integrals. However, only single variable integrals are considered.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: the function to integrate. (at the momment only single variable is suported)</li><li><code>a</code>: start in the integration limits.</li><li><code>b</code>: endin the integration limits.</li><li><code>N</code>: Number of points to sample. For most simple functions, 1000 to 10,000 should be okay.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; monte_carlo_integration(x -&gt; 3*x^2, 0, 1, 100000) # integrate a polynomial
1.0000037602209

julia&gt; monte_carlo_integration(x -&gt; sin(x), 0, pi, 1000) # integrate the sin function
2.0018927826323756</code></pre><p><strong>References</strong></p><ul><li>https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration</li><li>https://kingaa.github.io/sbied/pfilter/monteCarlo.html</li></ul><p><strong>Contributors</strong></p><ul><li><a href="https://github.com/AugustoCL">AugustoCL</a></li><li><a href="https://github.com/Ved-Mahajan">Ved Mahajan</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/monte_carlo_integration.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.partitions_recursive-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.partitions_recursive-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.partitions_recursive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partitions_recursive(n)</code></pre><p>Finds partitions of an integer using recursion.</p><p>A partition of a positive integer n, also called an integer partition, is a way of writing n as a sum of positive integers.</p><p>There are 7 partitions of 5: 5 4 + 1 3 + 2 3 + 1 + 1 2 + 2 + 1 2 + 1 + 1 + 1 1 + 1 + 1 + 1 + 1</p><p>Partitions of n is equal to the sum of partitions of n with k parts.</p><p><span>$P \left ( n \right ) = \sum_{k=1}^{n} P_{k} \left ( n \right )$</span></p><p>Partitions of n with k parts is the sum of partitions of n-1 with k-1 parts and, partitions of n-k with k parts.</p><p><span>$P_{k}\left ( n \right ) =  P_{k-1}\left ( n - 1 \right ) + P_{k}\left ( n - k \right )$</span></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">partitions_recursive(0)      # returns 1
partitions_recursive(1)      # returns 1
partitions_recursive(10)     # returns 42
partitions_recursive(-1)     # returns DomainError</code></pre><p><strong>References</strong></p><ul><li>Partitions of a positive integer – https://en.wikipedia.org/wiki/Partition<em>function</em>(number_theory)</li><li>Partitions of a positive integer – https://www.whitman.edu/mathematics/cgt_online/book/section03.03.html</li></ul><p><strong>Contributor</strong></p><ul><li><a href="https://github.com/Whiteshark-314">Vaishakh C R</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/partitions.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.perfect_cube-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.perfect_cube-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.perfect_cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perfect_cube(number)</code></pre><p>Check if a number is a perfect cube or not.</p><p><strong>Example</strong></p><pre><code class="language-jula hljs">perfect_cube(27) # returns true
perfect_cube(4)  # returns false</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/perfect_cube.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.perfect_number-Tuple{N} where N&lt;:Number" href="#TheAlgorithms.perfect_number-Tuple{N} where N&lt;:Number"><code>TheAlgorithms.perfect_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perfect_number(number)</code></pre><p>Checks if a number is a perfect_number number or not</p><p><strong>Details</strong></p><p>perfect_number number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself.</p><p>For example : 6 is perfect_number number</p><p>Divisors of 6 =&gt; [1,2,3]</p><p>Sum of divisors =&gt; 1+2+3 = 6</p><p>6 == sum(divisors) # which is true</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">perfect_number(27)     # returns false
perfect_number(28)     # returns true
perfect_number(496)    # returns true
perfect_number(8128)   # returns true
perfect_number(123)    # returns false</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/perfect_number.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.perfect_square-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.perfect_square-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.perfect_square</code></a> — <span class="docstring-category">Method</span></header><section><div><p>perfect_square(number)</p><p>Check if a number is a perfect square or not.</p><p><strong>Example</strong></p><pre><code class="language-jula hljs">perfect_square(9)   # returns True
perfect_square(16)  # returns True
perfect_square(1)   # returns True
perfect_square(0)   # returns True
perfect_square(10)  # returns False
perfect_square(-9)  # returns False</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/perfect_square.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.prime_check-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.prime_check-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.prime_check</code></a> — <span class="docstring-category">Method</span></header><section><div><p>prime_check(number)</p><p>Checks to see if a number is a prime or not</p><p>A number is prime if it has exactly two factors: 1 and itself.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">prime_check(2) # returns true
prime_check(3) # returns true
prime_check(5) # returns true
prime_check(7) # returns true
prime_check(11) # returns true
prime_check(13) # returns true
prime_check(17) # returns true
prime_check(19) # returns true
prime_check(23) # returns true
prime_check(29) # returns true
prime_check(30) # returns false</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/prime_check.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.prime_factors-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.prime_factors-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.prime_factors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>prime_factors(number)</p><p>Returns prime factors of <code>number</code> as a vector</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">prime_factors(50)          # returns [2,5,5]
prime_factors(0)           # returns []
prime_factors(100)         # returns [2, 2, 5, 5]
prime_factors(2560)        # returns [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/prime_factors.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.rabin_karp-Tuple{String, String}" href="#TheAlgorithms.rabin_karp-Tuple{String, String}"><code>TheAlgorithms.rabin_karp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rabin_karp(text, pattern)</code></pre><p><strong>Brief:</strong></p><pre><code class="nohighlight hljs">A function that finds all occurrences of a pattern in the given text.
Instead of checking each character ot the pattern with each character block of the text,
for each character block calculate the hash value, and only if that value matches hash value of the pattern,
compare them character by character. These blocks are the same length as the pattern.</code></pre><p><strong>Returns:</strong></p><pre><code class="nohighlight hljs">A list with starting indices where the pattern was found</code></pre><p><strong>References:</strong></p><pre><code class="nohighlight hljs">https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/</code></pre><p><strong>Contributed by: <a href="https://github.com/Nikola-Mircic">Nikola Mircic</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/strings/rabin_karp.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.riemann_integration" href="#TheAlgorithms.riemann_integration"><code>TheAlgorithms.riemann_integration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">riemann_integration(f::Function, a::Real, b::Real, n::Int, approx::Symbol = :midpoint)</code></pre><p>a Riemann sum is a certain kind of approximation of an integral by a finite sum. The sum is calculated by partitioning the region into shapes (rectangles, trapezoids, parabolas, or cubics) that together form a region that is similar to the region being measured, then calculating the area for each of these shapes, and finally adding all of these small areas together.</p><p>Because the region filled by the small shapes is usually not exactly the same shape as the region being measured, the Riemann sum will differ from the area being measured.  This error can be reduced by dividing up the region more finely, using smaller and smaller shapes.  As the shapes get smaller and smaller, the sum approaches the Riemann integral.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: the function to integrate. (at the momment only single variable is suported)</li><li><code>a</code>: Start of the integration limit.</li><li><code>b</code>: End of the integration limit.</li><li><code>n</code>: Number of points to sample. (as n increase, error decrease)</li><li><code>approx</code>: Indicate the method of approximation (midpoint, left or right)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; riemann_integration(x -&gt; x, 1, 3, 1_000, :midpoint)  # 4.0
julia&gt; riemann_integration(x -&gt; x, 1, 3, 1_000, :left)      # 3.997997997997998
julia&gt; riemann_integration(x -&gt; x, 1, 3, 1_000, :right)     # 4.002002002002002
julia&gt; riemann_integration(x -&gt; 3*x^2, 0, 1, 100000)        # integrate a polynomial
0.9999999999750021
julia&gt; riemann_integration(x -&gt; sin(x), 0, pi, 1000)          # integrate the sin function
2.0000008241146774</code></pre><p><strong>Refereces</strong></p><ul><li>https://www.khanacademy.org/math/ap-calculus-ab/ab-integration-new/ab-6-2/a/riemann-sums-review</li><li>https://math.libretexts.org/Courses/Mount<em>Royal</em>University/MATH<em>2200%3A</em>Calculus<em>for</em>Scientists<em>II/2%3A</em>Techniques<em>of</em>Integration/2.5%3A<em>Numerical</em>Integration<em>-</em>Midpoint%2C<em>Trapezoid%2C</em>Simpson&#39;s_rule</li><li>https://abel.math.harvard.edu/~knill/teaching/math1a_2011/handouts/40-numerical.pdf</li><li>https://en.wikipedia.org/wiki/Riemann_integral</li></ul><p>Contributed By:- <a href="https://github.com/AugustoCL">AugustoCL</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/riemann_integration.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.rotation_matrix-Tuple{Any}" href="#TheAlgorithms.rotation_matrix-Tuple{Any}"><code>TheAlgorithms.rotation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A 2D Rotation matrix is a mtrix that rotates a vector in a 2D real space by an angle theta. For more info: https://en.wikipedia.org/wiki/Rotation_matrix</p><p>This function takes the angle <code>theta</code> in radians as input and returns a 2D Matrix which will rotate the vector by angle <code>theta</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/matrix/rotation-matrix.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.simpsons_integration-Tuple{Function, Real, Real, Int64}" href="#TheAlgorithms.simpsons_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.simpsons_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simpsons_integration(f::Function, a::Real, b::Real, n::Int)</code></pre><p>Simpson&#39;s rule uses a quadratic polynomial on each subinterval of a partition to approximate the function f(x) and to compute the definite integral.  This is an improvement over the trapezoid rule which approximates f(x) by a straight line on each subinterval of a partition. For more details of the method, check the link in the reference.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The function to integrate. (ar the moment only single variable is suported)</li><li><code>a</code>: Start of the integration limit.</li><li><code>b</code>: End of the integration limit.</li><li><code>n</code>: Number of points to sample. (as n increase, error decrease)</li></ul><p><strong>Examples/Test</strong></p><pre><code class="language-julia hljs"># aproximate pi with f(x) = 4 / (1 + x^2)
julia&gt; simpsons_integration(x -&gt; 4 / (1 + x^2), 0, 1, 100_000)
3.1415926535897936
julia&gt; simpsons_integration(x -&gt; 4 / (1 + x^2), 0, 1, 100_000) ≈ pi
true</code></pre><p><strong>References:</strong></p><ul><li>https://personal.math.ubc.ca/~pwalls/math-python/integration/simpsons-rule/</li></ul><p><strong>Contributed By:- <a href="https://github.com/AugustoCL">AugustoCL</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/simpsons_integration.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.sum_ap-Tuple{Any, Any, Any}" href="#TheAlgorithms.sum_ap-Tuple{Any, Any, Any}"><code>TheAlgorithms.sum_ap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum_ap(first_term, diff, num_terms)</code></pre><p>Finds sum of a arithmetic progression series</p><p><strong>Input parameters</strong></p><ul><li>first_term : first term of the series</li><li>diff       : common difference between consecutive terms</li><li>num_terms  : number of terms in the series till which we count sum</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sum_ap(1, 1, 10)    # returns 55.0 
sum_ap(1, 10, 100)  # returns 49600.0</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/sum_of_arithmetic_series.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.sum_gp-Tuple{Any, Any, Any}" href="#TheAlgorithms.sum_gp-Tuple{Any, Any, Any}"><code>TheAlgorithms.sum_gp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum_gp(first_term, ratio, num_terms)</code></pre><p>Finds sum of n terms in a geometric progression</p><p><strong>Input parameters</strong></p><ul><li>first_term : first term of the series</li><li>raio      : common ratio between consecutive terms -&gt; a2/a1 or a3/a2 or a4/a3</li><li>num_terms  : number of terms in the series till which we count sum</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sum_gp(1, 2, 10)    # 1023.0
sum_gp(1, 10, 5)    # 11111.0
sum_gp(0, 2, 10)    # 0.0
sum_gp(1, 0, 10)    # 1.0
sum_gp(1, 2, 0)     # -0.0
sum_gp(-1, 2, 10)   # -1023.0
sum_gp(1, -2, 10)   # -341.0</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/sum_of_geometric_progression.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.surfarea_cube-Tuple{Any}" href="#TheAlgorithms.surfarea_cube-Tuple{Any}"><code>TheAlgorithms.surfarea_cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surfarea_cube(side)</code></pre><p>Finds surface area of a cube</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">surfarea_cube(1)  # returns 6
surfarea_cube(3)  # returns 54
surfarea_cube(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L4-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.surfarea_cuboid-Tuple{Any, Any, Any}" href="#TheAlgorithms.surfarea_cuboid-Tuple{Any, Any, Any}"><code>TheAlgorithms.surfarea_cuboid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surfarea_cuboid(length, width, height)</code></pre><p>Finds surface area of a cuboid</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">surfarea_cuboid(5, 5, 5)  # returns 150
surfarea_cuboid(-5, -5, -5)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L29-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.surfarea_sphere-Tuple{Any}" href="#TheAlgorithms.surfarea_sphere-Tuple{Any}"><code>TheAlgorithms.surfarea_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surfarea_sphere(side)</code></pre><p>Finds surface area of a sphere</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">surfarea_sphere(5)  # returns 314.1592653589793
surfarea_sphere(1)  # returns 12.566370614359172
surfarea_sphere(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L48-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.trapazoidal_area-NTuple{4, Any}" href="#TheAlgorithms.trapazoidal_area-NTuple{4, Any}"><code>TheAlgorithms.trapazoidal_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trapazoidal_area(f, x_start, x_end, steps)</code></pre><p>Approximates the area under the curve using the trapezoidal rule Arguments:</p><ul><li>f: function for the</li><li>x_start: starting value for x</li><li>x_end: ending value for x</li><li>steps: steps taken while integrating.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/area.jl#L284-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.trapezoid_integration-Tuple{Function, Real, Real, Int64}" href="#TheAlgorithms.trapezoid_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.trapezoid_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trapezoid_integration(f::Function, a::Real, b::Real, n::Int)</code></pre><p>The trapezoidal rule works by approximating the region under the graph of the function f(x) as a trapezoid and calculating its area.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: the function to integrate. (at the momment only single variable is suported)</li><li><code>a</code>: Start of the integration limit.</li><li><code>b</code>: End of the integration limit.</li><li><code>n</code>: Number of points to sample. (as n increase, error decrease)</li></ul><p><strong>Examples/Test</strong></p><pre><code class="language-julia hljs">julia&gt; trapezoid_integration(x -&gt; 4 / (1 + x^2), 0, 1, 100_000)
3.1415926535731526
julia&gt; trapezoid_integration(x -&gt; 4 / (1 + x^2), 0, 1, 100_000) ≈ pi
true</code></pre><p><strong>References:</strong></p><p>-https://personal.math.ubc.ca/~pwalls/math-python/integration/trapezoid-rule/ -https://en.wikipedia.org/wiki/Trapezoidal_rule</p><p><strong>Contributed By:- <a href="https://github.com/AugustoCL">AugustoCL</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/trapezoid_integration.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.variance-Tuple{Any}" href="#TheAlgorithms.variance-Tuple{Any}"><code>TheAlgorithms.variance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variance(a)</code></pre><p>Find the variance from a set of data.</p><p><strong>Arguments:</strong></p><ul><li><code>a</code>: holds the set of data</li></ul><p><strong>Reference</strong></p><pre><code class="nohighlight hljs">- According to Ronald E. Walpole, `variance` is used to measure the variability of a set of data. -- Introduction to Statistics by Ronald E. Walpole</code></pre><p><strong>Contributors:</strong></p><ul><li><a href="https://github.com/arubhardwaj">Aru Bhardwaj</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/statistics/variance.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.verlet_integration" href="#TheAlgorithms.verlet_integration"><code>TheAlgorithms.verlet_integration</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Verlet integration is an integration method used to integrate newtons - law of motion. It is frequently used to find trajectories in molecular dynamics simulation. The function takes <code>four</code> inputs viz,</p><ul><li><code>f</code> : the differential equation</li><li><code>x0</code> : the initial condition. This is a Vector with the first element as initial value for position (x<em>0) and the second initial condition for velocity (v</em>0) </li><li><code>tspan</code>: is the time span for integration. It is a tuple (initial time, final time)</li></ul><p>This functionr returns a tuple (x,t):</p><ul><li><code>x</code> is the solution</li><li><code>t</code> is the array containing the time points</li></ul><p>Reference:</p><ul><li>https://www.algorithm-archive.org/contents/verlet<em>integration/verlet</em>integration.html</li></ul><p>Contributed by: <a href="https://github.com/Ved-Mahajan">Ved Mahajan</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/verlet.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_circular_cylinder-Tuple{Any, Any}" href="#TheAlgorithms.vol_circular_cylinder-Tuple{Any, Any}"><code>TheAlgorithms.vol_circular_cylinder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_circular_cylinder(area_of_, height)</code></pre><p>Compute the Volume of a Circular Cylinder.</p><p><strong>Examples</strong></p><p>```julia-repl julia&gt; vol<em>circular</em>cylinder(1, 1) 3.141592653589793 julia&gt; vol<em>circular</em>cylinder(4, 3) 150.79644737231007</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/volume.jl#L156-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_cone-Tuple{Any, Any}" href="#TheAlgorithms.vol_cone-Tuple{Any, Any}"><code>TheAlgorithms.vol_cone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_cone(area_of_base, height)</code></pre><p>Compute the Volume of a Cone</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_cone(10, 3)
10.0
julia&gt; vol_cone(1, 1)
0.3333333333333333</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/volume.jl#L49-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_cube-Tuple{Any}" href="#TheAlgorithms.vol_cube-Tuple{Any}"><code>TheAlgorithms.vol_cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_cube()</code></pre><p>Compute the volume of a cube.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_cube(1)
1
julia&gt; vol_cube(3)
27
julia&gt; vol_cube(-1)
DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/volume.jl#L5-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_cuboid-Tuple{Any, Any, Any}" href="#TheAlgorithms.vol_cuboid-Tuple{Any, Any, Any}"><code>TheAlgorithms.vol_cuboid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_cuboid(width, height, length)</code></pre><p>Compute the volume of a vol_cuboid</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_cuboid(1, 1, 1)
1
julia&gt; vol_cuboid(1, 2, 3)
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/volume.jl#L28-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_prism-Tuple{Any, Any}" href="#TheAlgorithms.vol_prism-Tuple{Any, Any}"><code>TheAlgorithms.vol_prism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_prism(area_of_base, height)</code></pre><p>Compute the Volume of a Prism.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_prism(10, 2)
20.0
julia&gt; vol_prism(11, 1)
11.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/volume.jl#L94-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_pyramid-Tuple{Any, Any}" href="#TheAlgorithms.vol_pyramid-Tuple{Any, Any}"><code>TheAlgorithms.vol_pyramid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_pyramid(area_of_base, height)</code></pre><p>Compute the volume of a Pyramid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_pyramid(10, 3)
10.0
julia&gt; vol_pyramid(1.5, 3)
1.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/volume.jl#L115-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_right_circ_cone-Tuple{Any, Any}" href="#TheAlgorithms.vol_right_circ_cone-Tuple{Any, Any}"><code>TheAlgorithms.vol_right_circ_cone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_right_circ_cone(radius, height)</code></pre><p>Compute the Volume of a Right Circular Cone.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_right_circ_cone(2, 3)
12.566370614359172</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/volume.jl#L71-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.vol_sphere-Tuple{Any}" href="#TheAlgorithms.vol_sphere-Tuple{Any}"><code>TheAlgorithms.vol_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_sphere(radius)</code></pre><p>Compute the volume of a sphere.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">vol_sphere(5)  # returns 523.5987755982989
vol_sphere(1)  # returns 4.1887902047863905
vol_sphere(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/math/volume.jl#L136-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.word_count-Tuple{Any}" href="#TheAlgorithms.word_count-Tuple{Any}"><code>TheAlgorithms.word_count</code></a> — <span class="docstring-category">Method</span></header><section><div><p>wordcount(sentence)</p><p>Program to find word count in the given sentence. The program will return count with the word. A full description of the algorithm can be found on <a href="https://exercism.org/tracks/julia/exercises/word-count">exercism</a></p><p><strong>Arguments:</strong></p><ul><li><code>sentence</code>: The sentence to find the word count.</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; wordcount(The quick brown fox jumps over the lazy dog)
Dict{Any, Any}(&quot;jumps&quot; =&gt; 1, &quot;the&quot; =&gt; 2, &quot;brown&quot; =&gt; 1, &quot;over&quot; =&gt; 1, &quot;quick&quot; =&gt; 1, &quot;lazy&quot; =&gt; 1, &quot;dog&quot; =&gt; 1, &quot;fox&quot; =&gt; 1)

julia&gt; wordcount(the sky is blue and beautiful)
Dict{Any, Any}(&quot;and&quot; =&gt; 1, &quot;the&quot; =&gt; 1, &quot;sky&quot; =&gt; 1, &quot;blue&quot; =&gt; 1, &quot;is&quot; =&gt; 1, &quot;beautiful&quot; =&gt; 1)
</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">
for word in eachmatch(reg_expression, sentence)
    if !haskey(counts, word.match)
        counts[word.match] = 1
    else
        counts[word.match] += 1
    end
end
</code></pre><p><strong>References:</strong></p><p>(https://exercism.org/tracks/julia/exercises/word-count)</p><p>```</p><p><strong>Contributed by:- <a href="https://github.com/Ihjass">Ihjass Thasbekha</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/strings/word_count.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}" href="#TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.zero_one_pack!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_one_pack!(capacity::N, weights::V, values::V, dp::V) where {N &lt;: Number,V &lt;: AbstractVector}</code></pre><p>This does 0-1 (each item can be chosen only once) knapsack : pack capacity = capacity weight of each item = weights value of each item = values dp array is what the function works on It returns the ans (dp[capacity])</p><pre><code class="nohighlight hljs">julia&gt; dp=zeros(Int,30)
julia&gt; zero_one_pack!(20,[1,3,11],[2,5,30],dp)
37</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/knapsack/dynamic_programming.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}" href="#TheAlgorithms.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.zero_one_pack!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For greedy algorithm, it will take the element based on the optimal value in the array at each loop in the function</p><p>This does 0-1 (each item can be chosen only once) knapsack : pack capacity = capacity weight of each item = weights value of each item = values</p><p>Each loop the function will find the highest value in the array and check if the capacity is enough to store it, if enough then  the value will be added into the total<em>max</em>value.  After that the highest current value will be deleted.</p><pre><code class="nohighlight hljs">julia&gt; zero_one_pack!(20,[1,3,11],[2,5,30])
37</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/cb013fff2d65229105ebc5163b20f13387431ee6/src/knapsack/greedy_algorithm.jl#L1-L17">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 21 September 2022 14:57">Wednesday 21 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
