<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TheAlgorithms.jl</title><meta name="title" content="Home · TheAlgorithms.jl"/><meta property="og:title" content="Home · TheAlgorithms.jl"/><meta property="twitter:title" content="Home · TheAlgorithms.jl"/><meta name="description" content="Documentation for TheAlgorithms.jl."/><meta property="og:description" content="Documentation for TheAlgorithms.jl."/><meta property="twitter:description" content="Documentation for TheAlgorithms.jl."/><meta property="og:url" content="https://TheAlgorithms.github.io/Julia/"/><meta property="twitter:url" content="https://TheAlgorithms.github.io/Julia/"/><link rel="canonical" href="https://TheAlgorithms.github.io/Julia/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TheAlgorithms.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TheAlgorithms/Julia/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="TheAlgorithms"><a class="docs-heading-anchor" href="#TheAlgorithms">TheAlgorithms</a><a id="TheAlgorithms-1"></a><a class="docs-heading-anchor-permalink" href="#TheAlgorithms" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/TheAlgorithms/Julia">TheAlgorithms</a>.</p><ul><li><a href="#TheAlgorithms.Basic"><code>TheAlgorithms.Basic</code></a></li><li><a href="#TheAlgorithms.Basic.DifferenceArray"><code>TheAlgorithms.Basic.DifferenceArray</code></a></li><li><a href="#TheAlgorithms.Cipher"><code>TheAlgorithms.Cipher</code></a></li><li><a href="#TheAlgorithms.Conversions"><code>TheAlgorithms.Conversions</code></a></li><li><a href="#TheAlgorithms.DataStructure"><code>TheAlgorithms.DataStructure</code></a></li><li><a href="#TheAlgorithms.DataStructure.LinkedList"><code>TheAlgorithms.DataStructure.LinkedList</code></a></li><li><a href="#TheAlgorithms.DynamicProgramming"><code>TheAlgorithms.DynamicProgramming</code></a></li><li><a href="#TheAlgorithms.Graph"><code>TheAlgorithms.Graph</code></a></li><li><a href="#TheAlgorithms.LongSubSeq"><code>TheAlgorithms.LongSubSeq</code></a></li><li><a href="#TheAlgorithms.Math"><code>TheAlgorithms.Math</code></a></li><li><a href="#TheAlgorithms.MatrixAlgo"><code>TheAlgorithms.MatrixAlgo</code></a></li><li><a href="#TheAlgorithms.ProjectEuler"><code>TheAlgorithms.ProjectEuler</code></a></li><li><a href="#TheAlgorithms.ProjectRosalind"><code>TheAlgorithms.ProjectRosalind</code></a></li><li><a href="#TheAlgorithms.Scheduling"><code>TheAlgorithms.Scheduling</code></a></li><li><a href="#TheAlgorithms.Searches"><code>TheAlgorithms.Searches</code></a></li><li><a href="#TheAlgorithms.Sorts"><code>TheAlgorithms.Sorts</code></a></li><li><a href="#TheAlgorithms.StatAlgo"><code>TheAlgorithms.StatAlgo</code></a></li><li><a href="#TheAlgorithms.StringAlgo"><code>TheAlgorithms.StringAlgo</code></a></li><li><a href="#TheAlgorithms.DataStructure.AbstractBinarySearchTree_arr"><code>TheAlgorithms.DataStructure.AbstractBinarySearchTree_arr</code></a></li><li><a href="#TheAlgorithms.DataStructure.AbstractBinaryTree_arr"><code>TheAlgorithms.DataStructure.AbstractBinaryTree_arr</code></a></li><li><a href="#TheAlgorithms.DataStructure.BinaryHeap"><code>TheAlgorithms.DataStructure.BinaryHeap</code></a></li><li><a href="#TheAlgorithms.DataStructure.DisjointSet"><code>TheAlgorithms.DataStructure.DisjointSet</code></a></li><li><a href="#TheAlgorithms.Cipher.affine-Tuple{String, String, Int64, Int64}"><code>TheAlgorithms.Cipher.affine</code></a></li><li><a href="#TheAlgorithms.Cipher.atbash_encode-Tuple{Any}"><code>TheAlgorithms.Cipher.atbash_encode</code></a></li><li><a href="#TheAlgorithms.Cipher.caesar-Tuple{Any, Any}"><code>TheAlgorithms.Cipher.caesar</code></a></li><li><a href="#TheAlgorithms.Cipher.decrypt_vigenere-Tuple{String, String}"><code>TheAlgorithms.Cipher.decrypt_vigenere</code></a></li><li><a href="#TheAlgorithms.Cipher.encrypt_vigenere-Tuple{String, String}"><code>TheAlgorithms.Cipher.encrypt_vigenere</code></a></li><li><a href="#TheAlgorithms.Conversions.celsius_to_fahrenheit"><code>TheAlgorithms.Conversions.celsius_to_fahrenheit</code></a></li><li><a href="#TheAlgorithms.Conversions.celsius_to_kelvin"><code>TheAlgorithms.Conversions.celsius_to_kelvin</code></a></li><li><a href="#TheAlgorithms.Conversions.fahrenheit_to_celsius"><code>TheAlgorithms.Conversions.fahrenheit_to_celsius</code></a></li><li><a href="#TheAlgorithms.Conversions.fahrenheit_to_kelvin"><code>TheAlgorithms.Conversions.fahrenheit_to_kelvin</code></a></li><li><a href="#TheAlgorithms.Conversions.kelvin_to_celsius"><code>TheAlgorithms.Conversions.kelvin_to_celsius</code></a></li><li><a href="#TheAlgorithms.Conversions.kelvin_to_fahrenheit"><code>TheAlgorithms.Conversions.kelvin_to_fahrenheit</code></a></li><li><a href="#TheAlgorithms.DataStructure.FenwickTree.change-Union{Tuple{T}, Tuple{Array{T}, Integer, Integer}} where T&lt;:Number"><code>TheAlgorithms.DataStructure.FenwickTree.change</code></a></li><li><a href="#TheAlgorithms.DataStructure.FenwickTree.create_tree-Union{Tuple{Array{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.DataStructure.FenwickTree.create_tree</code></a></li><li><a href="#TheAlgorithms.DataStructure.FenwickTree.get_sum-Union{Tuple{T}, Tuple{Array{T}, Integer}} where T&lt;:Number"><code>TheAlgorithms.DataStructure.FenwickTree.get_sum</code></a></li><li><a href="#TheAlgorithms.DataStructure.FenwickTree.to_arr-Union{Tuple{Array{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.DataStructure.FenwickTree.to_arr</code></a></li><li><a href="#TheAlgorithms.DataStructure.find-Tuple{TheAlgorithms.DataStructure.DisjointSet, Int64}"><code>TheAlgorithms.DataStructure.find</code></a></li><li><a href="#TheAlgorithms.DataStructure.isbefore-Union{Tuple{T}, Tuple{TheAlgorithms.DataStructure.MinHeap{T}, T, T}} where T"><code>TheAlgorithms.DataStructure.isbefore</code></a></li><li><a href="#TheAlgorithms.DynamicProgramming.coin_change-Tuple{Vector{Int64}, Int64}"><code>TheAlgorithms.DynamicProgramming.coin_change</code></a></li><li><a href="#TheAlgorithms.Graph.bellman_ford"><code>TheAlgorithms.Graph.bellman_ford</code></a></li><li><a href="#TheAlgorithms.Graph.bfs"><code>TheAlgorithms.Graph.bfs</code></a></li><li><a href="#TheAlgorithms.Graph.dfs"><code>TheAlgorithms.Graph.dfs</code></a></li><li><a href="#TheAlgorithms.Graph.dijkstra-Tuple{Vector{Vector{Tuple{Int64, Int64}}}, Int64}"><code>TheAlgorithms.Graph.dijkstra</code></a></li><li><a href="#TheAlgorithms.Graph.get_dijkstra_path-Tuple{Vector{Int64}, Int64}"><code>TheAlgorithms.Graph.get_dijkstra_path</code></a></li><li><a href="#TheAlgorithms.KnapSack.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.KnapSack.complete_pack!</code></a></li><li><a href="#TheAlgorithms.KnapSack.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.KnapSack.complete_pack!</code></a></li><li><a href="#TheAlgorithms.KnapSack.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.KnapSack.zero_one_pack!</code></a></li><li><a href="#TheAlgorithms.KnapSack.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.KnapSack.zero_one_pack!</code></a></li><li><a href="#TheAlgorithms.Math.abs_max-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real"><code>TheAlgorithms.Math.abs_max</code></a></li><li><a href="#TheAlgorithms.Math.abs_min-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real"><code>TheAlgorithms.Math.abs_min</code></a></li><li><a href="#TheAlgorithms.Math.abs_val-Tuple{N} where N&lt;:Real"><code>TheAlgorithms.Math.abs_val</code></a></li><li><a href="#TheAlgorithms.Math.aliquot_sum-Tuple{Int64}"><code>TheAlgorithms.Math.aliquot_sum</code></a></li><li><a href="#TheAlgorithms.Math.amicable_pairs-Tuple{Int64}"><code>TheAlgorithms.Math.amicable_pairs</code></a></li><li><a href="#TheAlgorithms.Math.area_circle-Tuple{Any}"><code>TheAlgorithms.Math.area_circle</code></a></li><li><a href="#TheAlgorithms.Math.area_ellipse-Tuple{Any, Any}"><code>TheAlgorithms.Math.area_ellipse</code></a></li><li><a href="#TheAlgorithms.Math.area_heron_triangle-Tuple{Any, Any, Any}"><code>TheAlgorithms.Math.area_heron_triangle</code></a></li><li><a href="#TheAlgorithms.Math.area_parallelogram-Tuple{Any, Any}"><code>TheAlgorithms.Math.area_parallelogram</code></a></li><li><a href="#TheAlgorithms.Math.area_polygon-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>TheAlgorithms.Math.area_polygon</code></a></li><li><a href="#TheAlgorithms.Math.area_rectangle-Tuple{Any, Any}"><code>TheAlgorithms.Math.area_rectangle</code></a></li><li><a href="#TheAlgorithms.Math.area_regular_polygon-Tuple{Any, Any}"><code>TheAlgorithms.Math.area_regular_polygon</code></a></li><li><a href="#TheAlgorithms.Math.area_rhombus-Tuple{Any, Any}"><code>TheAlgorithms.Math.area_rhombus</code></a></li><li><a href="#TheAlgorithms.Math.area_square-Tuple{Any}"><code>TheAlgorithms.Math.area_square</code></a></li><li><a href="#TheAlgorithms.Math.area_trapezium-Tuple{Any, Any, Any}"><code>TheAlgorithms.Math.area_trapezium</code></a></li><li><a href="#TheAlgorithms.Math.area_triangle-Tuple{Any, Any}"><code>TheAlgorithms.Math.area_triangle</code></a></li><li><a href="#TheAlgorithms.Math.average_absolute_deviation-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.Math.average_absolute_deviation</code></a></li><li><a href="#TheAlgorithms.Math.bab_sqrt-Tuple{Real}"><code>TheAlgorithms.Math.bab_sqrt</code></a></li><li><a href="#TheAlgorithms.Math.catalan-Tuple{Int64}"><code>TheAlgorithms.Math.catalan</code></a></li><li><a href="#TheAlgorithms.Math.ceil-Tuple{Any}"><code>TheAlgorithms.Math.ceil</code></a></li><li><a href="#TheAlgorithms.Math.divisors-Tuple{Int64}"><code>TheAlgorithms.Math.divisors</code></a></li><li><a href="#TheAlgorithms.Math.eratosthenes-Tuple{Any}"><code>TheAlgorithms.Math.eratosthenes</code></a></li><li><a href="#TheAlgorithms.Math.euler_method"><code>TheAlgorithms.Math.euler_method</code></a></li><li><a href="#TheAlgorithms.Math.factorial_iterative-Tuple{Integer}"><code>TheAlgorithms.Math.factorial_iterative</code></a></li><li><a href="#TheAlgorithms.Math.factorial_recursive-Tuple{Integer}"><code>TheAlgorithms.Math.factorial_recursive</code></a></li><li><a href="#TheAlgorithms.Math.fib_iterative-Tuple{Int64}"><code>TheAlgorithms.Math.fib_iterative</code></a></li><li><a href="#TheAlgorithms.Math.fib_recursive-Tuple{Int64}"><code>TheAlgorithms.Math.fib_recursive</code></a></li><li><a href="#TheAlgorithms.Math.fib_recursive_memo-Tuple{Int64}"><code>TheAlgorithms.Math.fib_recursive_memo</code></a></li><li><a href="#TheAlgorithms.Math.floor-Tuple{Any}"><code>TheAlgorithms.Math.floor</code></a></li><li><a href="#TheAlgorithms.Math.get_mersenne_primes-Tuple{Int64}"><code>TheAlgorithms.Math.get_mersenne_primes</code></a></li><li><a href="#TheAlgorithms.Math.is_armstrong-Tuple{Any}"><code>TheAlgorithms.Math.is_armstrong</code></a></li><li><a href="#TheAlgorithms.Math.is_mersenne_prime-Tuple{Int64}"><code>TheAlgorithms.Math.is_mersenne_prime</code></a></li><li><a href="#TheAlgorithms.Math.krishnamurthy-Tuple{Any}"><code>TheAlgorithms.Math.krishnamurthy</code></a></li><li><a href="#TheAlgorithms.Math.line_length"><code>TheAlgorithms.Math.line_length</code></a></li><li><a href="#TheAlgorithms.Math.mean-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.Math.mean</code></a></li><li><a href="#TheAlgorithms.Math.median-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.Math.median</code></a></li><li><a href="#TheAlgorithms.Math.mode-Tuple{Any}"><code>TheAlgorithms.Math.mode</code></a></li><li><a href="#TheAlgorithms.Math.monte_carlo_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.Math.monte_carlo_integration</code></a></li><li><a href="#TheAlgorithms.Math.num_divisors-Tuple{Int64}"><code>TheAlgorithms.Math.num_divisors</code></a></li><li><a href="#TheAlgorithms.Math.partitions_recursive-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.Math.partitions_recursive</code></a></li><li><a href="#TheAlgorithms.Math.perfect_cube-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.Math.perfect_cube</code></a></li><li><a href="#TheAlgorithms.Math.perfect_number-Tuple{N} where N&lt;:Number"><code>TheAlgorithms.Math.perfect_number</code></a></li><li><a href="#TheAlgorithms.Math.perfect_square-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.Math.perfect_square</code></a></li><li><a href="#TheAlgorithms.Math.prime_check-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.Math.prime_check</code></a></li><li><a href="#TheAlgorithms.Math.prime_factors-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.Math.prime_factors</code></a></li><li><a href="#TheAlgorithms.Math.riemann_integration"><code>TheAlgorithms.Math.riemann_integration</code></a></li><li><a href="#TheAlgorithms.Math.simpsons_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.Math.simpsons_integration</code></a></li><li><a href="#TheAlgorithms.Math.sum_ap-Tuple{Any, Any, Any}"><code>TheAlgorithms.Math.sum_ap</code></a></li><li><a href="#TheAlgorithms.Math.sum_divisors-Tuple{Int64}"><code>TheAlgorithms.Math.sum_divisors</code></a></li><li><a href="#TheAlgorithms.Math.sum_gp-Tuple{Any, Any, Any}"><code>TheAlgorithms.Math.sum_gp</code></a></li><li><a href="#TheAlgorithms.Math.surfarea_cube-Tuple{Any}"><code>TheAlgorithms.Math.surfarea_cube</code></a></li><li><a href="#TheAlgorithms.Math.surfarea_cuboid-Tuple{Any, Any, Any}"><code>TheAlgorithms.Math.surfarea_cuboid</code></a></li><li><a href="#TheAlgorithms.Math.surfarea_sphere-Tuple{Any}"><code>TheAlgorithms.Math.surfarea_sphere</code></a></li><li><a href="#TheAlgorithms.Math.totient-Tuple{Int64}"><code>TheAlgorithms.Math.totient</code></a></li><li><a href="#TheAlgorithms.Math.trapazoidal_area-NTuple{4, Any}"><code>TheAlgorithms.Math.trapazoidal_area</code></a></li><li><a href="#TheAlgorithms.Math.trapezoid_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.Math.trapezoid_integration</code></a></li><li><a href="#TheAlgorithms.Math.verlet_integration"><code>TheAlgorithms.Math.verlet_integration</code></a></li><li><a href="#TheAlgorithms.Math.vol_circular_cylinder-Tuple{Any, Any}"><code>TheAlgorithms.Math.vol_circular_cylinder</code></a></li><li><a href="#TheAlgorithms.Math.vol_cone-Tuple{Any, Any}"><code>TheAlgorithms.Math.vol_cone</code></a></li><li><a href="#TheAlgorithms.Math.vol_cube-Tuple{Any}"><code>TheAlgorithms.Math.vol_cube</code></a></li><li><a href="#TheAlgorithms.Math.vol_cuboid-Tuple{Any, Any, Any}"><code>TheAlgorithms.Math.vol_cuboid</code></a></li><li><a href="#TheAlgorithms.Math.vol_prism-Tuple{Any, Any}"><code>TheAlgorithms.Math.vol_prism</code></a></li><li><a href="#TheAlgorithms.Math.vol_pyramid-Tuple{Any, Any}"><code>TheAlgorithms.Math.vol_pyramid</code></a></li><li><a href="#TheAlgorithms.Math.vol_right_circ_cone-Tuple{Any, Any}"><code>TheAlgorithms.Math.vol_right_circ_cone</code></a></li><li><a href="#TheAlgorithms.Math.vol_sphere-Tuple{Any}"><code>TheAlgorithms.Math.vol_sphere</code></a></li><li><a href="#TheAlgorithms.MatrixAlgo.determinant-Tuple{Any}"><code>TheAlgorithms.MatrixAlgo.determinant</code></a></li><li><a href="#TheAlgorithms.MatrixAlgo.gauss_jordan-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.MatrixAlgo.gauss_jordan</code></a></li><li><a href="#TheAlgorithms.MatrixAlgo.lu_decompose-Tuple{Any}"><code>TheAlgorithms.MatrixAlgo.lu_decompose</code></a></li><li><a href="#TheAlgorithms.MatrixAlgo.rotation_matrix-Tuple{Any}"><code>TheAlgorithms.MatrixAlgo.rotation_matrix</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.aliquot_sum-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.aliquot_sum</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.divisors-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.divisors</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.eratosthenes-Tuple{Any}"><code>TheAlgorithms.ProjectEuler.eratosthenes</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.num_divisors-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.num_divisors</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.problem_001-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_001</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.problem_002-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_002</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.problem_003-Tuple{Number}"><code>TheAlgorithms.ProjectEuler.problem_003</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.problem_004-Tuple{}"><code>TheAlgorithms.ProjectEuler.problem_004</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.problem_005-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_005</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.problem_006-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_006</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.problem_007-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_007</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.problem_008-Tuple{String, Int64}"><code>TheAlgorithms.ProjectEuler.problem_008</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.problem_009-Tuple{}"><code>TheAlgorithms.ProjectEuler.problem_009</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.problem_010-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_010</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.problem_012-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_012</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.problem_013-Tuple{}"><code>TheAlgorithms.ProjectEuler.problem_013</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.problem_014-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_014</code></a></li><li><a href="#TheAlgorithms.ProjectEuler.sum_divisors-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.sum_divisors</code></a></li><li><a href="#TheAlgorithms.ProjectRosalind.count_nucleotides-Tuple{AbstractString}"><code>TheAlgorithms.ProjectRosalind.count_nucleotides</code></a></li><li><a href="#TheAlgorithms.ProjectRosalind.dna2rna-Tuple{AbstractString}"><code>TheAlgorithms.ProjectRosalind.dna2rna</code></a></li><li><a href="#TheAlgorithms.Scheduling.fcfs-Tuple{Any, Any, Any}"><code>TheAlgorithms.Scheduling.fcfs</code></a></li><li><a href="#TheAlgorithms.Searches.binary_search-Tuple{Any, Any}"><code>TheAlgorithms.Searches.binary_search</code></a></li><li><a href="#TheAlgorithms.Searches.binary_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real"><code>TheAlgorithms.Searches.binary_search</code></a></li><li><a href="#TheAlgorithms.Searches.exponential_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:Real"><code>TheAlgorithms.Searches.exponential_search</code></a></li><li><a href="#TheAlgorithms.Searches.interpolation_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real"><code>TheAlgorithms.Searches.interpolation_search</code></a></li><li><a href="#TheAlgorithms.Searches.jump_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:Real"><code>TheAlgorithms.Searches.jump_search</code></a></li><li><a href="#TheAlgorithms.Searches.linear_search-Tuple{Any, Any}"><code>TheAlgorithms.Searches.linear_search</code></a></li><li><a href="#TheAlgorithms.Sorts.counting_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Int64}, Tuple{Vector{T}, Int64, Int64}} where T"><code>TheAlgorithms.Sorts.counting_sort!</code></a></li><li><a href="#TheAlgorithms.Sorts.heap_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Any}, Tuple{Vector{T}, Any, Int64}} where T"><code>TheAlgorithms.Sorts.heap_sort!</code></a></li><li><a href="#TheAlgorithms.Sorts.idx_for-Tuple{Int64}"><code>TheAlgorithms.Sorts.idx_for</code></a></li><li><a href="#TheAlgorithms.StatAlgo.variance-Tuple{Any}"><code>TheAlgorithms.StatAlgo.variance</code></a></li><li><a href="#TheAlgorithms.StringAlgo.detect_anagrams-Tuple{Any, Any}"><code>TheAlgorithms.StringAlgo.detect_anagrams</code></a></li><li><a href="#TheAlgorithms.StringAlgo.ispangram-Tuple{Any}"><code>TheAlgorithms.StringAlgo.ispangram</code></a></li><li><a href="#TheAlgorithms.StringAlgo.rabin_karp-Tuple{String, String}"><code>TheAlgorithms.StringAlgo.rabin_karp</code></a></li><li><a href="#TheAlgorithms.StringAlgo.word_count-Tuple{Any}"><code>TheAlgorithms.StringAlgo.word_count</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Basic" href="#TheAlgorithms.Basic"><code>TheAlgorithms.Basic</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Basic</p><p>Basic algorthims for TheAlgorithms/Julia </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/basic/Basic.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Basic.DifferenceArray" href="#TheAlgorithms.Basic.DifferenceArray"><code>TheAlgorithms.Basic.DifferenceArray</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Difference array</code></pre><p><strong>Brief:</strong></p><pre><code class="nohighlight hljs">For any array A with N numbers, we can create difference array D with N numbers also.
Every k-th element of D is equal to difference between A[k] and A[k-1]
    D[k] = A[k-1] - A[k]</code></pre><p><strong>Complexity of some operations</strong></p><pre><code class="nohighlight hljs">- add some value x to the m consecutive elements of array - O(1)
- print array after any numbers of changes                - O(N)</code></pre><p><strong>Functions</strong></p><pre><code class="nohighlight hljs">- create_diff_arr(original::Array{T}) - Create difference array for array &#39;original&#39;
- calculate_arr(diff_arr::Array{T}) - Create a original array from the given difference array
- add_to_arr(diff_arr::Array{T}, l::Int, r::Int, x::Number) - Add x to all elements with index from [l, r]</code></pre><p><strong>Contributed by: <a href="https://github.com/Nikola-Mircic">Nikola Mircic</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/basic/difference_arr.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Cipher" href="#TheAlgorithms.Cipher"><code>TheAlgorithms.Cipher</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Cipher</p><p><code>Cipher</code> algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/cipher/Cipher.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Cipher.affine-Tuple{String, String, Int64, Int64}" href="#TheAlgorithms.Cipher.affine-Tuple{String, String, Int64, Int64}"><code>TheAlgorithms.Cipher.affine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">affine(text, alphabet, nMultiply, nAdd)</code></pre><p>Program to implement affine cipher for the given input. A full description of it can be found on <a href="https://en.wikipedia.org/wiki/Affine_cipher">wikipedia</a>.</p><p><strong>Arguments:</strong></p><ul><li><code>text</code> : text to be encoded/decoded</li><li><code>alphabet</code> : the alphaebt the text uses</li><li><code>nMultiply</code> : the number to the multiply by (a)</li><li><code>nAdd</code> : the number to add (b)</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">
julia&gt; affine(&quot;abcdefghijklmnopqrstuvwxyz&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;, 3, 1)
&quot;behknqtwzcfiloruxadgjmpsvy&quot;

julia&gt; affine(&quot;whyhellothere&quot;, &quot;abcdefghijklmnopqrstuvwxyz&quot;, 17, 82)
&quot;otwtujjiptuhu&quot;

julia&gt; affine(&quot;1234&quot;, &quot;0123456789&quot;, 5, 2)
&quot;9630&quot;
</code></pre><p><strong>Algorithm:</strong></p><p>As usual, julia&#39;s 1 based indexing doesn&#39;t play nicely with the affine cipher, but all that is required is <code>-1</code> from the initial index of the letter and <code>+1</code> after the mod.  </p><p>An affine cipher uses a simple function: <code>f(x) = ax + b</code>.</p><p>Notes:</p><ul><li><code>nMultiply</code> and <code>length(alphabet)</code> <em>must</em> be coprime so that the two plaintext letters are not substituted for the same cipehrtext letter.</li><li>This doesn&#39;t check that the all of the characters in <code>text</code> actually are in <code>alphabet</code>, but that does need to be the case!</li></ul><pre><code class="language-julia hljs">
join([
    alphabet[((findfirst(isequal(letter), alphabet) - 1) * nMultiply + nAdd) % length(alphabet) + 1]
    for letter in text
])
</code></pre><p><strong>References:</strong></p><p>https://www.dcode.fr/affine-cipher   https://github.com/Squalm/Cipher-Tools</p><p><strong>Contributed by: <a href="https://github.com/Squalm">Chirp (Squalm)</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/cipher/affine.jl#L1-L51">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Cipher.atbash_encode-Tuple{Any}" href="#TheAlgorithms.Cipher.atbash_encode-Tuple{Any}"><code>TheAlgorithms.Cipher.atbash_encode</code></a> — <span class="docstring-category">Method</span></header><section><div><p>encode(input)</p><p>Program to implement atbash cipher for the given sentence.A full description of the algorithm can be found on <a href="https://en.wikipedia.org/wiki/Atbash">wikipedia</a></p><p><strong>Arguments:</strong></p><ul><li><code>input</code> : The sentence needed to rotate</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; atbash_encode(&quot;test&quot;)
gvhg

julia&gt; atbash_encode(&quot;abcdefghijklmnopqrstuvwxyz&quot;)
zyxwvutsrqponmlkjihgfedcba

julia&gt; atbash_encode(&quot;hello&quot;)
svool
</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">
for r in input
    part *= xform(r)
    if length(part) &gt;= 5
      push!(parts, part)
      part = &quot;&quot;
    end
  end
  if part != &quot;&quot;
    push!(parts, part)
  end
  return join(parts, &quot; &quot;)
</code></pre><p><strong>References:</strong></p><p>https://en.wikipedia.org/wiki/Atbash</p><p>```</p><p><strong>Contributed by:- <a href="https://github.com/Ihjass">Ihjass Thasbekha</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/cipher/atbash.jl#L1-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Cipher.caesar-Tuple{Any, Any}" href="#TheAlgorithms.Cipher.caesar-Tuple{Any, Any}"><code>TheAlgorithms.Cipher.caesar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">caesar(rot, s)</code></pre><p>Program to implement rotational cipher for the given sentence. A full description of the algorithm can be found on <a href="https://en.wikipedia.org/wiki/Caesar_cipher">wikipedia</a></p><p><strong>Arguments:</strong></p><ul><li><code>rot</code>: The number of rotations needed.</li><li><code>s</code> : The sentence needed to rotate</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; caesar(13,&quot;abcdefghijklmnopqrstuvwxyz&quot;)
nopqrstuvwxyzabcdefghijklm

julia&gt; caesar(5,&quot;omg&quot;)
trl

julia&gt; caesar(0,&quot;hello&quot;)
hello
</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">
if r &gt;= &#39;a&#39; &amp;&amp; r &lt;= &#39;z&#39;
    v = ((r - &#39;a&#39;) + rot) % 26
    return v + &#39;a&#39;
end
if r &gt;= &#39;A&#39; &amp;&amp; r &lt;= &#39;Z&#39;
    v = ((r - &#39;A&#39;) + rot) % 26
    return v + &#39;A&#39;
end
return r
</code></pre><p><strong>References:</strong></p><p>https://en.wikipedia.org/wiki/Caesar_cipher</p><p>```</p><p><strong>Contributed by:- <a href="https://github.com/Ihjass">Ihjass Thasbekha</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/cipher/caesar.jl#L1-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Cipher.decrypt_vigenere-Tuple{String, String}" href="#TheAlgorithms.Cipher.decrypt_vigenere-Tuple{String, String}"><code>TheAlgorithms.Cipher.decrypt_vigenere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decrypt_vigenere(text, key)</code></pre><p>Decrypts a plaintext message using the Vigenere cipher.</p><p><strong>Arguments</strong></p><ul><li><code>text</code>: the ciphertext message to decrypt</li><li><code>key</code>: the keyword used for decryption</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; decrypt_vigenere(&quot;Rijvs, Uyvjn!&quot;, &quot;key&quot;)
Hello, World!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/cipher/vigenere.jl#L40-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Cipher.encrypt_vigenere-Tuple{String, String}" href="#TheAlgorithms.Cipher.encrypt_vigenere-Tuple{String, String}"><code>TheAlgorithms.Cipher.encrypt_vigenere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">encrypt_vigenere(text, key)</code></pre><p>Encrypts a plaintext message using the Vigenere cipher.</p><p><strong>Arguments</strong></p><ul><li><code>text</code>: the plaintext message to encrypt</li><li><code>key</code>: the keyword used for encryption</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; encrypt_vigenere(&quot;Hello, World!&quot;, &quot;key&quot;)
Rijvs, Uyvjn!</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/cipher/vigenere.jl#L4-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Conversions" href="#TheAlgorithms.Conversions"><code>TheAlgorithms.Conversions</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Conversions</p><p><code>Conversions</code> are conversions of measurements in Julia	</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/conversions/Conversions.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Conversions.celsius_to_fahrenheit" href="#TheAlgorithms.Conversions.celsius_to_fahrenheit"><code>TheAlgorithms.Conversions.celsius_to_fahrenheit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>celsius<em>to</em>fahrenheit(celsius, ndigits::Int = 2)</p><p>Converts celsius to fahrenheit and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">celsius_to_fahrenheit(273.354, 3) == 524.037  # returns true
celsius_to_fahrenheit(273.354, 0) == 524.0    # returns true
celsius_to_fahrenheit(-40.0) == -40.0         # returns true
celsius_to_fahrenheit(-20.0) == -4.0          # returns true
celsius_to_fahrenheit(0) == 32.0              # returns true
celsius_to_fahrenheit(20) == 68.0             # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/conversions/temparature_conversion.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Conversions.celsius_to_kelvin" href="#TheAlgorithms.Conversions.celsius_to_kelvin"><code>TheAlgorithms.Conversions.celsius_to_kelvin</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function celsius<em>to</em>kelvin(celsius, ndigits::Int = 2)</p><p>Converts celsius to kelvin and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">celsius_to_kelvin(273.354, 3) == 546.504    # returns true
celsius_to_kelvin(273.354, 0) == 547.0      # returns true
celsius_to_kelvin(0.0) == 273.15            # returns true
celsius_to_kelvin(20.0) == 293.15           # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/conversions/temparature_conversion.jl#L21-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Conversions.fahrenheit_to_celsius" href="#TheAlgorithms.Conversions.fahrenheit_to_celsius"><code>TheAlgorithms.Conversions.fahrenheit_to_celsius</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fahrenheit<em>to</em>celsius(fahrenheit, ndigits::Int = 2)</p><p>Converts fahrenheit to celsius and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">fahrenheit_to_celsius(273.354, 3) == 134.086 # returns true
fahrenheit_to_celsius(273.354, 0) == 134.0   # returns true
fahrenheit_to_celsius(0.0) == -17.78         # returns true
fahrenheit_to_celsius(20.0) == -6.67         # returns true
fahrenheit_to_celsius(40.0) == 4.44          # returns true
fahrenheit_to_celsius(60.0) == 15.56         # returns true
fahrenheit_to_celsius(80.0) == 26.67         # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/conversions/temparature_conversion.jl#L40-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Conversions.fahrenheit_to_kelvin" href="#TheAlgorithms.Conversions.fahrenheit_to_kelvin"><code>TheAlgorithms.Conversions.fahrenheit_to_kelvin</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fahrenheit<em>to</em>kelvin(fahrenheit, ndigits::Int = 2)</p><p>Converts fahrenheit to kelvin and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">fahrenheit_to_kelvin(273.354, 3) == 407.236 # returns true
fahrenheit_to_kelvin(273.354, 0) == 407.0   # returns true
fahrenheit_to_kelvin(0) == 255.37           # returns true
fahrenheit_to_kelvin(20.0) == 266.48        # returns true
fahrenheit_to_kelvin(40.0) == 277.59        # returns true
fahrenheit_to_kelvin(60.0) == 288.71        # returns true
fahrenheit_to_kelvin(80.0) == 299.82        # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/conversions/temparature_conversion.jl#L61-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Conversions.kelvin_to_celsius" href="#TheAlgorithms.Conversions.kelvin_to_celsius"><code>TheAlgorithms.Conversions.kelvin_to_celsius</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function kelvin<em>to</em>celsius(kelvin, ndigits::Int = 2)</p><p>Converts kelvin to celsius and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">kelvin_to_celsius(273.354, 3) == 0.204   # returns true
kelvin_to_celsius(273.354, 0) == 0.0     # returns true
kelvin_to_celsius(273.15) == 0.0         # returns true
kelvin_to_celsius(300) == 26.85          # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/conversions/temparature_conversion.jl#L85-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Conversions.kelvin_to_fahrenheit" href="#TheAlgorithms.Conversions.kelvin_to_fahrenheit"><code>TheAlgorithms.Conversions.kelvin_to_fahrenheit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function kelvin<em>to</em>fahrenheit(kelvin, ndigits::Int = 2)</p><p>Converts kelvin to fahrenheit and round to 2 decimal places</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">kelvin_to_fahrenheit(273.354, 3) == 32.367  # returns true
kelvin_to_fahrenheit(273.354, 0) == 32.0    # returns true
kelvin_to_fahrenheit(273.15) == 32.0        # returns true
kelvin_to_fahrenheit(300) == 80.33          # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/conversions/temparature_conversion.jl#L103-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DataStructure" href="#TheAlgorithms.DataStructure"><code>TheAlgorithms.DataStructure</code></a> — <span class="docstring-category">Module</span></header><section><div><p>DataStructure</p><p><code>DataStructure</code> algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/data_structures/DataStructure.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DataStructure.AbstractBinarySearchTree_arr" href="#TheAlgorithms.DataStructure.AbstractBinarySearchTree_arr"><code>TheAlgorithms.DataStructure.AbstractBinarySearchTree_arr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>array-based binary search tree left tree values &lt; root value &lt; right tree values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/data_structures/binary_tree/basic_binary_search_tree.jl#L2-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DataStructure.AbstractBinaryTree_arr" href="#TheAlgorithms.DataStructure.AbstractBinaryTree_arr"><code>TheAlgorithms.DataStructure.AbstractBinaryTree_arr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>array-based binary tree</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/data_structures/binary_tree/basic_binary_tree.jl#L2-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DataStructure.BinaryHeap" href="#TheAlgorithms.DataStructure.BinaryHeap"><code>TheAlgorithms.DataStructure.BinaryHeap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BinaryHeap{T,HT}</code></pre><p>A heap data structures implemented as a binary tree. It can be instantiated either as a <code>MinHeap</code> or <code>MaxHeap</code>. In a <code>MinHeap</code> each element in the tree is smaller than its children, and similarly, in a <code>MaxHeap</code> each element is greater than its children, this is called &quot;Heap Property&quot;.</p><p>One of the most common usage of the Heaps is as a Priority Queue. Note that the element with highest priority will always be at the root of the tree.</p><p>In this implementation, the tree is store in a <code>Vector</code> where the first element (<code>index = 1</code>) is the root and for all elements, it&#39;s children will be at <code>index * 2</code> and <code>index * 2 + 1</code>. The methods are implemented just once for both min and max heap, and it relies on the multiple dispatch of the <code>isbefore</code> function that will depend on the heap type.</p><p><strong>Functions:</strong></p><ul><li><code>MinHeap{T}</code>/<code>MaxHeap{T}</code>: constructors</li><li><code>push!(heap, elements...)</code>: push elements into the heap</li><li><code>top(heap)</code>: get the top element (smaller in a <code>MinHeap</code>, greater in a <code>MaxHeap</code>)</li><li><code>pop!(heap)</code>: get top element and remove it from the heap</li><li><code>isempty(heap)</code>: wheter theres no elemets in the heap</li><li><code>length(heap)</code>: how many elements are in the heap</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">heap = MinHeap{Int}()
push!(heap, 4, 2, 3, 1, 5)
while !isempty(heap)
    println(pop!(heap))
end

# output

1
2
3
4
5</code></pre><p><strong>Complexities:</strong></p><ul><li>Space: O(n)</li><li>Get top element: O(1)</li><li>Push a element: O(log n)</li><li>Pop a element: O(log n)</li><li>Get number of elements: O(1)</li></ul><p>Contributed By: <a href="https://github.com/gosoares">Gabriel Soares</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/data_structures/binary_heap.jl#L5-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DataStructure.DisjointSet" href="#TheAlgorithms.DataStructure.DisjointSet"><code>TheAlgorithms.DataStructure.DisjointSet</code></a> — <span class="docstring-category">Type</span></header><section><div><p>This can contain a maximum of <code>length(par)</code> parenting-relations par is an array of <code>Int</code>, which is the index of the parent node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/data_structures/disjoint_set/disjoint_set.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DataStructure.find-Tuple{TheAlgorithms.DataStructure.DisjointSet, Int64}" href="#TheAlgorithms.DataStructure.find-Tuple{TheAlgorithms.DataStructure.DisjointSet, Int64}"><code>TheAlgorithms.DataStructure.find</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the ancestor of node <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/data_structures/disjoint_set/disjoint_set.jl#L13-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DataStructure.isbefore-Union{Tuple{T}, Tuple{TheAlgorithms.DataStructure.MinHeap{T}, T, T}} where T" href="#TheAlgorithms.DataStructure.isbefore-Union{Tuple{T}, Tuple{TheAlgorithms.DataStructure.MinHeap{T}, T, T}} where T"><code>TheAlgorithms.DataStructure.isbefore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isbefore(heap, x, y)</code></pre><p>Whether <code>x</code> comes before <code>y</code> in the <code>heap</code> ordering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/data_structures/binary_heap.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DataStructure.LinkedList" href="#TheAlgorithms.DataStructure.LinkedList"><code>TheAlgorithms.DataStructure.LinkedList</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Linked List</p><p><strong>Brief:</strong></p><pre><code class="nohighlight hljs">A linked list is a data structure where each element is connected to the next one.</code></pre><p><strong>Complexity of some operations</strong></p><pre><code class="nohighlight hljs">- insert            - O(N)
- insert to front   - O(1)
- delete            - O(N)
- delete first      - O(1)
- get element       - O(N)</code></pre><p><strong>Functions</strong></p><pre><code class="nohighlight hljs">- create_node(val, next=missing) - Create node with value &#39;val&#39; and the pointer to the next node ( missing by default ) 
- create_list(n::Int=0, val=missing) - Create root node of the list with n elements with value set to &#39;val&#39;
- insert(list::Node, new_node::Node, index::Int=1) - Add a new node to the list at the specified index
- insert(list::Node, val, index::Int=1) - Create a new node with value &#39;val&#39; in the list at the specified index
- push_back(list::Node, node::Node) - Add a new node to the end of the list
- push_back(list::Node, val) - Add a new node with value &#39;val&#39; to the end of the list
- return_as_array(list::Node) - Return the array representation of the list
- clear(list::Node) - Remove all elements from the list
- remove(list::Node, index::Int) - Remove an element at the specified index
- remove_all(list::Node, val) Remove all elements with the value &#39;val&#39;
- remove_first(list::Node, val) - Remove the first element in the list with value &#39;val&#39;
- get_node(list::Node, index::Int) - Get a node at the specified index
- get(list::Node, index::Int) - Get a value from the node at the specified index
- indexOf(list::Node, val) - Return the index of the first element with a value &#39;val&#39;
- is_empty(list) - Return true if list is empty, false if it has elements</code></pre><p><strong>Contributed by: <a href="https://github.com/Nikola-Mircic">Nikola Mircic</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/data_structures/linked_list.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DataStructure.FenwickTree.change-Union{Tuple{T}, Tuple{Array{T}, Integer, Integer}} where T&lt;:Number" href="#TheAlgorithms.DataStructure.FenwickTree.change-Union{Tuple{T}, Tuple{Array{T}, Integer, Integer}} where T&lt;:Number"><code>TheAlgorithms.DataStructure.FenwickTree.change</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This function changes the tree to correspond to an array after adding k to the element at index x</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- tree::Array{T} - A Fenwick tree for an array
- x::Integer - Index of the changed element
- k::Integer - An integer added to the element arr[x]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/data_structures/fenwick_tree.jl#L78-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DataStructure.FenwickTree.create_tree-Union{Tuple{Array{T}}, Tuple{T}} where T&lt;:Number" href="#TheAlgorithms.DataStructure.FenwickTree.create_tree-Union{Tuple{Array{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.DataStructure.FenwickTree.create_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is a function for generating the tree from the given array of numbers.</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- arr::Array{T} : An array of numbers.</code></pre><p><strong>Returns</strong></p><pre><code class="nohighlight hljs">- A Fenwick tree for the given array</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/data_structures/fenwick_tree.jl#L20-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DataStructure.FenwickTree.get_sum-Union{Tuple{T}, Tuple{Array{T}, Integer}} where T&lt;:Number" href="#TheAlgorithms.DataStructure.FenwickTree.get_sum-Union{Tuple{T}, Tuple{Array{T}, Integer}} where T&lt;:Number"><code>TheAlgorithms.DataStructure.FenwickTree.get_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This is a function that returns the sum of the first x elements</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- tree::Array{T} - A Fenwick tree for an array
- x::Integer - The number of the elements</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/data_structures/fenwick_tree.jl#L44-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DataStructure.FenwickTree.to_arr-Union{Tuple{Array{T}}, Tuple{T}} where T&lt;:Number" href="#TheAlgorithms.DataStructure.FenwickTree.to_arr-Union{Tuple{Array{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.DataStructure.FenwickTree.to_arr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a original array from the given tree</p><p><strong>Arguments</strong></p><pre><code class="nohighlight hljs">- tree::Array{T} - an binary index tree which is used for calculating the original array</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/data_structures/fenwick_tree.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DynamicProgramming" href="#TheAlgorithms.DynamicProgramming"><code>TheAlgorithms.DynamicProgramming</code></a> — <span class="docstring-category">Module</span></header><section><div><p>DynamicProgramming</p><p><code>DynamicProgramming</code> algorithms in Julia.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/dynamic_programming/DynamicProgramming.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.DynamicProgramming.coin_change-Tuple{Vector{Int64}, Int64}" href="#TheAlgorithms.DynamicProgramming.coin_change-Tuple{Vector{Int64}, Int64}"><code>TheAlgorithms.DynamicProgramming.coin_change</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coin_change(coins::Vector{Int}, amount::Int)</code></pre><p>Given a vector <code>coins</code> of coin values, calculates the minimum number of coins that sums to <code>amount</code>. It&#39;s considered that a unlimited number of coins for each value is available.</p><p><strong>Arguments:</strong></p><ul><li><code>coins</code>: the coins values available</li><li><code>amount</code>: the total amount that need to be summed to</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; n_coins, coins = coin_change([1, 3, 4, 7], 13);

julia&gt; n_coins
3

julia&gt; coins
3-element Vector{Int64}:
 3
 3
 7

julia&gt; n_coins, coins = coin_change([2, 4, 6], 23)
(-1, Int64[])

julia&gt; n_coins
-1

julia&gt; coins
Int64[]</code></pre><p><strong>Contributors:</strong></p><ul><li><a href="https://github.com/gosoares">Gabriel Soares</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/dynamic_programming/coin_change.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Graph" href="#TheAlgorithms.Graph"><code>TheAlgorithms.Graph</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Graph</p><p><code>Graph</code> related algorithms in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/graph/Graph.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Graph.bellman_ford" href="#TheAlgorithms.Graph.bellman_ford"><code>TheAlgorithms.Graph.bellman_ford</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bellman_ford(graph::Vector{Tuple{Int, Int, Int}}, source::Int)</code></pre><p>The Bellman-Ford algorithm is an algorithm which computes the shortest paths from a single source vertex to all other vertices in a weighted graph. It is slower than Dijkstra&#39;s algorithm, which solves the same problem, but it is capable of handling graphs with negative edge weights. Instead of greedily performing the relaxation on the vertices, Bellman-Ford simply relaxes all edges, and does this |V|-1 times.</p><p><strong>Arguments:</strong></p><ul><li><code>graph</code>: a directed, weighted graph</li><li><code>source</code>: the source vertex from which to begin the traversal</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">graph = [
    (1, 2, 4), (1, 3, 2),
    (2, 3, 3), (2, 4, 2), (2, 5, 3),
    (3, 2, 1), (3, 4, 4), (3, 5, 5),
    (5, 4, -5)
]
bellman_ford(graph, 1)

# output

5-element Vector{Int64}:
 0
 3
 2
 1
 6</code></pre><p>Contributed by: <a href="https://github.com/ybrenning">Yannick Brenning</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/graph/bellman_ford.jl#L1-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Graph.bfs" href="#TheAlgorithms.Graph.bfs"><code>TheAlgorithms.Graph.bfs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bfs(graph:Vector{Vector{Int}}, source::Int = 1)</code></pre><p>Depth-first search is an algorithm for traversing or searching tree or graph data structures.  The algorithm starts at a given vertex and explores all vertices at the present depth before moving to the next &quot;level&quot;. This implementation is for educational purposes only, so it simply prints out the vertices in the order that they were traversed.</p><p><strong>Arguments:</strong></p><ul><li><code>graph</code>: a directed, unweighted graph</li><li><code>source</code>: the source vertex from which to begin the traversal</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">graph = [
    [2, 3, 6], 
    [3, 4],
    [4],
    [1, 2, 5],
    [2],
    [1, 5]
]
TheAlgorithms.Graph.bfs(graph, 4)

# output

4 1 2 5 3 6</code></pre><p>Contributed by: <a href="https://github.com/ybrenning">Yannick Brenning</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/graph/bfs.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Graph.dfs" href="#TheAlgorithms.Graph.dfs"><code>TheAlgorithms.Graph.dfs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dfs(graph::Vector{Vector{Int}}, source::Int)</code></pre><p>Depth-first search is an algorithm for traversing or searching tree or graph data structures.  The algorithm starts at a given vertex and explores as far as possible along each branch before backtracking. This implementation is for educational purposes only, so it simply prints out the vertices in the order that they were traversed.</p><p><strong>Arguments:</strong></p><ul><li><code>graph</code>: a directed, unweighted graph</li><li><code>source</code>: the source vertex from which to begin the traversal</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">graph = [
    [2, 3, 6], 
    [3, 4],
    [4],
    [1, 2, 5],
    [2],
    [1, 5]
]
dfs(graph, 6)

# output

6 5 2 4 3 1</code></pre><p>Contributed by: <a href="https://github.com/ybrenning">Yannick Brenning</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/graph/dfs.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Graph.dijkstra-Tuple{Vector{Vector{Tuple{Int64, Int64}}}, Int64}" href="#TheAlgorithms.Graph.dijkstra-Tuple{Vector{Vector{Tuple{Int64, Int64}}}, Int64}"><code>TheAlgorithms.Graph.dijkstra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dijkstra(graph::Vector{Vector{Tuple{Int,Int}}}, source::Int)</code></pre><p>Given a directed graph with weights on the arcs and a source vertex, the dijkstra algorithm calculates the distance from the source to all other vertices, and the solution tree associated with those distances. The solution tree is given by a vector <code>prev</code> which stores the source of the arc that arrives at each vertex. By definition: distance[source] = prev[source] = 0. If a vertex v is not reachable from the source, then distance[v] = prev[v] = -1.</p><p><strong>Arguments:</strong></p><ul><li><code>graph</code>: a directed graph with weights on the arcs</li><li><code>source</code>: the source vertex from which the distances will be calculated</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">graph = [
    [(2, 8), (3, 6), (4, 4)],
    [(3, 1), (5, 5)],
    [(5, 4)],
    [(2, 3), (5, 9)],
    [(1, 2), (3, 2), (4, 5)],
    [(1, 1), (4, 3)],
]
distances, prev = dijkstra(graph, 1)

println(&quot;v | dist | path&quot;)
for v in eachindex(graph)
    distance = distances[v] == -1 ? &quot;  NR&quot; : lpad(distances[v], 4) # NR: Non Reachable
    path = join(get_dijkstra_path(prev, v), &quot; -&gt; &quot;)
    println(&quot;$v | $distance | $path&quot;)
end

# output

v | dist | path
1 |    0 | 1
2 |    7 | 1 -&gt; 4 -&gt; 2
3 |    6 | 1 -&gt; 3
4 |    4 | 1 -&gt; 4
5 |   10 | 1 -&gt; 3 -&gt; 5
6 |   NR | </code></pre><p>Contributed By: <a href="https://github.com/gosoares">Gabriel Soares</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/graph/dijkstra.jl#L2-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Graph.get_dijkstra_path-Tuple{Vector{Int64}, Int64}" href="#TheAlgorithms.Graph.get_dijkstra_path-Tuple{Vector{Int64}, Int64}"><code>TheAlgorithms.Graph.get_dijkstra_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_dijkstra_path(tree::Vector{Int}, dest::Int)</code></pre><p>Given a solution <code>tree</code> from the <a href="#TheAlgorithms.Graph.dijkstra-Tuple{Vector{Vector{Tuple{Int64, Int64}}}, Int64}"><code>dijkstra</code></a> algorithm, extract the path from the source to <code>dest</code>, including them.</p><p><strong>Arguments:</strong></p><ul><li><code>tree</code>: solution tree from the <a href="#TheAlgorithms.Graph.dijkstra-Tuple{Vector{Vector{Tuple{Int64, Int64}}}, Int64}"><code>dijkstra</code></a> algorithm</li><li><code>dest</code>: path&#39;s destionation vertex</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/graph/dijkstra.jl#L82-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.KnapSack.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}" href="#TheAlgorithms.KnapSack.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.KnapSack.complete_pack!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This does complete/infinite (each item can be chosen infinite times) knapsack : pack capacity = capacity weight of each item = weights value of each item = values dp array is what the function works on It returns the ans (dp[capacity])</p><pre><code class="nohighlight hljs">julia&gt; dp=zeros(Int,30)
julia&gt; complete_pack!(20,[1,2,9],[1,3,20],dp)
43</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/knapsack/dynamic_programming.jl#L32-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.KnapSack.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}" href="#TheAlgorithms.KnapSack.complete_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.KnapSack.complete_pack!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>This does complete/infinite (each item can be chosen infinite times) knapsack : pack capacity = capacity weight of each item = weights value of each item = values</p><p>Each loop the function will find the highest value in the array and check if the capacity is enough to store it, if enough then  the value will be added into the total<em>max</em>value until the capacity cannot hold the weight of the highest current value.  After that the highest current value will be deleted.</p><pre><code class="nohighlight hljs">julia&gt; complete_pack!(20,[1,2,9],[1,3,20])
43</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/knapsack/greedy_algorithm.jl#L36-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.KnapSack.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}" href="#TheAlgorithms.KnapSack.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.KnapSack.zero_one_pack!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_one_pack!(capacity::N, weights::V, values::V, dp::V) where {N &lt;: Number,V &lt;: AbstractVector}</code></pre><p>This does 0-1 (each item can be chosen only once) knapsack : pack capacity = capacity weight of each item = weights value of each item = values dp array is what the function works on It returns the ans (dp[capacity])</p><pre><code class="nohighlight hljs">julia&gt; dp=zeros(Int,30)
julia&gt; zero_one_pack!(20,[1,3,11],[2,5,30],dp)
37</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/knapsack/dynamic_programming.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.KnapSack.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}" href="#TheAlgorithms.KnapSack.zero_one_pack!-Union{Tuple{V}, Tuple{N}, Tuple{N, V, V}} where {N&lt;:Number, V&lt;:(AbstractVector)}"><code>TheAlgorithms.KnapSack.zero_one_pack!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For greedy algorithm, it will take the element based on the optimal value in the array at each loop in the function</p><p>This does 0-1 (each item can be chosen only once) knapsack : pack capacity = capacity weight of each item = weights value of each item = values</p><p>Each loop the function will find the highest value in the array and check if the capacity is enough to store it, if enough then  the value will be added into the total<em>max</em>value.  After that the highest current value will be deleted.</p><pre><code class="nohighlight hljs">julia&gt; zero_one_pack!(20,[1,3,11],[2,5,30])
37</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/knapsack/greedy_algorithm.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.LongSubSeq" href="#TheAlgorithms.LongSubSeq"><code>TheAlgorithms.LongSubSeq</code></a> — <span class="docstring-category">Module</span></header><section><div><p>LongSubSeq</p><p><code>LongSubSeq</code> for longest increasing subsequence algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/longest_increasing_subsequence/LongSubSeq.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math" href="#TheAlgorithms.Math"><code>TheAlgorithms.Math</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Math</p><p><code>Math</code> algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/Math.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.abs_max-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real" href="#TheAlgorithms.Math.abs_max-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real"><code>TheAlgorithms.Math.abs_max</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs_max(x)</code></pre><p>Program to find the max absolute value in a vector</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">abs_max([1,3,4]) # returns 4
abs_max([-3,1,2]) # returns -3
abs_max([-7,-3,6]) #returns -7</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/abs.jl#L22-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.abs_min-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real" href="#TheAlgorithms.Math.abs_min-Union{Tuple{Vector{N}}, Tuple{N}} where N&lt;:Real"><code>TheAlgorithms.Math.abs_min</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs_min(num)</code></pre><p>Program to find the min absolute value in a vector</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">abs_min([1,3,4]) # returns 1
abs_min([-3,1,2]) # returns 1
abs_min([-7,-3,6]) #returns -3</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/abs.jl#L46-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.abs_val-Tuple{N} where N&lt;:Real" href="#TheAlgorithms.Math.abs_val-Tuple{N} where N&lt;:Real"><code>TheAlgorithms.Math.abs_val</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">abs_val(num)</code></pre><p>Program to find the absolute value of a number</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">abs_val(-100) # returns 100
abs_val(0) # returns 0
abs(123.1) # returns 123.1
-1000 == abs_val(-1000) #returns false
1000 == abs_val(1000) #returns true</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/abs.jl#L2-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.aliquot_sum-Tuple{Int64}" href="#TheAlgorithms.Math.aliquot_sum-Tuple{Int64}"><code>TheAlgorithms.Math.aliquot_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aliquot_sum(n::Int)</code></pre><p>The aliquot sum of a positive integer n is the sum of all the proper divisors of n, i.e, all divisors of n other than n itself.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : The number to find the aliquot sum of.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">aliquot_sum(6)      # returns 6
aliquot_sum(10)     # returns 8
aliquot_sum(1345)   # returns 275
aliquot_sum(-1)     # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://en.wikipedia.org/wiki/Aliquot_sum</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/divisors.jl#L50-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.amicable_pairs-Tuple{Int64}" href="#TheAlgorithms.Math.amicable_pairs-Tuple{Int64}"><code>TheAlgorithms.Math.amicable_pairs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">amicable_pairs(n::Int)</code></pre><p>Two unique natural numbers are said to form an amicable pair when them sum of proper divisors of each is equal to the other number.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : Finds amicable pairs below n.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">amicable_pairs(10)      # returns []
amicable_pairs(400)     # returns [220 =&gt; 284]
amicable_pairs(2000)    # returns [220 =&gt; 284, 1184 =&gt; 1210]
amicable_pairs(-1)      # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://mathworld.wolfram.com/AmicablePair.html</li></ul><p>Contributed by <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/amicable_numbers.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.area_circle-Tuple{Any}" href="#TheAlgorithms.Math.area_circle-Tuple{Any}"><code>TheAlgorithms.Math.area_circle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_circle(radius)</code></pre><p>Finds area of the circle</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_circle(20) # returns 1256.6370614359173
area_circle(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L222-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.area_ellipse-Tuple{Any, Any}" href="#TheAlgorithms.Math.area_ellipse-Tuple{Any, Any}"><code>TheAlgorithms.Math.area_ellipse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_ellipse(radius_x, radius_y)</code></pre><p>Finds area of the ellipse</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_ellipse(10, 10) # returns 314.1592653589793
area_ellipse(10, 20) # returns 628.3185307179587
area_ellipse(1, -2) # returns DomainError
area_ellipse(-1, 2) # returns DomainError
area_ellipse(-1, -2) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L241-L255">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.area_heron_triangle-Tuple{Any, Any, Any}" href="#TheAlgorithms.Math.area_heron_triangle-Tuple{Any, Any, Any}"><code>TheAlgorithms.Math.area_heron_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_heron_triangle(side1, side2, side3)</code></pre><p>Finds area of a triangle using heron&#39;s formula</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_heron_triangle(5,12,13) # returns 30.0
area_heron_triangle(-1,-2,1) # returns DomainError
area_heron_triangle(1,-2,1)  # returns DomainError
area_heron_triangle(-1,2,1)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L136-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.area_parallelogram-Tuple{Any, Any}" href="#TheAlgorithms.Math.area_parallelogram-Tuple{Any, Any}"><code>TheAlgorithms.Math.area_parallelogram</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_parallelogram(base, height)</code></pre><p>Finds area of the parallelogram</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_parallelogram(10,20) # returns 200
area_parallelogram(-1,-2) # returns DomainError
area_parallelogram(1,-2)  # returns DomainError
area_parallelogram(-1,2)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L172-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.area_polygon-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real" href="#TheAlgorithms.Math.area_polygon-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>TheAlgorithms.Math.area_polygon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_polygon(V)</code></pre><p>Finds area of any Polygon given by continuous sequence of vertex coordinates Arguments:</p><ul><li>coords: x,y co-ordinates of the vertices   [Vector of Tuples / Matrix with 2 rows or 2 columns]</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_polygon([(0, 0), (100, 0), (0, 100)])  # returns 5000.0
area_polygon([0 0;100 0;100 100;0 100])  # returns 10000.0
area_polygon([(6, 4.5), (5, 4.5), (4.5, 5.5), (5, 6.5)]) # returns 1.5
area_polygon([0 0;100 0]) # returns DomainError
area_polygon([(6, 4.63), (5, 4.63)]) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L336-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.area_rectangle-Tuple{Any, Any}" href="#TheAlgorithms.Math.area_rectangle-Tuple{Any, Any}"><code>TheAlgorithms.Math.area_rectangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_rectangle(length, width)</code></pre><p>Finds area of the rectangle</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_rectangle(10,20) # returns 200
area_rectangle(-1,-2) # returns DomainError
area_rectangle(1,-2)  # returns DomainError
area_rectangle(-1,2)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L73-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.area_regular_polygon-Tuple{Any, Any}" href="#TheAlgorithms.Math.area_regular_polygon-Tuple{Any, Any}"><code>TheAlgorithms.Math.area_regular_polygon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_regular_polygon(sides, side_len)</code></pre><p>Finds area of any regular Polygon</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_regular_polygon(1, 5)  # returns DomainError
area_regular_polygon(3, 5)  # returns 10.825317547305486
area_regular_polygon(7, 15)  # returns 817.6302999003576
area_regular_polygon(-1, 4) # returns DomainError
area_regular_polygon(4, -3) # returns DomainError
area_regular_polygon(-12, -4) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L310-L325">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.area_rhombus-Tuple{Any, Any}" href="#TheAlgorithms.Math.area_rhombus-Tuple{Any, Any}"><code>TheAlgorithms.Math.area_rhombus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_rhombus(diagonal_1, diagonal_2)</code></pre><p>Finds area of the rhombus</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_rhombus(10, 20) # returns 100.0
area_rhombus(-1,-2) # returns DomainError
area_rhombus(1,-2)  # returns DomainError
area_rhombus(-1,2)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L263-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.area_square-Tuple{Any}" href="#TheAlgorithms.Math.area_square-Tuple{Any}"><code>TheAlgorithms.Math.area_square</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_square(side)</code></pre><p>Finds area of the area_square</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_square(10) # returns 100
area_square(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L96-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.area_trapezium-Tuple{Any, Any, Any}" href="#TheAlgorithms.Math.area_trapezium-Tuple{Any, Any, Any}"><code>TheAlgorithms.Math.area_trapezium</code></a> — <span class="docstring-category">Method</span></header><section><div><p>area_trapezium(base1,base2,height)</p><p>Finds area of the traπzium</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_trapezium(10, 20, 30)  # returns 450.0
area_trapezium(-1, -2, -3)  # returns DomainError
area_trapezium(-1, 2, 3)    # returns DomainError
area_trapezium(1, -2, 3)    # returns DomainError
area_trapezium(1, 2, -3)    # returns DomainError
area_trapezium(-1, -2, 3)   # returns DomainError
area_trapezium(1, -2, -3)   # returns DomainError
area_trapezium(-1, 2, -3)   # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L197-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.area_triangle-Tuple{Any, Any}" href="#TheAlgorithms.Math.area_triangle-Tuple{Any, Any}"><code>TheAlgorithms.Math.area_triangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area_triangle(base, height)</code></pre><p>Finds area of the right angled triangle with base height</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">area_triangle(10,10) # returns 50.0
area_triangle(-1,-2) # returns DomainError
area_triangle(1,-2)  # returns DomainError
area_triangle(-1,2)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L115-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.average_absolute_deviation-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#TheAlgorithms.Math.average_absolute_deviation-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.Math.average_absolute_deviation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">average_absolute_deviation(numbers)</code></pre><p>The average absolute deviation of a data set is the average of the absolute deviations from the mean. It is  a measure of statistical dispersion or variability.</p><p><strong>Input parameters:</strong></p><ul><li><code>numbers</code> : The numbers to find the average absolute deviation of.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">average_absolute_deviation([1, 2, 3, 4, 5])     # returns 1.2
average_absolute_deviation([0])                 # returns 0.0
average_absolute_deviation([5.5, 64.3, 100.4])  # returns 34.16</code></pre><p><strong>Reference</strong></p><ul><li>https://mathworld.wolfram.com/AverageAbsoluteDeviation.html</li></ul><p>Contributed by <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/average_absolute_deviation.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.bab_sqrt-Tuple{Real}" href="#TheAlgorithms.Math.bab_sqrt-Tuple{Real}"><code>TheAlgorithms.Math.bab_sqrt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bab_sqrt(S::Real; tolerance = 1e-6, guess = nothing)</code></pre><p>The Babylonian Method of calculating a square root is a simple iterative method to determine square roots. A full description of the algorithm can be found on <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method">Wikipedia</a></p><p><strong>Arguments:</strong></p><ul><li><code>S</code>: The number to calculate the square root for.</li></ul><p><strong>Positional Arguments</strong></p><ul><li><code>tolerance</code>: How close the square of the square root needs to be from the input value. <code>abs(S - xn^2) &lt; tolerance</code></li><li><code>guess</code>: The initial value to use for <code>xn</code></li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; bab_sqrt(100)
10.000000000107445

julia&gt; bab_sqrt(100, guess = 15)
10.000000000131072

julia&gt; bab_sqrt(π, guess = 1)
1.7724538555800293

julia&gt; bab_sqrt(π, guess = 1, tolerance = 2)
2.0707963267948966</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">while tolerance &lt;= abs(xn^2 - S)
    xn = (1 / 2) * (xn + S / xn)
end</code></pre><p><strong>References:</strong></p><p><a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method">Methods of computing square roots</a></p><p>```</p><p><strong>Contributed by:- <a href="https://ansonbiggs.com">Anson Biggs</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/babylonian_sqrt.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.catalan-Tuple{Int64}" href="#TheAlgorithms.Math.catalan-Tuple{Int64}"><code>TheAlgorithms.Math.catalan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">catalan(n::Int)</code></pre><p>In combinatorial mathematics, the Catalan numbers are a sequence of natural numbers that occur in various counting problems, often involving recursively defined objects.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : index of the catalan number.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">catalan(0)  # returns 1
catalan(3)  # returns 5
catalan(8)  # returns 1430
catalan(-1) # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://mathworld.wolfram.com/CatalanNumber.html</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/catalan_number.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.ceil-Tuple{Any}" href="#TheAlgorithms.Math.ceil-Tuple{Any}"><code>TheAlgorithms.Math.ceil</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ceil(x)</code></pre><p>Finds the ceiling of x as an functionInteger</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ceil(1.3)   # 2.0
ceil(2.0)   # returns 2.0
ceil(-1.5)  #returns -1.0</code></pre><p><strong>Reference</strong></p><ul><li>https://en.wikipedia.org/wiki/Floor<em>and</em>ceiling_functions</li></ul><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/ceil.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.divisors-Tuple{Int64}" href="#TheAlgorithms.Math.divisors-Tuple{Int64}"><code>TheAlgorithms.Math.divisors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">divisors(n::Int)</code></pre><p>Returns the divisors of n as a vector.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : The number to find the factors of.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">divisors(6)     # returns [1, 2, 3, 6]
divisors(10)    # returns [1, 2, 5, 10]
divisors(1345)  # returns [1, 5, 269, 1345]
divisors(-1)    # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://mathworld.wolfram.com/Divisor.html</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/divisors.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.eratosthenes-Tuple{Any}" href="#TheAlgorithms.Math.eratosthenes-Tuple{Any}"><code>TheAlgorithms.Math.eratosthenes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sieve of Eratosthenes is an algorithm for finding all the primes upto a limit <code>n</code>.</p><p>Reference: -https://en.wikipedia.org/wiki/Sieve<em>of</em>Eratosthenes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/sieve_of_eratosthenes.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.euler_method" href="#TheAlgorithms.Math.euler_method"><code>TheAlgorithms.Math.euler_method</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">euler_method(f, x0, span, h=1.0e-2)</code></pre><p>Calculate the solution to a differential equation using forward euler method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/euler_method.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.factorial_iterative-Tuple{Integer}" href="#TheAlgorithms.Math.factorial_iterative-Tuple{Integer}"><code>TheAlgorithms.Math.factorial_iterative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factorial_iterative(n)</code></pre><p>Finds factorial of a number using Iterative method</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">factorial_iterative(5)      # returns 120
factorial_iterative(-1)     # returns error</code></pre><p><strong>Reference</strong></p><ul><li>factorial of a positive integer – https://en.wikipedia.org/wiki/Factorial</li></ul><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/factorial.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.factorial_recursive-Tuple{Integer}" href="#TheAlgorithms.Math.factorial_recursive-Tuple{Integer}"><code>TheAlgorithms.Math.factorial_recursive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">factorial_recursive(n)</code></pre><p>Finds factorial of a number using recursive method</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">factorial_recursive(5)      # returns 120</code></pre><p><strong>Reference</strong></p><ul><li>factorial of a positive integer – https://en.wikipedia.org/wiki/Factorial</li></ul><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/factorial.jl#L35-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.fib_iterative-Tuple{Int64}" href="#TheAlgorithms.Math.fib_iterative-Tuple{Int64}"><code>TheAlgorithms.Math.fib_iterative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fib_iterative(n::Int)</code></pre><p>Finds the first n fibonacci number using iterative method.</p><p><strong>Arguments:</strong></p><ul><li><code>n</code> : Number of fibonacci numbers required</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">fib_iterative(1)    # returns [0]
fib_iterative(2)    # returns [0, 1]
fib_iterative(6)    # returns [0, 1, 1, 2, 3, 5]
fib_iterative(10)   # returns [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
fib_iterative(-1)   # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://mathworld.wolfram.com/FibonacciNumber.html</li></ul><p>Contributed by <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/fibonacci.jl#L74-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.fib_recursive-Tuple{Int64}" href="#TheAlgorithms.Math.fib_recursive-Tuple{Int64}"><code>TheAlgorithms.Math.fib_recursive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fib_recursive(n::Int)</code></pre><p>Finds the first n fibonacci number using recursive method.</p><p><strong>Arguments:</strong></p><ul><li><code>n</code> : Number of fibonacci numbers required</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">fib_recursive(1)    # returns [0]
fib_recursive(2)    # returns [0, 1]
fib_recursive(6)    # returns [0, 1, 1, 2, 3, 5]
fib_recursive(10)   # returns [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
fib_recursive(-1)   # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://mathworld.wolfram.com/FibonacciNumber.html</li></ul><p>Contributed by <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/fibonacci.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.fib_recursive_memo-Tuple{Int64}" href="#TheAlgorithms.Math.fib_recursive_memo-Tuple{Int64}"><code>TheAlgorithms.Math.fib_recursive_memo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fib_recursive_memo(n::Int)</code></pre><p>Finds the first n fibonacci number using recursive method and memoization.</p><p><strong>Arguments:</strong></p><ul><li><code>n</code> : Number of fibonacci numbers required</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">fib_recursive_memo(1)    # returns [0]
fib_recursive_memo(2)    # returns [0, 1]
fib_recursive_memo(6)    # returns [0, 1, 1, 2, 3, 5]
fib_recursive_memo(10)   # returns [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
fib_recursive_memo(-1)   # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://mathworld.wolfram.com/FibonacciNumber.html</li></ul><p>Contributed by <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/fibonacci.jl#L37-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.floor-Tuple{Any}" href="#TheAlgorithms.Math.floor-Tuple{Any}"><code>TheAlgorithms.Math.floor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">floor(x)</code></pre><p>Finds the floor of x as an Integer</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">floor(1.3)  # 1
floor(2.0)  # returns 2.0
floor(-1.7) # returns -2.0</code></pre><p><strong>Reference</strong></p><ul><li>https://en.wikipedia.org/wiki/Floor<em>and</em>ceiling_functions</li></ul><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/floor.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.get_mersenne_primes-Tuple{Int64}" href="#TheAlgorithms.Math.get_mersenne_primes-Tuple{Int64}"><code>TheAlgorithms.Math.get_mersenne_primes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_mersenne_primes(n::Int)</code></pre><p>A mersenne prime is a prime number that is one less than a power of 2. Returns a list of mersenne primes upto n.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : The limit upto which mersenne primes are to be generated.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">get_mersenne_primes(100)    # returns [3, 7, 31]
get_mersenne_primes(1000)   # returns [3, 7, 31, 127]
get_mersenne_primes(10000)  # returns [3, 7, 31, 127, 8191]</code></pre><p><strong>Reference</strong></p><ul><li>https://mathworld.wolfram.com/MersennePrime.html</li></ul><p>Contributed by <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/mersenne_prime.jl#L30-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.is_armstrong-Tuple{Any}" href="#TheAlgorithms.Math.is_armstrong-Tuple{Any}"><code>TheAlgorithms.Math.is_armstrong</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_armstrong(x)</code></pre><p>Program to check if a number is an <a href="https://en.wikipedia.org/wiki/Narcissistic_number">Armstrong/Narcissistic number</a> in decimal system.</p><p>Armstrong number is a number that is the sum of its own digits raised to the power of the number of digits.</p><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p><p>A positive integer is called an Armstrong number (of order n) if</p><p><code>abcd... = a^n + b^n + c^n + d^n +....</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/armstrong_number.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.is_mersenne_prime-Tuple{Int64}" href="#TheAlgorithms.Math.is_mersenne_prime-Tuple{Int64}"><code>TheAlgorithms.Math.is_mersenne_prime</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_mersenne_prime(n::Int)</code></pre><p>A mersenne prime is a prime number that is one less than a power of 2. Checks whether the given integer is a mersenne prime.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : The number to be checked.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">is_mersenne_prime(3)     # returns true
is_mersenne_prime(15)    # returns false
is_mersenne_prime(8191)  # returns true</code></pre><p><strong>Reference</strong></p><ul><li>https://mathworld.wolfram.com/MersennePrime.html</li></ul><p>Contributed by <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/mersenne_prime.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.krishnamurthy-Tuple{Any}" href="#TheAlgorithms.Math.krishnamurthy-Tuple{Any}"><code>TheAlgorithms.Math.krishnamurthy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">krishnamurthy(number)</code></pre><p>Check if a number is a Krishnamurthy number or not</p><p><strong>Details</strong></p><p>It is also known as Peterson Number. </p><p>A Krishnamurthy Number is a number whose sum of the factorial of the digits equals to the original number itself.</p><p>For example: 145 = 1! + 4! + 5!     So, 145 is a Krishnamurthy Number</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">krishnamurthy(145) # returns true
krishnamurthy(240) # returns false
krishnamurthy(1)   # returns true </code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/krishnamurthy_number.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.line_length" href="#TheAlgorithms.Math.line_length"><code>TheAlgorithms.Math.line_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">line_length(f, x_start, x_end, steps=100)</code></pre><p>Approximates the arc length of a line segment by treating the curve as a sequence of linear lines and summing their lengths.</p><p>Arguments:</p><ul><li>f: function that returns the arc</li><li>x_start: starting x value</li><li>x<em>end: ending x</em>value</li><li>steps: steps to take for accurace, more the steps greater the accuracy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/line_length.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.mean-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#TheAlgorithms.Math.mean-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.Math.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean(nums)</code></pre><p>Find mean of a vector of numbers</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mean([3, 6, 9, 12, 15, 18, 21])      # returns 12.0
mean([5, 10, 15, 20, 25, 30, 35])    # returns 20.0
mean([1, 2, 3, 4, 5, 6, 7, 8])       # returns 4.5</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/average_mean.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.median-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#TheAlgorithms.Math.median-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.Math.median</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">median(nums)</code></pre><p>Finds median of a vector of numbers</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">median([2,1,3,4])                   # returns 2.5
median([2, 70, 6, 50, 20, 8, 4])    # returns 8
median([0])                         # returns 0</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/average_median.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.mode-Tuple{Any}" href="#TheAlgorithms.Math.mode-Tuple{Any}"><code>TheAlgorithms.Math.mode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mode(nums)</code></pre><p>Finds mode of a vector of numbers</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mode([2, 3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 2, 2, 2])        # returns [2]
mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 2, 2, 2])        # returns [2]
mode([3, 4, 5, 3, 4, 2, 5, 2, 2, 4, 4, 4, 2, 2, 4, 2])  # returns [2, 4]
mode([&quot;x&quot;, &quot;y&quot;, &quot;y&quot;, &quot;z&quot;])                              # returns [&quot;y&quot;]
mode([&quot;x&quot;, &quot;x&quot; , &quot;y&quot;, &quot;y&quot;, &quot;z&quot;])                       # returns [&quot;x&quot;, &quot;y&quot;]</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/average_mode.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.monte_carlo_integration-Tuple{Function, Real, Real, Int64}" href="#TheAlgorithms.Math.monte_carlo_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.Math.monte_carlo_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">monte_carlo_integration(f::Function, a::Real, b::Real, n::Int)</code></pre><p>Monte carlo integration is a very easy and scalable way to do multidimentional integrals. However, only single variable integrals are considered.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: the function to integrate. (at the momment only single variable is suported)</li><li><code>a</code>: start in the integration limits.</li><li><code>b</code>: endin the integration limits.</li><li><code>N</code>: Number of points to sample. For most simple functions, 1000 to 10,000 should be okay.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; monte_carlo_integration(x -&gt; 3*x^2, 0, 1, 100000) # integrate a polynomial
1.0000037602209

julia&gt; monte_carlo_integration(x -&gt; sin(x), 0, pi, 1000) # integrate the sin function
2.0018927826323756</code></pre><p><strong>References</strong></p><ul><li>https://www.scratchapixel.com/lessons/mathematics-physics-for-computer-graphics/monte-carlo-methods-in-practice/monte-carlo-integration</li><li>https://kingaa.github.io/sbied/pfilter/monteCarlo.html</li></ul><p><strong>Contributors</strong></p><ul><li><a href="https://github.com/AugustoCL">AugustoCL</a></li><li><a href="https://github.com/Ved-Mahajan">Ved Mahajan</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/monte_carlo_integration.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.num_divisors-Tuple{Int64}" href="#TheAlgorithms.Math.num_divisors-Tuple{Int64}"><code>TheAlgorithms.Math.num_divisors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_divisors(n::Int)</code></pre><p>Efficiently finds the number of divisors of n.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : The number to find the number of divisors of.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">num_divisors(1)       # returns 1
num_divisors(13)      # returns 2
num_divisors(420)     # returns 24
num_divisors(1345)    # returns 4
num_divisors(-1)      # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://cp-algorithms.com/algebra/divisors.html#number-of-divisors</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/divisors.jl#L74-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.partitions_recursive-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.Math.partitions_recursive-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.Math.partitions_recursive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partitions_recursive(n)</code></pre><p>Finds partitions of an integer using recursion.</p><p>A partition of a positive integer n, also called an integer partition, is a way of writing n as a sum of positive integers.</p><p>There are 7 partitions of 5: 5 4 + 1 3 + 2 3 + 1 + 1 2 + 2 + 1 2 + 1 + 1 + 1 1 + 1 + 1 + 1 + 1</p><p>Partitions of n is equal to the sum of partitions of n with k parts.</p><p><span>$P \left ( n \right ) = \sum_{k=1}^{n} P_{k} \left ( n \right )$</span></p><p>Partitions of n with k parts is the sum of partitions of n-1 with k-1 parts and, partitions of n-k with k parts.</p><p><span>$P_{k}\left ( n \right ) =  P_{k-1}\left ( n - 1 \right ) + P_{k}\left ( n - k \right )$</span></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">partitions_recursive(0)      # returns 1
partitions_recursive(1)      # returns 1
partitions_recursive(10)     # returns 42
partitions_recursive(-1)     # returns DomainError</code></pre><p><strong>References</strong></p><ul><li>Partitions of a positive integer – https://en.wikipedia.org/wiki/Partition<em>function</em>(number_theory)</li><li>Partitions of a positive integer – https://www.whitman.edu/mathematics/cgt_online/book/section03.03.html</li></ul><p><strong>Contributor</strong></p><ul><li><a href="https://github.com/Whiteshark-314">Vaishakh C R</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/partitions.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.perfect_cube-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.Math.perfect_cube-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.Math.perfect_cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perfect_cube(number)</code></pre><p>Check if a number is a perfect cube or not.</p><p><strong>Example</strong></p><pre><code class="language-jula hljs">perfect_cube(27) # returns true
perfect_cube(4)  # returns false</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/perfect_cube.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.perfect_number-Tuple{N} where N&lt;:Number" href="#TheAlgorithms.Math.perfect_number-Tuple{N} where N&lt;:Number"><code>TheAlgorithms.Math.perfect_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">perfect_number(number)</code></pre><p>Checks if a number is a perfect_number number or not</p><p><strong>Details</strong></p><p>perfect_number number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself.</p><p>For example : 6 is perfect_number number</p><p>Divisors of 6 =&gt; [1,2,3]</p><p>Sum of divisors =&gt; 1+2+3 = 6</p><p>6 == sum(divisors) # which is true</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">perfect_number(27)     # returns false
perfect_number(28)     # returns true
perfect_number(496)    # returns true
perfect_number(8128)   # returns true
perfect_number(123)    # returns false</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/perfect_number.jl#L1-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.perfect_square-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.Math.perfect_square-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.Math.perfect_square</code></a> — <span class="docstring-category">Method</span></header><section><div><p>perfect_square(number)</p><p>Check if a number is a perfect square or not.</p><p><strong>Example</strong></p><pre><code class="language-jula hljs">perfect_square(9)   # returns True
perfect_square(16)  # returns True
perfect_square(1)   # returns True
perfect_square(0)   # returns True
perfect_square(10)  # returns False
perfect_square(-9)  # returns False</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/perfect_square.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.prime_check-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.Math.prime_check-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.Math.prime_check</code></a> — <span class="docstring-category">Method</span></header><section><div><p>prime_check(number)</p><p>Checks to see if a number is a prime or not</p><p>A number is prime if it has exactly two factors: 1 and itself.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">prime_check(2) # returns true
prime_check(3) # returns true
prime_check(5) # returns true
prime_check(7) # returns true
prime_check(11) # returns true
prime_check(13) # returns true
prime_check(17) # returns true
prime_check(19) # returns true
prime_check(23) # returns true
prime_check(29) # returns true
prime_check(30) # returns false</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a> and <a href="https://github.com/Rratic">Rratic</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/prime_check.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.prime_factors-Tuple{N} where N&lt;:Integer" href="#TheAlgorithms.Math.prime_factors-Tuple{N} where N&lt;:Integer"><code>TheAlgorithms.Math.prime_factors</code></a> — <span class="docstring-category">Method</span></header><section><div><p>prime_factors(number)</p><p>Returns prime factors of <code>number</code> as a vector</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">prime_factors(50)          # returns [2,5,5]
prime_factors(0)           # returns []
prime_factors(100)         # returns [2, 2, 5, 5]
prime_factors(2560)        # returns [2, 2, 2, 2, 2, 2, 2, 2, 2, 5]</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/prime_factors.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.riemann_integration" href="#TheAlgorithms.Math.riemann_integration"><code>TheAlgorithms.Math.riemann_integration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">riemann_integration(f::Function, a::Real, b::Real, n::Int, approx::Symbol = :midpoint)</code></pre><p>a Riemann sum is a certain kind of approximation of an integral by a finite sum. The sum is calculated by partitioning the region into shapes (rectangles, trapezoids, parabolas, or cubics) that together form a region that is similar to the region being measured, then calculating the area for each of these shapes, and finally adding all of these small areas together.</p><p>Because the region filled by the small shapes is usually not exactly the same shape as the region being measured, the Riemann sum will differ from the area being measured.  This error can be reduced by dividing up the region more finely, using smaller and smaller shapes.  As the shapes get smaller and smaller, the sum approaches the Riemann integral.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: the function to integrate. (at the momment only single variable is suported)</li><li><code>a</code>: Start of the integration limit.</li><li><code>b</code>: End of the integration limit.</li><li><code>n</code>: Number of points to sample. (as n increase, error decrease)</li><li><code>approx</code>: Indicate the method of approximation (midpoint, left or right)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; riemann_integration(x -&gt; x, 1, 3, 1_000, :midpoint)  # 4.0
julia&gt; riemann_integration(x -&gt; x, 1, 3, 1_000, :left)      # 3.997997997997998
julia&gt; riemann_integration(x -&gt; x, 1, 3, 1_000, :right)     # 4.002002002002002
julia&gt; riemann_integration(x -&gt; 3*x^2, 0, 1, 100000)        # integrate a polynomial
0.9999999999750021
julia&gt; riemann_integration(x -&gt; sin(x), 0, pi, 1000)          # integrate the sin function
2.0000008241146774</code></pre><p><strong>Refereces</strong></p><ul><li>https://www.khanacademy.org/math/ap-calculus-ab/ab-integration-new/ab-6-2/a/riemann-sums-review</li><li>https://math.libretexts.org/Courses/Mount<em>Royal</em>University/MATH<em>2200%3A</em>Calculus<em>for</em>Scientists<em>II/2%3A</em>Techniques<em>of</em>Integration/2.5%3A<em>Numerical</em>Integration<em>-</em>Midpoint%2C<em>Trapezoid%2C</em>Simpson&#39;s_rule</li><li>https://abel.math.harvard.edu/~knill/teaching/math1a_2011/handouts/40-numerical.pdf</li><li>https://en.wikipedia.org/wiki/Riemann_integral</li></ul><p>Contributed By:- <a href="https://github.com/AugustoCL">AugustoCL</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/riemann_integration.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.simpsons_integration-Tuple{Function, Real, Real, Int64}" href="#TheAlgorithms.Math.simpsons_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.Math.simpsons_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simpsons_integration(f::Function, a::Real, b::Real, n::Int)</code></pre><p>Simpson&#39;s rule uses a quadratic polynomial on each subinterval of a partition to approximate the function f(x) and to compute the definite integral.  This is an improvement over the trapezoid rule which approximates f(x) by a straight line on each subinterval of a partition. For more details of the method, check the link in the reference.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: The function to integrate. (ar the moment only single variable is suported)</li><li><code>a</code>: Start of the integration limit.</li><li><code>b</code>: End of the integration limit.</li><li><code>n</code>: Number of points to sample. (as n increase, error decrease)</li></ul><p><strong>Examples/Test</strong></p><pre><code class="language-julia hljs"># aproximate pi with f(x) = 4 / (1 + x^2)
julia&gt; simpsons_integration(x -&gt; 4 / (1 + x^2), 0, 1, 100_000)
3.1415926535897936
julia&gt; simpsons_integration(x -&gt; 4 / (1 + x^2), 0, 1, 100_000) ≈ pi
true</code></pre><p><strong>References:</strong></p><ul><li>https://personal.math.ubc.ca/~pwalls/math-python/integration/simpsons-rule/</li></ul><p><strong>Contributed By:- <a href="https://github.com/AugustoCL">AugustoCL</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/simpsons_integration.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.sum_ap-Tuple{Any, Any, Any}" href="#TheAlgorithms.Math.sum_ap-Tuple{Any, Any, Any}"><code>TheAlgorithms.Math.sum_ap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum_ap(first_term, diff, num_terms)</code></pre><p>Finds sum of a arithmetic progression series</p><p><strong>Input parameters</strong></p><ul><li>first_term : first term of the series</li><li>diff       : common difference between consecutive terms</li><li>num_terms  : number of terms in the series till which we count sum</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sum_ap(1, 1, 10)    # returns 55.0 
sum_ap(1, 10, 100)  # returns 49600.0</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/sum_of_arithmetic_series.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.sum_divisors-Tuple{Int64}" href="#TheAlgorithms.Math.sum_divisors-Tuple{Int64}"><code>TheAlgorithms.Math.sum_divisors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum_divisors(n::Int)</code></pre><p>Returns the sum of the divisors of n.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : The number to find the sum of divisors of.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">sum_divisors(6)     # returns 12
sum_divisors(10)    # returns 18
sum_divisors(1345)  # returns 1620
sum_divisors(-1)    # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://mathworld.wolfram.com/Divisor.html</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/divisors.jl#L26-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.sum_gp-Tuple{Any, Any, Any}" href="#TheAlgorithms.Math.sum_gp-Tuple{Any, Any, Any}"><code>TheAlgorithms.Math.sum_gp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum_gp(first_term, ratio, num_terms)</code></pre><p>Finds sum of n terms in a geometric progression</p><p><strong>Input parameters</strong></p><ul><li>first_term : first term of the series</li><li>raio      : common ratio between consecutive terms -&gt; a2/a1 or a3/a2 or a4/a3</li><li>num_terms  : number of terms in the series till which we count sum</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">sum_gp(1, 2, 10)    # 1023.0
sum_gp(1, 10, 5)    # 11111.0
sum_gp(0, 2, 10)    # 0.0
sum_gp(1, 0, 10)    # 1.0
sum_gp(1, 2, 0)     # -0.0
sum_gp(-1, 2, 10)   # -1023.0
sum_gp(1, -2, 10)   # -341.0</code></pre><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/sum_of_geometric_progression.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.surfarea_cube-Tuple{Any}" href="#TheAlgorithms.Math.surfarea_cube-Tuple{Any}"><code>TheAlgorithms.Math.surfarea_cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surfarea_cube(side)</code></pre><p>Finds surface area of a cube</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">surfarea_cube(1)  # returns 6
surfarea_cube(3)  # returns 54
surfarea_cube(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L4-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.surfarea_cuboid-Tuple{Any, Any, Any}" href="#TheAlgorithms.Math.surfarea_cuboid-Tuple{Any, Any, Any}"><code>TheAlgorithms.Math.surfarea_cuboid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surfarea_cuboid(length, width, height)</code></pre><p>Finds surface area of a cuboid</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">surfarea_cuboid(5, 5, 5)  # returns 150
surfarea_cuboid(-5, -5, -5)  # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L29-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.surfarea_sphere-Tuple{Any}" href="#TheAlgorithms.Math.surfarea_sphere-Tuple{Any}"><code>TheAlgorithms.Math.surfarea_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surfarea_sphere(side)</code></pre><p>Finds surface area of a sphere</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">surfarea_sphere(5)  # returns 314.1592653589793
surfarea_sphere(1)  # returns 12.566370614359172
surfarea_sphere(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L48-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.totient-Tuple{Int64}" href="#TheAlgorithms.Math.totient-Tuple{Int64}"><code>TheAlgorithms.Math.totient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">totient(n::Int)</code></pre><p>The totient function phi(n) is defined as the number of positive integers &lt;=n that are relatively prime to n. Since a number less than or equal to and relatively prime to a given number is called a totative, the totient function phi(n) can be simply defined as the number of totatives of n.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : The number to find the totient of.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">totient(1) # returns 1
totient(2) # returns 1
totient(3) # returns 2
totient(10) # returns 4
totient(24) # returns 8
totient(50) # returns 20
totient(-1) # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://mathworld.wolfram.com/TotientFunction.html</li></ul><p>Contributed by <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/eulers_totient.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.trapazoidal_area-NTuple{4, Any}" href="#TheAlgorithms.Math.trapazoidal_area-NTuple{4, Any}"><code>TheAlgorithms.Math.trapazoidal_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trapazoidal_area(f, x_start, x_end, steps)</code></pre><p>Approximates the area under the curve using the trapezoidal rule Arguments:</p><ul><li>f: function for the</li><li>x_start: starting value for x</li><li>x_end: ending value for x</li><li>steps: steps taken while integrating.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/area.jl#L284-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.trapezoid_integration-Tuple{Function, Real, Real, Int64}" href="#TheAlgorithms.Math.trapezoid_integration-Tuple{Function, Real, Real, Int64}"><code>TheAlgorithms.Math.trapezoid_integration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trapezoid_integration(f::Function, a::Real, b::Real, n::Int)</code></pre><p>The trapezoidal rule works by approximating the region under the graph of the function f(x) as a trapezoid and calculating its area.</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: the function to integrate. (at the momment only single variable is suported)</li><li><code>a</code>: Start of the integration limit.</li><li><code>b</code>: End of the integration limit.</li><li><code>n</code>: Number of points to sample. (as n increase, error decrease)</li></ul><p><strong>Examples/Test</strong></p><pre><code class="language-julia hljs">julia&gt; trapezoid_integration(x -&gt; 4 / (1 + x^2), 0, 1, 100_000)
3.1415926535731526
julia&gt; trapezoid_integration(x -&gt; 4 / (1 + x^2), 0, 1, 100_000) ≈ pi
true</code></pre><p><strong>References:</strong></p><p>-https://personal.math.ubc.ca/~pwalls/math-python/integration/trapezoid-rule/ -https://en.wikipedia.org/wiki/Trapezoidal_rule</p><p><strong>Contributed By:- <a href="https://github.com/AugustoCL">AugustoCL</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/trapezoid_integration.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.verlet_integration" href="#TheAlgorithms.Math.verlet_integration"><code>TheAlgorithms.Math.verlet_integration</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Verlet integration is an integration method used to integrate newtons - law of motion. It is frequently used to find trajectories in molecular dynamics simulation. The function takes <code>four</code> inputs viz,</p><ul><li><code>f</code> : the differential equation</li><li><code>x0</code> : the initial condition. This is a Vector with the first element as initial value for position (x<em>0) and the second initial condition for velocity (v</em>0) </li><li><code>tspan</code>: is the time span for integration. It is a tuple (initial time, final time)</li></ul><p>This functionr returns a tuple (x,t):</p><ul><li><code>x</code> is the solution</li><li><code>t</code> is the array containing the time points</li></ul><p>Reference:</p><ul><li>https://www.algorithm-archive.org/contents/verlet<em>integration/verlet</em>integration.html</li></ul><p>Contributed by: <a href="https://github.com/Ved-Mahajan">Ved Mahajan</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/verlet.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.vol_circular_cylinder-Tuple{Any, Any}" href="#TheAlgorithms.Math.vol_circular_cylinder-Tuple{Any, Any}"><code>TheAlgorithms.Math.vol_circular_cylinder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_circular_cylinder(area_of_, height)</code></pre><p>Compute the Volume of a Circular Cylinder.</p><p><strong>Examples</strong></p><p>```julia-repl julia&gt; vol<em>circular</em>cylinder(1, 1) 3.141592653589793 julia&gt; vol<em>circular</em>cylinder(4, 3) 150.79644737231007</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/volume.jl#L156-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.vol_cone-Tuple{Any, Any}" href="#TheAlgorithms.Math.vol_cone-Tuple{Any, Any}"><code>TheAlgorithms.Math.vol_cone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_cone(area_of_base, height)</code></pre><p>Compute the Volume of a Cone</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_cone(10, 3)
10.0
julia&gt; vol_cone(1, 1)
0.3333333333333333</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/volume.jl#L49-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.vol_cube-Tuple{Any}" href="#TheAlgorithms.Math.vol_cube-Tuple{Any}"><code>TheAlgorithms.Math.vol_cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_cube()</code></pre><p>Compute the volume of a cube.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_cube(1)
1
julia&gt; vol_cube(3)
27
julia&gt; vol_cube(-1)
DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/volume.jl#L5-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.vol_cuboid-Tuple{Any, Any, Any}" href="#TheAlgorithms.Math.vol_cuboid-Tuple{Any, Any, Any}"><code>TheAlgorithms.Math.vol_cuboid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_cuboid(width, height, length)</code></pre><p>Compute the volume of a vol_cuboid</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_cuboid(1, 1, 1)
1
julia&gt; vol_cuboid(1, 2, 3)
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/volume.jl#L28-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.vol_prism-Tuple{Any, Any}" href="#TheAlgorithms.Math.vol_prism-Tuple{Any, Any}"><code>TheAlgorithms.Math.vol_prism</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_prism(area_of_base, height)</code></pre><p>Compute the Volume of a Prism.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_prism(10, 2)
20.0
julia&gt; vol_prism(11, 1)
11.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/volume.jl#L94-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.vol_pyramid-Tuple{Any, Any}" href="#TheAlgorithms.Math.vol_pyramid-Tuple{Any, Any}"><code>TheAlgorithms.Math.vol_pyramid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_pyramid(area_of_base, height)</code></pre><p>Compute the volume of a Pyramid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_pyramid(10, 3)
10.0
julia&gt; vol_pyramid(1.5, 3)
1.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/volume.jl#L115-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.vol_right_circ_cone-Tuple{Any, Any}" href="#TheAlgorithms.Math.vol_right_circ_cone-Tuple{Any, Any}"><code>TheAlgorithms.Math.vol_right_circ_cone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_right_circ_cone(radius, height)</code></pre><p>Compute the Volume of a Right Circular Cone.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; vol_right_circ_cone(2, 3)
12.566370614359172</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/volume.jl#L71-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Math.vol_sphere-Tuple{Any}" href="#TheAlgorithms.Math.vol_sphere-Tuple{Any}"><code>TheAlgorithms.Math.vol_sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vol_sphere(radius)</code></pre><p>Compute the volume of a sphere.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">vol_sphere(5)  # returns 523.5987755982989
vol_sphere(1)  # returns 4.1887902047863905
vol_sphere(-1) # returns DomainError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/volume.jl#L136-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.MatrixAlgo" href="#TheAlgorithms.MatrixAlgo"><code>TheAlgorithms.MatrixAlgo</code></a> — <span class="docstring-category">Module</span></header><section><div><p>MatrixAlgo</p><p><code>MatrixAlgo</code> for matrix algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/matrix/MatrixAlgo.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.MatrixAlgo.determinant-Tuple{Any}" href="#TheAlgorithms.MatrixAlgo.determinant-Tuple{Any}"><code>TheAlgorithms.MatrixAlgo.determinant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">determinant(mat)</code></pre><p>Given a non singluar matrix, calculate its determinant using LU decomposition.</p><p>L and U are lower triangular and upper triangular matrices respectively such that</p><p>A = L*U</p><p>If we want to find the determinant, then</p><p>det(A) = det(LU) = det(L)*det(U)</p><p>Determinant of triangualar matrices is the product of their diagonal entries. Hence, makes finding the determinant easy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/matrix/determinant.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.MatrixAlgo.gauss_jordan-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number" href="#TheAlgorithms.MatrixAlgo.gauss_jordan-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:Number"><code>TheAlgorithms.MatrixAlgo.gauss_jordan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gauss_jordan(A::AbstractMatrix{T}) where T&lt;:Number</code></pre><p>Gaussian elimination, also known as row reduction, is an algorithm for solving systems of linear equations.  It consists of a sequence of operations performed on the corresponding matrix of coefficients.  This method can also be used to compute the rank of a matrix, the determinant of a square matrix, and the inverse of an invertible matrix. https://en.wikipedia.org/wiki/Gaussian_elimination</p><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; M1 = [1 2 3; 4 5 6];
julia&gt; M2 = [1 2 3; 4 8 12];

julia&gt; @test gauss_jordan(M1) == [1 0 -1; 0 1 2]        # Test Passed
julia&gt; @test_throws AssertionError gauss_jordan(M2)     # Test Passed - Thrown: AssertionError</code></pre><p><strong>Contributed By:- <a href="https://github.com/AugustoCL">AugustoCL</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/matrix/gauss_jordan_elim.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.MatrixAlgo.lu_decompose-Tuple{Any}" href="#TheAlgorithms.MatrixAlgo.lu_decompose-Tuple{Any}"><code>TheAlgorithms.MatrixAlgo.lu_decompose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lu_decompose(mat)</code></pre><p>Decomposes a <code>n x n</code> non singular matrix into a lower triangular matrix (L) and an upper triangular matrix (U)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/matrix/lu_decompose.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.MatrixAlgo.rotation_matrix-Tuple{Any}" href="#TheAlgorithms.MatrixAlgo.rotation_matrix-Tuple{Any}"><code>TheAlgorithms.MatrixAlgo.rotation_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A 2D Rotation matrix is a mtrix that rotates a vector in a 2D real space by an angle theta. For more info: https://en.wikipedia.org/wiki/Rotation_matrix</p><p>This function takes the angle <code>theta</code> in radians as input and returns a 2D Matrix which will rotate the vector by angle <code>theta</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/matrix/rotation_matrix.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler" href="#TheAlgorithms.ProjectEuler"><code>TheAlgorithms.ProjectEuler</code></a> — <span class="docstring-category">Module</span></header><section><div><p>ProjectEuler</p><p><code>ProjectEuler</code> naive solutions in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/ProjectEuler.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.aliquot_sum-Tuple{Int64}" href="#TheAlgorithms.ProjectEuler.aliquot_sum-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.aliquot_sum</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aliquot_sum(n::Int)</code></pre><p>The aliquot sum of a positive integer n is the sum of all the proper divisors of n, i.e, all divisors of n other than n itself.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : The number to find the aliquot sum of.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">aliquot_sum(6)      # returns 6
aliquot_sum(10)     # returns 8
aliquot_sum(1345)   # returns 275
aliquot_sum(-1)     # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://en.wikipedia.org/wiki/Aliquot_sum</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/divisors.jl#L50-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.divisors-Tuple{Int64}" href="#TheAlgorithms.ProjectEuler.divisors-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.divisors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">divisors(n::Int)</code></pre><p>Returns the divisors of n as a vector.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : The number to find the factors of.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">divisors(6)     # returns [1, 2, 3, 6]
divisors(10)    # returns [1, 2, 5, 10]
divisors(1345)  # returns [1, 5, 269, 1345]
divisors(-1)    # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://mathworld.wolfram.com/Divisor.html</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/divisors.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.eratosthenes-Tuple{Any}" href="#TheAlgorithms.ProjectEuler.eratosthenes-Tuple{Any}"><code>TheAlgorithms.ProjectEuler.eratosthenes</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sieve of Eratosthenes is an algorithm for finding all the primes upto a limit <code>n</code>.</p><p>Reference: -https://en.wikipedia.org/wiki/Sieve<em>of</em>Eratosthenes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/sieve_of_eratosthenes.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.num_divisors-Tuple{Int64}" href="#TheAlgorithms.ProjectEuler.num_divisors-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.num_divisors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_divisors(n::Int)</code></pre><p>Efficiently finds the number of divisors of n.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : The number to find the number of divisors of.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">num_divisors(1)       # returns 1
num_divisors(13)      # returns 2
num_divisors(420)     # returns 24
num_divisors(1345)    # returns 4
num_divisors(-1)      # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://cp-algorithms.com/algebra/divisors.html#number-of-divisors</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/divisors.jl#L74-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.problem_001-Tuple{Int64}" href="#TheAlgorithms.ProjectEuler.problem_001-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_001</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Multiples of 3 or 5</code></pre><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p><p>Find the sum of all the multiples of 3 or 5 below 1000.</p><p><strong>Input parameters:</strong></p><ul><li><code>limit</code> : Upper limit for the numbers.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">problem_001(10)     # returns 23
problem_001(1000)   # returns 233168
problem_001(-1)     # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://projecteuler.net/problem=1</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/problem_001.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.problem_002-Tuple{Int64}" href="#TheAlgorithms.ProjectEuler.problem_002-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_002</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Even Fibonacci numbers</code></pre><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p><p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p><p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p><p><strong>Input parameters:</strong></p><ul><li><code>limit</code> : Upper limit for the numbers.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">problem_002(10)         # returns 10
problem_002(4_000_000)  # returns 4613732
problem_002(-1)         # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://projecteuler.net/problem=2</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/problem_002.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.problem_003-Tuple{Number}" href="#TheAlgorithms.ProjectEuler.problem_003-Tuple{Number}"><code>TheAlgorithms.ProjectEuler.problem_003</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Largest prime factor</code></pre><p>The prime factors of 13195 are 5, 7, 13 and 29.</p><p>What is the largest prime factor of the number 600851475143 ?</p><p><strong>Input parameters:</strong></p><ul><li><code>number</code> : Number to find the largest prime factor of.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">problem_003(17)             # returns 17
problem_003(13195)          # returns 29
problem_003(600851475143)   # returns 6857
problem_003(-1)             # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://projecteuler.net/problem=3</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/problem_003.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.problem_004-Tuple{}" href="#TheAlgorithms.ProjectEuler.problem_004-Tuple{}"><code>TheAlgorithms.ProjectEuler.problem_004</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Largest palindrome product</code></pre><p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.</p><p>Find the largest palindrome made from the product of two 3-digit numbers.</p><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">problem_004()   # returns 906609</code></pre><p><strong>Reference</strong></p><ul><li>https://projecteuler.net/problem=4</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/problem_004.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.problem_005-Tuple{Int64}" href="#TheAlgorithms.ProjectEuler.problem_005-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_005</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Smallest multiple</code></pre><p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p><p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p><p><strong>Input parameters:</strong></p><ul><li><code>limit</code>: Limit upto which to find the smallest multiple.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">problem_005(10) # returns 2520
problem_005(20) # returns 232792560
problem_005(-1) # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://projecteuler.net/problem=5</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/problem_005.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.problem_006-Tuple{Int64}" href="#TheAlgorithms.ProjectEuler.problem_006-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_006</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Sum square difference</code></pre><p>The sum of the squares of the first ten natural numbers is,     1^2 + 2^2 + ... + 10^2 = 385</p><p>The square of the sum of the first ten natural numbers is,     (1 + 2 + ... + 10)^2 = 55^2 = 3025</p><p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : limit upto which to find the sum square difference.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">problem_006(10)     # returns 2640
problem_006(100)    # returns 25164150
problem_006(-1)     # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://projecteuler.net/problem=6</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/problem_006.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.problem_007-Tuple{Int64}" href="#TheAlgorithms.ProjectEuler.problem_007-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_007</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">10001st prime</code></pre><p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.</p><p>What is the 10 001st prime number?</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : Will find the nth prime.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">problem_007(1)      # returns 2
problem_007(6)      # returns 13
problem_007(10001)  # returns 104743
problem_007(-1)     # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://projecteuler.net/problem=7</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/problem_007.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.problem_008-Tuple{String, Int64}" href="#TheAlgorithms.ProjectEuler.problem_008-Tuple{String, Int64}"><code>TheAlgorithms.ProjectEuler.problem_008</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Largest product in a series</code></pre><p>The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.</p><p>Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?</p><p><strong>Input parameters:</strong></p><ul><li><code>num_str</code> : The number to find the greatest product in, in string form.</li><li><code>n</code> : Number of consecutive numbers to find the product of.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">num_str = &quot;7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450&quot;
problem_008(&quot;1234&quot;, 2)      # returns 12
problem_008(num_str, 4)     # returns 5832    
problem_008(num_str, 13)    # returns 23514624000
problem_008(&quot;12345&quot;, 6)     # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://projecteuler.net/problem=8</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/problem_008.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.problem_009-Tuple{}" href="#TheAlgorithms.ProjectEuler.problem_009-Tuple{}"><code>TheAlgorithms.ProjectEuler.problem_009</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Special Pythagorean triplet</code></pre><p>A Pythagorean triplet is a set of three natural numbers, a &lt; b &lt; c, for which, a2 + b2 = c2</p><p>For example, 32 + 42 = 9 + 16 = 25 = 52.</p><p>There exists exactly one Pythagorean triplet for which a + b + c = 1000. Find the product abc.</p><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">problem_009()   # returns 31875000</code></pre><p><strong>Reference</strong></p><ul><li>https://projecteuler.net/problem=9</li><li>https://en.wikipedia.org/wiki/Pythagorean<em>triple#Generating</em>a_triple</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/problem_009.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.problem_010-Tuple{Int64}" href="#TheAlgorithms.ProjectEuler.problem_010-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_010</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Summation of primes</code></pre><p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.</p><p>Find the sum of all the primes below two million.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : Upper limit of primes.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">problem_010(1)          # returns 0
problem_010(10)         # returns 17
problem_010(2000000)    # returns 142913828922
problem_010(-1)         # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://projecteuler.net/problem=10</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/problem_010.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.problem_012-Tuple{Int64}" href="#TheAlgorithms.ProjectEuler.problem_012-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_012</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Highly Divisible Triangular Number</code></pre><p>The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1+2+3+4+5+6+7 = 28. The first ten terms would be 1,3,6,10,15,21,28,36,45,55,... What is the value of the first triangle number to have over 500 divisors?</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : the triangle number must have over n divisors.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">problem_012(5)          # returns 28
problem_012(333)        # returns 17907120
problem_012(500)        # returns 76576500
problem_012(-1)         # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://projecteuler.net/problem=12</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/problem_012.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.problem_013-Tuple{}" href="#TheAlgorithms.ProjectEuler.problem_013-Tuple{}"><code>TheAlgorithms.ProjectEuler.problem_013</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Large Sum</code></pre><p>Work out the first ten digits of the sum of the given one-hundred 50-digit numbers.</p><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">problem_013()   # returns &quot;5537376230&quot;</code></pre><p><strong>Reference</strong></p><ul><li>https://projecteuler.net/problem=13</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/problem_013.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.problem_014-Tuple{Int64}" href="#TheAlgorithms.ProjectEuler.problem_014-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.problem_014</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Longest Collatz Sequence</code></pre><p>The following iterative sequence is defined for the set of positive integers: n -&gt; n/2  (n is even) n -&gt; 3n+1 (n is odd) Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1. Which starting number, under one million, produces the longest chain?</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : upper bound on the starting number</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">problem_014(10)         # returns 9
problem_014(250)        # returns 231
problem_014(1000000)    # returns 837799
problem_014(-1)         # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://projecteuler.net/problem=14</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_euler/problem_014.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectEuler.sum_divisors-Tuple{Int64}" href="#TheAlgorithms.ProjectEuler.sum_divisors-Tuple{Int64}"><code>TheAlgorithms.ProjectEuler.sum_divisors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sum_divisors(n::Int)</code></pre><p>Returns the sum of the divisors of n.</p><p><strong>Input parameters:</strong></p><ul><li><code>n</code> : The number to find the sum of divisors of.</li></ul><p><strong>Examples/Tests:</strong></p><pre><code class="language-julia hljs">sum_divisors(6)     # returns 12
sum_divisors(10)    # returns 18
sum_divisors(1345)  # returns 1620
sum_divisors(-1)    # throws DomainError</code></pre><p><strong>Reference</strong></p><ul><li>https://mathworld.wolfram.com/Divisor.html</li></ul><p>Contributed by: <a href="https://www.github.com/PraneethJain">Praneeth Jain</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/math/divisors.jl#L26-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectRosalind" href="#TheAlgorithms.ProjectRosalind"><code>TheAlgorithms.ProjectRosalind</code></a> — <span class="docstring-category">Module</span></header><section><div><p>ProjectRosalind</p><p><code>ProjectRosalind</code> naive solutions and algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_rosalind/ProjectRosalind.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectRosalind.count_nucleotides-Tuple{AbstractString}" href="#TheAlgorithms.ProjectRosalind.count_nucleotides-Tuple{AbstractString}"><code>TheAlgorithms.ProjectRosalind.count_nucleotides</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_nucleotides(s::AbstractString)</code></pre><p>Given: A DNA string s</p><p>of length at most 1000 nt.</p><p>Return: Four integers (separated by spaces) counting the respective number of times that the symbols &#39;A&#39;, &#39;C&#39;, &#39;G&#39;, and &#39;T&#39; occur in s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_rosalind/count_nucleotide.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.ProjectRosalind.dna2rna-Tuple{AbstractString}" href="#TheAlgorithms.ProjectRosalind.dna2rna-Tuple{AbstractString}"><code>TheAlgorithms.ProjectRosalind.dna2rna</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dna2rna(s::AbstractString)</code></pre><p>Given: A DNA string t</p><p>having length at most 1000 nt.</p><p>Return: The transcribed RNA string of t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/project_rosalind/dna2_rna.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Scheduling" href="#TheAlgorithms.Scheduling"><code>TheAlgorithms.Scheduling</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Scheduling</p><p><code>Scheduling</code> algorithms in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/scheduling/Scheduling.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Scheduling.fcfs-Tuple{Any, Any, Any}" href="#TheAlgorithms.Scheduling.fcfs-Tuple{Any, Any, Any}"><code>TheAlgorithms.Scheduling.fcfs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fcfs(n, process_id, burst_time)</code></pre><p>Implementation of first come first served scheduling algorithm</p><p><strong>Output</strong></p><p>Tuple of vectors (process<em>id, burst</em>time, waiting<em>time, turnaround</em>time, avg<em>waiting</em>time, avg<em>turnaround</em>time)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">n = 3 # number of processes
process_id = Any[1, 2, 3] # process ids
burst_times = Any[3, 4, 5] # burst times
fcfs(n, process_id, burst_times)</code></pre><p><strong>Reference</strong></p><p>https://en.wikipedia.org/wiki/Scheduling<em>(computing)#First</em>come,<em>first</em>served</p><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ashwani Rathee</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/scheduling/fcfs.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Searches" href="#TheAlgorithms.Searches"><code>TheAlgorithms.Searches</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Searches</p><p><code>Searches</code> - search algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/searches/Searches.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Searches.binary_search-Tuple{Any, Any}" href="#TheAlgorithms.Searches.binary_search-Tuple{Any, Any}"><code>TheAlgorithms.Searches.binary_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">binary_search(list, query; rev=false, lt=&lt;, by=identity)</code></pre><p>Implement a binary search algorithm. Searching a sorted collection is a common task. A dictionary is a sorted list of word definitions. Given a word, one can find its definition. A telephone book is a sorted list of people&#39;s names, addresses, and telephone numbers. Knowing someone&#39;s name allows one to quickly find their telephone number and address.</p><p>If the list to be searched contains more than a few items (a dozen, say) a binary search will require far fewer comparisons than a linear search, but it imposes the requirement that the list be sorted.</p><p>In computer science, a binary search or half-interval search algorithm finds the position of a specified input value (the search &quot;key&quot;) within an array sorted by key value.</p><p>In each step, the algorithm compares the search key value with the key value of the middle element of the array.</p><p>If the keys match, then a matching element has been found and the range of indices that equal the search key value are returned.</p><p>Otherwise, if the search key is less than the middle element&#39;s key, then the algorithm repeats its action on the sub-array to the left of the middle element or, if the search key is greater, on the sub-array to the right.</p><p>If the remaining array to be searched is empty, then the key cannot be found in the array and a special &quot;not found&quot; indication is returned. Search methods in Julia typically return an empty range located at the insertion point in this case.</p><p>A binary search halves the number of items to check with each iteration, so locating an item (or determining its absence) takes logarithmic time. A binary search is a dichotomic divide and conquer search algorithm.</p><p>Bonus task: Implement keyword arguments by, lt and rev so that by specifies a transformation applied to all elements of the list, lt specifies a comparison and rev specifies if the list is ordered in reverse.</p><p>Contributed By:- <a href="https://github.com/uncomfyhalomacro">Soc Virnyl Estela</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/searches/binary_search.jl#L6-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Searches.binary_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real" href="#TheAlgorithms.Searches.binary_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real"><code>TheAlgorithms.Searches.binary_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">binary_search(arr::AbstractArray{T,1}, l::T, r::T, x::T) where {T&lt;:Real}</code></pre><p>The implementation of this binary Search is recursive and requires O(Log n) space. With iterative Binary Search, we need only O(1) space. Useful for the implementation of <code>exponential_search</code>.</p><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ash</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/searches/binary_search.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Searches.exponential_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:Real" href="#TheAlgorithms.Searches.exponential_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:Real"><code>TheAlgorithms.Searches.exponential_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> exponential_search(arr::AbstractArray{T,1}, x::T) where {T &lt;: Real}</code></pre><p>Exponential Search in 1-D array Time Complexity:  O(Log n)</p><p><strong>Exponential Search</strong></p><p>It works in O(Log n) time Exponential search involves two steps:</p><ul><li>Find range where element is present</li><li>Do Binary Search in above found range.</li></ul><p><strong>Time Complexity :</strong></p><p>O(Log n) Applications of Exponential Search: Exponential Binary Search is particularly useful for unbounded searches, where size of array is infinite. Please refer Unbounded Binary Search for an example. It works better than Binary Search for bounded arrays, and also when the element to be searched is closer to the first element.</p><p>Contributed By:- <a href="https://github.com/ashwani-rathee">Ash</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/searches/exponential_search.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Searches.interpolation_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real" href="#TheAlgorithms.Searches.interpolation_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T, T}} where T&lt;:Real"><code>TheAlgorithms.Searches.interpolation_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> interpolation_search(arr::AbstractArray{T,1}, l::T, r::T, x::T) where {T &lt;: Real}</code></pre><p>Interpolation Search in 1-D array Time Complexity: O(log2(log2 n))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/searches/interpolation_search.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Searches.jump_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:Real" href="#TheAlgorithms.Searches.jump_search-Union{Tuple{T}, Tuple{AbstractVector{T}, T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:Real"><code>TheAlgorithms.Searches.jump_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jump_search(arr::AbstractArray{T,1}, x::T, jump::T = Int(ceil(sqrt(n)))) where {T &lt;: Real}</code></pre><p>Jump Search in 1-D array Time Complexity :  O(√ n) Time complexity of Jump Search is between Linear Search ( ( O(n) ) and Binary Search ( O (Log n) )</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/searches/jump_search.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Searches.linear_search-Tuple{Any, Any}" href="#TheAlgorithms.Searches.linear_search-Tuple{Any, Any}"><code>TheAlgorithms.Searches.linear_search</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">linear_search(array, key)</code></pre><p>A simple search of <code>array</code>, element per element until <code>key</code> is found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/searches/linear_search.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Sorts" href="#TheAlgorithms.Sorts"><code>TheAlgorithms.Sorts</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Sorts</p><p><code>Sorts</code> are sorting algorithms in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/sorts/Sorts.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Sorts.counting_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Int64}, Tuple{Vector{T}, Int64, Int64}} where T" href="#TheAlgorithms.Sorts.counting_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Int64}, Tuple{Vector{T}, Int64, Int64}} where T"><code>TheAlgorithms.Sorts.counting_sort!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>Counting Sort</strong></p><p>OVERVIEW: Counting Sort is a sorting algorithm that sort elements within a specific range. The sorting technique is to count the existing element and stored its occurrence time in a new list, then only print it out.</p><p>STEPS:  Assume the input as –&gt; x=[-3, 1, -5, 0, -3]   minimum = -5</p><ul><li><p>STEP 1: Create a list size within the range, in this case is -5 –&gt; 1 which have range of 7 (-5, -4, -3, -2, -1, 0, 1), so list with size 7 and assign all to 0 is created</p></li><li><p>STEP 2: Count the occurances of element in the list          First number = -3 it is the third number in the range, so count[3]+=1         Final view:         index : ( 1,  2,  3,  4,  5, 6, 7)         range : (-5, -4, -3, -2, -1, 0, 1)         count : [ 1,  0,  2,  0,  0, 1, 1] &lt;– the list will store this occurrence</p></li><li><p>STEP 3: Make the count list accumulate the occurances          The final count is (1, 1, 3, 3, 3, 4, 5)</p></li><li><p>STEP 4: Assign the elements in x into correct possition by creating a new list (will call &#39;output&#39; in this sample)         the 1st element in &#39;x&#39; is -3, it is third in range, so it will call the index of 3 in &#39;count&#39;, which is 3 and assign the -3 in to 3rd position in &#39;output&#39;,          then the third element in range will deduct by 1, so the next repeated element will get the correct position, new &#39;count&#39; –&gt; [1, 1, 2, 3, 3, 4, 5]</p><pre><code class="nohighlight hljs">    the 2nd element in &#39;x&#39; is  1, it is last  in range, so it will call the index of 7 in &#39;count&#39;, which is 5 and assign the  1 in to 5th position in &#39;output&#39;, 
    new &#39;count&#39; --&gt; [1, 1, 2, 3, 3, 4, 4]
    ......
    ......
    *If you want the order of original array to have the same order as the output array use can change this to decremental for loop</code></pre></li><li><p>STEP 5: Assign the &#39;output&#39; list back to &#39;x&#39;</p></li></ul><p>FINAL RESULT –&gt;  [-5, -3, -3, 0, 1]                                                                                    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/sorts/counting_sort.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Sorts.heap_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Any}, Tuple{Vector{T}, Any, Int64}} where T" href="#TheAlgorithms.Sorts.heap_sort!-Union{Tuple{Vector{T}}, Tuple{T}, Tuple{Vector{T}, Any}, Tuple{Vector{T}, Any, Int64}} where T"><code>TheAlgorithms.Sorts.heap_sort!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">heap_sort!(arr::Vector{T}, gt = &gt;, N::Int = length(arr)) where {T}</code></pre><p>Sort the given vector (in-place) using the Heapsort algorithm.</p><p>Heapsort consists of two stages:</p><ol><li>Building a (max) heap of the array</li><li>Repeatedly extracting the largest element and inserting it at the front of the sorted part of the array</li></ol><p>After the largest element has been extracted, the tree is updated to maintain the heap property via a &quot;sifting&quot; operation.</p><p>Storing a heap in an array is pretty straightforward - for every node with index n, its children are stored at indices   2n + 1 and 2n + 2 (for 0-based indices). Index 0 contains the root node.   Since Julia&#39;s indices are 1-based, we need to change this a little bit. We&#39;re using a trivial helper function    idx_for to convert from 0-based to 1-based.</p><p>See https://en.wikipedia.org/wiki/Heapsort for a complete explanation of Heapsort.</p><p>Contributed By:- <a href="https://github.com/frankschmitt">Frank Schmitt</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/sorts/heap_sort.jl#L10-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.Sorts.idx_for-Tuple{Int64}" href="#TheAlgorithms.Sorts.idx_for-Tuple{Int64}"><code>TheAlgorithms.Sorts.idx_for</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">idx_for(i::Int)</code></pre><p>Simple helper function for converting 0-based indices to Julia&#39;s 1-based indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/sorts/heap_sort.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.StatAlgo" href="#TheAlgorithms.StatAlgo"><code>TheAlgorithms.StatAlgo</code></a> — <span class="docstring-category">Module</span></header><section><div><p>StatAlgo</p><p><code>StatAlgo</code> in Julia</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/statistics/StatAlgo.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.StatAlgo.variance-Tuple{Any}" href="#TheAlgorithms.StatAlgo.variance-Tuple{Any}"><code>TheAlgorithms.StatAlgo.variance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">variance(a)</code></pre><p>Find the variance from a set of data.</p><p><strong>Arguments:</strong></p><ul><li><code>a</code>: holds the set of data</li></ul><p><strong>Reference</strong></p><pre><code class="nohighlight hljs">- According to Ronald E. Walpole, `variance` is used to measure the variability of a set of data. -- Introduction to Statistics by Ronald E. Walpole</code></pre><p><strong>Contributors:</strong></p><ul><li><a href="https://github.com/arubhardwaj">Aru Bhardwaj</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/statistics/variance.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.StringAlgo" href="#TheAlgorithms.StringAlgo"><code>TheAlgorithms.StringAlgo</code></a> — <span class="docstring-category">Module</span></header><section><div><p>StringAlgo</p><p><code>StringAlgo</code> in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/strings/StringAlgo.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.StringAlgo.detect_anagrams-Tuple{Any, Any}" href="#TheAlgorithms.StringAlgo.detect_anagrams-Tuple{Any, Any}"><code>TheAlgorithms.StringAlgo.detect_anagrams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">detect_anagrams(subject, candidates)</code></pre><p>A function that checks if a list of words is an <a href="https://en.wikipedia.org/wiki/Anagram">Anagram</a> or not of a subject word.</p><p>is the original word = subject is list of words to be compared if they are an anagram of <code>subject</code> = candidates</p><pre><code class="nohighlight hljs">julia&gt; subject = &quot;listen&quot;
julia&gt; candidates = [&quot;inlets&quot;, &quot;enlists&quot;, &quot;google&quot;, &quot;banana&quot;]
julia&gt; detect_anagrams(subject, candidates)
1-element Vector{String}:
 &quot;inlets&quot;</code></pre><p>Contributed By:- <a href="https://github.com/ReneganRonin">Soc V. E.</a> Based on my exercism&#39;s Julia track problem solution on <a href="https://exercism.io/my/solutions/0a1d39faa5694624b7750be3ebf6c974">Anagrams</a>.</p><p>Instructions:</p><p>An anagram is a rearrangement of letters to form a new word. Given a word and a list of candidates, select the sublist of anagrams of the given word. Given &quot;listen&quot; and a list of candidates like &quot;enlists&quot; &quot;google&quot; &quot;inlets&quot; &quot;banana&quot; the program should return a list containing &quot;inlets&quot;.</p><p>Inspired by the <a href="https://github.com/rchatley/extreme_startup">Extreme Startup game</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/strings/detect_anagrams.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.StringAlgo.ispangram-Tuple{Any}" href="#TheAlgorithms.StringAlgo.ispangram-Tuple{Any}"><code>TheAlgorithms.StringAlgo.ispangram</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ispangram(input)</p><p>Program to determine the sentence is pangram or not.The program will return true if it is pangram and false if it is not.A full description of the algorithm can be found on <a href="https://exercism.org/tracks/julia/exercises/pangram">exercism</a></p><p><strong>Arguments:</strong></p><ul><li><code>input</code>: The sentence to find if its pangram or not.</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; ispangram(Pack my box with five dozen liquor jugs)
true

julia&gt; ispangram(The quick brown fox jumps over the lazy dog)
true

julia&gt; wordcount(hello world!!!)
false
</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">
for letter in input
    if &#39;A&#39; &lt;= letter &lt;= &#39;Z&#39;
        x &amp;= ~(1&lt;&lt;(letter-&#39;A&#39;))
    elseif &#39;a&#39; &lt;= letter &lt;= &#39;z&#39;
        x &amp;= ~(1&lt;&lt;(letter-&#39;a&#39;))
    end
    x == 0 &amp;&amp; return true
end
</code></pre><p><strong>References:</strong></p><p>(https://exercism.org/tracks/julia/exercises/pangram)</p><p>```</p><p><strong>Contributed by:- <a href="https://github.com/Ihjass">Ihjass Thasbekha</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/strings/pangram.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.StringAlgo.rabin_karp-Tuple{String, String}" href="#TheAlgorithms.StringAlgo.rabin_karp-Tuple{String, String}"><code>TheAlgorithms.StringAlgo.rabin_karp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rabin_karp(text, pattern)</code></pre><p><strong>Brief:</strong></p><pre><code class="nohighlight hljs">A function that finds all occurrences of a pattern in the given text.
Instead of checking each character ot the pattern with each character block of the text,
for each character block calculate the hash value, and only if that value matches hash value of the pattern,
compare them character by character. These blocks are the same length as the pattern.</code></pre><p><strong>Returns:</strong></p><pre><code class="nohighlight hljs">A list with starting indices where the pattern was found</code></pre><p><strong>References:</strong></p><pre><code class="nohighlight hljs">https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/</code></pre><p><strong>Contributed by: <a href="https://github.com/Nikola-Mircic">Nikola Mircic</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/strings/rabin_karp.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TheAlgorithms.StringAlgo.word_count-Tuple{Any}" href="#TheAlgorithms.StringAlgo.word_count-Tuple{Any}"><code>TheAlgorithms.StringAlgo.word_count</code></a> — <span class="docstring-category">Method</span></header><section><div><p>wordcount(sentence)</p><p>Program to find word count in the given sentence. The program will return count with the word. A full description of the algorithm can be found on <a href="https://exercism.org/tracks/julia/exercises/word-count">exercism</a></p><p><strong>Arguments:</strong></p><ul><li><code>sentence</code>: The sentence to find the word count.</li></ul><p><strong>Examples/Tests</strong></p><pre><code class="language-julia hljs">julia&gt; wordcount(The quick brown fox jumps over the lazy dog)
Dict{Any, Any}(&quot;jumps&quot; =&gt; 1, &quot;the&quot; =&gt; 2, &quot;brown&quot; =&gt; 1, &quot;over&quot; =&gt; 1, &quot;quick&quot; =&gt; 1, &quot;lazy&quot; =&gt; 1, &quot;dog&quot; =&gt; 1, &quot;fox&quot; =&gt; 1)

julia&gt; wordcount(the sky is blue and beautiful)
Dict{Any, Any}(&quot;and&quot; =&gt; 1, &quot;the&quot; =&gt; 1, &quot;sky&quot; =&gt; 1, &quot;blue&quot; =&gt; 1, &quot;is&quot; =&gt; 1, &quot;beautiful&quot; =&gt; 1)
</code></pre><p><strong>Algorithm:</strong></p><pre><code class="language-julia hljs">
for word in eachmatch(reg_expression, sentence)
    if !haskey(counts, word.match)
        counts[word.match] = 1
    else
        counts[word.match] += 1
    end
end
</code></pre><p><strong>References:</strong></p><p>(https://exercism.org/tracks/julia/exercises/word-count)</p><p>```</p><p><strong>Contributed by:- <a href="https://github.com/Ihjass">Ihjass Thasbekha</a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/TheAlgorithms/Julia/blob/40586f4c0fc11b9814b7aabef1b01e2975b332c0/src/strings/word_count.jl#L1-L40">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Monday 2 October 2023 20:29">Monday 2 October 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
